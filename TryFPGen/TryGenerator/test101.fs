//this code is automaticly generated by yaccConstractor with FParsecGenerator
module test

open FParsec.Primitives

  (*IF-OCAML*)  
    let find_assoc = List.assoc 
  (*ENDIF-OCAML*)
  (*F#
let find_assoc key list = snd <| List.find (fst >> (=) key) list
   F#*)

let rec private binExpr operand binOp list = operand list >>= fun (l ) -> (many ( attempt(binOp  >>= fun (_  as _1) ->(operand list |>> fun (_ as _2)   -> (_1,_2 )))) |>> fun (r) -> (List.fold (fun l (op,r) -> op l r) l r ) )  

 and private termOp   = (attempt (Lexer.literal "+" |>> fun (_) -> (( +. ))   )) <|> (Lexer.literal "-" |>> fun (_) -> ( ( -. ) )   )

 and private factorOp   = (attempt (Lexer.pMULT |>> fun (_) -> (( *. ))   )) <|> (Lexer.pDIV |>> fun (_) -> ( ( /. ) )   )

 and private powOp   = Lexer.pPOW |>> fun (_) -> ( ( ** ) )   

 and private powExpr  list = (attempt (Lexer.pNUMBER |>> fun (n) -> ( float n )   )) <|> ((attempt (Lexer.pVAR |>> fun (s) -> ( find_assoc s list )   )) <|> (Lexer.pLEFT >>= fun (_  as _1) ->(exprCalc list >>= fun (_  as _2) ->(Lexer.pRIGHT |>> fun (_ as _3)   -> (_2 )))))

 and private factor  list = binExpr  powExpr powOp list |>> fun (_ as _1)   -> (_1 )

 and private term  list = binExpr  factor factorOp list |>> fun (_ as _1)   -> (_1 )

 and private exprCalc  list = binExpr  term termOp list |>> fun (_ as _1)   -> (_1 )

 and private definition  list = Lexer.pVAR >>= fun (_  as _1) ->(Lexer.pEQUAL >>= fun (_  as _2) ->(exprCalc list |>> fun (_ as _3)   -> (_1,_3 )))

 and private definitionList  list = (attempt (definition list >>= fun (l  as _1) ->(definitionList (l::list) |>> fun (_ as _2)   -> (_2 )))) <|> (preturn  list )

 and public expr   = definitionList  []  >>= fun (list  as _1) ->(exprCalc list |>> fun (_ as _2)   -> (_2 ))