// CodeGenerator.fs
//
// Copyright 2009-2010 Semen Grigorev
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation.

namespace  Yard.Generators._RACCGenerator

open Yard.Core.IL
open Yard.Core.IL.Definition
open Yard.Core.IL.Production
open Yard.Core.IL.Rule

type CodeGenerator(outPath: string) = 
    class        

        let ruleToAction = ref []

        let textWriter = TextWriter outPath                                
        let write str = textWriter.Write(str)
         
        let generatePreheader grammarName =
            write "//this file was generated by RACC"
            write ("//source grammar:" + grammarName )
            write ("//date:" + System.DateTime.Now.ToString())
            write ""
            write ("module RACC.Actions")
            write ""
            write ("open Yard.Generators._RACCGenerator")

        let notMatched = 
            let msg =
#if DEBUG
                "1"
#endif
            "| x -> Unexpected "

        let generateHeader header = 
            if (Option.isSome header)
            then write (Source.toString header.Value)            
                                      
        let generateFooter footer =
            if (Option.isSome footer)
            then write (Source.toString footer.Value)

        let rec generateBody indentSize body =
            let lAltFName = "yardLAltAction"
            let rAltFName = "yardRAltAction"
            let elemFName = "yardElemAction"
            let indentString l = 
                List.init l (fun i -> "    ")
                |> String.concat ""                 
            match body with 
            | PSeq(elems,expr) -> 
                let num = Enumerator()
                let namesPair = 
                    List.map 
                        (fun elem -> 
                            if Option.isSome elem.binding
                            then  Source.toString elem.binding.Value, "x" + num.Next().ToString()
                            else "_","_")
                        elems
                    
                let namesMap = dict namesPair

                let genElem elem =
                    if Option.isSome elem.binding
                    then 
                          let eFun = generateBody (indentSize + 3) elem.rule
                          indentString (indentSize + 1) + "let (" + Source.toString elem.binding.Value + ") =\n"
                        + indentString (indentSize + 2) + "let " + elemFName + " expr = \n" + eFun + "\n"
                        + indentString (indentSize + 2) + elemFName + "(" + namesMap.[Source.toString elem.binding.Value] + ")"
                    else ""
                                        
                indentString indentSize + "match expr with\n"
                + indentString indentSize + "| RESeq [" + (List.unzip namesPair |> snd |> String.concat "; ") + "] -> \n"
                + (List.map genElem elems |> String.concat "\n")
                + if expr.IsSome
                  then indentString (indentSize + 1) + "box (" + Source.toString expr.Value + ")\n"
                  else indentString (indentSize + 1) + "box ()"
                 
            | PAlt(alt1,alt2)  -> 
                 let lFun = generateBody (indentSize + 2) alt1
                 let rFun = generateBody (indentSize + 2) alt2
                 indentString indentSize + "match expr with\n"
               + indentString indentSize + "| REAlt(Some(x), None) -> \n" 
               + indentString (indentSize + 1) + "let " + lAltFName + " expr = \n" + lFun + "\n"
               + indentString (indentSize + 1) + lAltFName + " x \n"
               + indentString indentSize + "| REAlt(None, Some(x)) -> \n"
               + indentString (indentSize + 1) + "let " + rAltFName + " expr = \n" + rFun + "\n"
               + indentString (indentSize + 1) + rAltFName + " x \n"

            | PToken (x)
            | PRef(x,_) ->
                 indentString indentSize + "match expr with\n" 
               + indentString indentSize + "| RELeaf " + Source.toString x + " -> " + Source.toString x + " :?> 'a\n"
               
            | _ -> "NotSupported"
                    
        let enum = Enumerator()

        let generateRules rules =            
            let genRule rule =
                let actName =  rule.name + enum.Next().ToString()
                ruleToAction := (rule.name, actName) :: !ruleToAction
                "let " + actName + " expr = \n" + generateBody 1 rule.body
            List.map genRule rules

        let genearte grammar= 
            generatePreheader grammar.info.fileName
            generateHeader grammar.head
            generateRules grammar.grammar |> String.concat "\n" |> write
            List.map 
                (fun r2a -> "(\"" + fst r2a + "\"," + snd r2a + ")")
                !ruleToAction
            |> String.concat "; "
            |> fun x -> "\nlet ruleToAction = dict [|" + x + "|]\n"
            |> write             
            generateFooter grammar.foot
            textWriter.CloseOutStream()
                
        member self.Gemerate grammar = genearte grammar
                
    end