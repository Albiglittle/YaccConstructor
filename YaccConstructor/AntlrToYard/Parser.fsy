%{

open Yard.Core.IL.Production

(* Run with fsyacc.exe --module AntlrToYard.Parser --open Yard.Core.IL Parser.fsy *)


(*
Expr: ID { Val($1) }
     | INT {  Int($1)  }
     | FLOAT {  Float($1)  }
     | DECR LPAREN Expr RPAREN {  Decr($3)  }


 Stmt: ID ASSIGN Expr { Assign($1,$3) }
     | WHILE Expr DO Stmt { While($2,$4) }
     | BEGIN StmtList END { Seq(List.rev($2)) }
     | IF Expr THEN Stmt { IfThen($2,$4) }
     | IF Expr THEN Stmt ELSE Stmt { IfThenElse($2,$4,$6) }
     | PRINT Expr { Print($2) }


 StmtList: Stmt { [$1] }
        | StmtList SEMI Stmt { $3 :: $1  }

*)

let makeModifiedRule innerProduction modifier =
    match modifier with
    | "+" -> PSome(innerProduction)
    | "*" -> PMany(innerProduction)
    | "?" -> POpt(innerProduction)
    | "!" -> innerProduction // Not included in AST
    | "" -> innerProduction

let makePSeq (productionList, actionCode) =
    PSeq( List.map (fun prod -> {omit = false; rule = prod; binding = None; checker = None;}) productionList , actionCode )
    
%}

%token <Source.t> MULTILINE_COMMENT
%token <Source.t> SINGLELINE_COMMENT
%token <Source.t> SCOPE_NAME
%token <Source.t> ACTION_NAME
%token <Source.t> ACTION_CODE
%token EOF
%token T_GRAMMAR
%token T_OPTIONS
%token <Source.t> IDENTIFIER
%token <Source.t> LITERAL
%token LPAREN 
%token RPAREN
%token BAR
%token EQUAL
%token STAR
%token PLUS
%token COLON
%token SEMICOLON
%token QUESTION
%token EXCLAMATION
%token TILDE
%token DOUBLE_DOT

%start ParseAntlr
%type <(Source.t, Source.t)Grammar.t> ParseAntlr


%%

//file: GrammarDeclaration Options GlobalScope Header Members Rules { Prog() }

ParseAntlr: TopLevelDefs EOF { $1 }

TopLevelDefs: TopLevelDef { $1 }
    | TopLevelDefs TopLevelDef { $1 @ $2 }

TopLevelDef: Rule { [$1] }
    | T_OPTIONS ACTION_CODE { [] }
    
Rule: IDENTIFIER Options COLON RuleBody SEMICOLON { { new Rule.t<Source.t, Source.t> with name = fst($1) and args = [] and body = $4 and _public = false and metaArgs = [] } }

Options: {} | T_OPTIONS ACTION_CODE {}

RuleBody: Alt { makePSeq ($1) } | RuleBody BAR Alt { PAlt($1, makePSeq ($3)) }

Alt: Seq ActionCodeOptional { ([$1], $2) } | Seq Alt { $1 :: fst($2), None }

ActionCodeOptional: { None }
    | ACTION_CODE { Some($1) }

Seq: LPAREN RuleBody RPAREN Modifier { makeModifiedRule $2 $4 }
    | SimpleProduction Modifier { makeModifiedRule ($1) $2 }

Modifier: PLUS { "+" }
    | STAR { "*" }
    | QUESTION { "?" }
    | EXCLAMATION { "!" }
    | { "" }

SimpleProduction: IDENTIFIER { PRef($1, None) }
    | LITERAL DOUBLE_DOT LITERAL { 
        match (($1), ($3)) with
        | (("0",_), ("9", _)) -> PToken("NUMBER", (0,0))
        | (("\\0",_), ("\\255", _)) -> PToken("CHAR", (0,0))
        | (("a",_), ("z", _)) -> PToken("LOWER_LATIN", (0,0))
        | (("A",_), ("Z", _)) -> PToken("UPPER_LATIN", (0,0))
        | x -> failwith (sprintf "unsupported interval %A" x)
        }
    | LITERAL { PLiteral($1) }


RulePart: 
  DOUBLE_DOT {}
  | TILDE {}
  | QUESTION {}
  | EXCLAMATION {}
  | PLUS {}
  | STAR {}
  | EQUAL {}
  | BAR {}
  | RPAREN {}
  | LPAREN {}
  | LITERAL {}
  | IDENTIFIER {}
  | ACTION_CODE {}
  | ACTION_NAME {}
  | SCOPE_NAME {}