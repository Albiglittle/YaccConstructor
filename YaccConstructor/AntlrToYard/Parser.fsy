%{

open Yard.Core.IL.Production

(* Run with fsyacc.exe --module AntlrToYard.Parser --open Yard.Core.IL Parser.fsy *)


(*
Expr: ID { Val($1) }
     | INT {  Int($1)  }
     | FLOAT {  Float($1)  }
     | DECR LPAREN Expr RPAREN {  Decr($3)  }


 Stmt: ID ASSIGN Expr { Assign($1,$3) }
     | WHILE Expr DO Stmt { While($2,$4) }
     | BEGIN StmtList END { Seq(List.rev($2)) }
     | IF Expr THEN Stmt { IfThen($2,$4) }
     | IF Expr THEN Stmt ELSE Stmt { IfThenElse($2,$4,$6) }
     | PRINT Expr { Print($2) }


 StmtList: Stmt { [$1] }
        | StmtList SEMI Stmt { $3 :: $1  }

*)

let makeModifiedRule innerProduction modifier =
    match modifier with
    | "+" -> PSome(innerProduction)
    | "*" -> PMany(innerProduction)
    | "?" -> POpt(innerProduction)
    | "!" -> innerProduction // TODO ???
    | "" -> innerProduction

let makePSeq productionList =
    PSeq( List.map (fun prod -> {omit = false; rule = prod; binding = None; checker = None;}) productionList , None )
%}

%token <Source.t> MULTILINE_COMMENT
%token <Source.t> SINGLELINE_COMMENT
%token <Source.t> SCOPE_NAME
%token <Source.t> ACTION_NAME
%token <Source.t> ACTION_CODE
%token EOF
%token T_GRAMMAR
%token T_OPTIONS
%token <Source.t> IDENTIFIER
%token <Source.t> LITERAL
%token LPAREN 
%token RPAREN
%token BAR
%token EQUAL
%token STAR
%token PLUS
%token COLON
%token SEMICOLON
%token QUESTION
%token EXCLAMATION
%token TILDE
%token DOUBLE_DOT

%start ParseAntlr
%type <(Source.t, Source.t)Grammar.t> ParseAntlr


%%

//file: GrammarDeclaration Options GlobalScope Header Members Rules { Prog() }

ParseAntlr: Rules EOF { $1 }

Rules: Rule { [$1] }
    | Rules Rule { $2 :: $1 }
    
Rule: IDENTIFIER Options COLON RuleBody SEMICOLON { { new Rule.t<Source.t, Source.t> with name = fst($1) and args = [] and body = $4 and _public = false and metaArgs = [] } }

Options: {} | T_OPTIONS ACTION_CODE {}

RuleBody: Alt { makePSeq ($1) } | RuleBody BAR Alt { PAlt($1, makePSeq ($3)) }

Alt: Seq { [$1] } | Alt Seq { $2 :: $1 }

Seq: LPAREN RuleBody RPAREN Modifier { makeModifiedRule $2 $4 }
    | IDENTIFIER Modifier { makeModifiedRule (PToken($1)) $2 }

Modifier: PLUS { "+" }
    | STAR { "*" }
    | QUESTION { "?" }
    | EXCLAMATION { "!" }
    | { "" }

RulePart: 
  DOUBLE_DOT {}
  | TILDE {}
  | QUESTION {}
  | EXCLAMATION {}
  | PLUS {}
  | STAR {}
  | EQUAL {}
  | BAR {}
  | RPAREN {}
  | LPAREN {}
  | LITERAL {}
  | IDENTIFIER {}
  | ACTION_CODE {}
  | ACTION_NAME {}
  | SCOPE_NAME {}