{
//  UserLexer.fs contains simple lexer for testing.
//
//  for build:  fslex Lexer.fsl --unicode -o Lexer.fs
//
//  Copyright 2010, 2011, 2011 Semen Grigorev <rsdpisuy@gmail.com>
//
//  This file is part of YaccConctructor.
//
//  YaccConstructor is free software:you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.

module Lexer_summator_1
open Microsoft.FSharp.Text.Lexing
open Microsoft.FSharp.Text
open Yard.Generators.RACCGenerator
open Yard.Generators.RACCGenerator.Tables_Summator_1


 }
 

let digit = ['0'-'9']

rule tokens = parse
 | digit+ 
        {{tag = getTag T_NUMBER; value = LexBuffer<_>.LexemeString(lexbuf)}}
 | "+" 
        {{tag = getTag T_PLUS; value = LexBuffer<_>.LexemeString(lexbuf)}}
 | eof  {{tag = -1; value = LexBuffer<_>.LexemeString(lexbuf)}}

{

type Lexer(lb) = 
    let locBuf = ref []
    interface ILexer<string> with        
    
       member self.Get pos = 
        let l = !locBuf |> List.length
        if l >= pos
        then (!locBuf).[l-pos]
        else
            let t = tokens lb
            locBuf := t :: !locBuf
            t      
    end

}