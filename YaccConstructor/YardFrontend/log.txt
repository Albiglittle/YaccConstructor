
rules:
   0: file = action_opt rule_nlist foot_opt 
   1: yard_start_rule = file 
   2: action_opt = ACTION 
   3: action_opt = 
   4: foot_opt = SEMICOLON ACTION 
   5: foot_opt = 
   6: rule_nlist = 
   7: rule_nlist = INCLUDE STRING rule_nlist 
   8: rule_nlist = rule semi_opt rule_nlist 
   9: rule = start_rule_sign_opt LIDENT formal_meta_param_opt param_list COLON option_opt alts 
  10: start_rule_sign_opt = START_RULE_SIGN 
  11: start_rule_sign_opt = 
  12: formal_meta_param_opt = DLESS formal_meta_list DGREAT 
  13: formal_meta_param_opt = 
  14: formal_meta_list = LIDENT formal_meta_list 
  15: formal_meta_list = LIDENT 
  16: param_opt = PARAM 
  17: param_opt = 
  18: param_list = PARAM param_list 
  19: param_list = 
  20: weight_opt = WEIGHT 
  21: weight_opt = 
  22: alts = seq bar_seq_nlist 
  23: alts = seq 
  24: bar_seq_nlist = BAR seq 
  25: bar_seq_nlist = BAR seq bar_seq_nlist 
  26: seq = lbl_seq 
  27: seq = no_lbl_seq 
  28: no_lbl_seq = ACTION 
  29: no_lbl_seq = seq_elem seq_elem_list action_opt 
  30: lbl_seq = DLABEL weight_opt LPAREN no_lbl_seq RPAREN 
  31: seq_elem_list = seq_elem seq_elem_list 
  32: seq_elem_list = 
  33: seq_elem = omit_opt bound predicate_opt 
  34: omit_opt = MINUS 
  35: omit_opt = 
  36: semi_opt = SEMICOLON 
  37: semi_opt = 
  38: predicate_opt = PREDICATE 
  39: predicate_opt = 
  40: bound = prim 
  41: bound = patt EQUAL prim 
  42: patt = PATTERN 
  43: patt = LIDENT 
  44: prim = STRING 
  45: prim = lbl_seq 
  46: prim = call 
  47: prim = LPAREN alts RPAREN 
  48: prim = prim QUESTION 
  49: prim = prim PLUS 
  50: prim = prim STAR 
  51: meta_param = prim 
  52: meta_params = meta_param meta_params 
  53: meta_params = meta_param 
  54: meta_param_opt = DLESS meta_params DGREAT 
  55: meta_param_opt = 
  56: call = LIDENT meta_param_opt param_opt 
  57: call = UIDENT 
  58: option_opt = SET option_params 
  59: option_opt = 
  60: option_params = option_param COMMA option_params 
  61: option_params = option_param 
  62: option_param = LIDENT EQUAL STRING 
  63: tada_rule = EOF 
  64: tada_rule = SHARPLINE 
Source without filename:  
        { Definition.empty with
            Definition.info = { fileName = !currentFilename }
            Definition.head = _S1
            Definition.grammar = (fst _S2)
            Definition.foot = _S3
            Definition.options = (snd _S2)
        }
      
Source without filename:  Some _S1 
Source without filename:  None 
Source without filename:  Some _S2 
Source without filename:  None 
Source without filename:  [], Map.empty 
Source without filename:  let def = parseRules _S2.text in
          (def.grammar @ (fst _S3), joinMaps def.options (snd _S3)) 
        
Source without filename:  (fst _S1) :: (fst _S3), joinMaps (snd _S1) (snd _S3) 
Source without filename:  
        let newRule = { Rule._public = _S1
                        Rule.name = _S2
                        Rule.metaArgs = getList _S3
                        Rule.body = _S7
                        Rule.args = _S4
                      }
        in
        match _S6 with
        | Some m -> newRule, Map.empty.Add (newRule, m)
        | None -> newRule, Map.empty
       
Source without filename: true
Source without filename: false
Source without filename: Some _S2
Source without filename:  None 
Source without filename: _S1::_S2
Source without filename: [_S1]
Source without filename: Some _S1
Source without filename:  None 
Source without filename: _S1::_S2
Source without filename:  [] 
Source without filename:  Some _S1
Source without filename:  None 
Source without filename: PAlt (_S1,_S2)
Source without filename:  _S1 
Source without filename: _S2
Source without filename: PAlt(_S2,_S3) 
Source without filename: _S1
Source without filename: _S1
Source without filename:  PSeq([], Some _S1, None) 
Source without filename:  PSeq (_S1::_S2, _S3, None)
Source without filename: makeNewSeq _S4 _S1 _S2
Source without filename: _S1::_S2
Source without filename:  [] 
Source without filename: {_S2 with checker = _S3; omit = _S1 }
Source without filename:  true 
Source without filename:  false 
Source without filename: true
Source without filename:  false 
Source without filename:  Some _S1 
Source without filename:  None 
Source without filename:  createSeqElem None false _S1 None      
Source without filename:  createSeqElem (Some _S1) false _S3 None 
Source without filename: _S1
Source without filename: _S1
Source without filename: PLiteral _S1
Source without filename: _S1
Source without filename: _S1
Source without filename: _S2
Source without filename: POpt _S1
Source without filename: PSome _S1
Source without filename: PMany _S1
Source without filename: _S1
Source without filename: _S1 :: _S2
Source without filename: [_S1]
Source without filename: Some _S2
Source without filename:  None 
Source without filename:  match _S2 with
        | None -> PRef  (_S1, _S3)
        | Some x -> PMetaRef (_S1,_S3,x)
      
Source without filename: PToken _S1
Source without filename:  Some _S2 
Source without filename:  None 
Source without filename: (_S3).Add _S1
Source without filename:  Map.empty.Add _S1
Source without filename:  (Source.toString _S1, Source.toString _S3) 
Source without filename: 
Source without filename: 
