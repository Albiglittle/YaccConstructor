%{
//  Copyright 2009 Jake Kirilenko
//
//  This file is part of YaccConctructor.
//
//  YaccConstructor is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.

#nowarn "62";; 
open Microsoft.FSharp.Text
open Yard.Core.IL
open Yard.Core.IL.Production
 
type Range = struct
	val Start: Lexing.Position
	val End: Lexing.Position

	new (start,end_) = {Start = start; End = end_}
end

exception Parse_error
let FrontendsManager = Yard.Core.FrontendsManager.FrontendsManager()  
let currentFilename = ref ""
let o2l = function Some x -> [x] | None -> []
let getList = function Some x -> x | None -> []

let joinMaps (p:Map<'a,'b>) (q:Map<'a,'b>) = 
    Map(Seq.concat [ (Map.toSeq p) ; (Map.toSeq q) ])

let missing name = System.Console.WriteLine("Missing " + name)
let createSeqElem bnd omitted r check =
    { binding = bnd; omit = omitted; rule = r; checker = check }

let parseRules (filename:string) : (IL.Source.t, IL.Source.t)IL.Definition.t =
    let ext = filename.Substring(filename.LastIndexOf(".") + 1) in
    let frontend = FrontendsManager.GetByExtension ext in
    let userDefs =
        let args = (!currentFilename).Trim().Split('%') in
        if args.Length = 2
        then args.[1]
        else ""
	in
    let sameDirFilename = System.IO.Path.Combine(System.IO.Path.GetDirectoryName !currentFilename, filename) in

    match FrontendsManager.GetByExtension ext with
    | Some(frontend) -> 
        frontend.Value.ParseGrammar (sameDirFilename + "%" + userDefs)
    | None -> 
        failwith (sprintf "Not supported extension %s in file %s" ext filename )
%}

%token EOF
%token COLON
%token <Range> SEMICOLON
%token COMMA
%token EQUAL
%token BAR
%token STAR
%token PLUS
%token MINUS
%token QUESTION
%token EXCLAMATION
%token <Range> LPAREN
%token <Range> RPAREN
%token DGREAT
%token DLESS
%token COMMUT
%token INCLUDE
%token SET
%token <IL.Source.t> STRING LIDENT UIDENT
%token <IL.Source.t> PREDICATE ACTION
%token <IL.Source.t> PATTERN PARAM
%token <string> SHARPLINE


%start file
%type <(IL.Source.t, IL.Source.t)IL.Definition.t> file

%%

file: action_opt
      rule_nlist
      action_opt
      EOF
      { 
        { Definition.empty with
            Definition.info = { fileName = !currentFilename }
            ; Definition.head = $1
            ; Definition.grammar = (fst $2)
            ; Definition.foot = $3
            ; Definition.options = (snd $2)
        }
      }

action_opt: ACTION { Some $1 }
          | /* empty */ { None }

rule_nlist: rule SEMICOLON rule_nlist 
        { ((fst $1) :: (fst $3), joinMaps (snd $1) (snd $3)) }
    | INCLUDE STRING rule_nlist 
        { let def = parseRules (fst $2) in
          (def.grammar @ (fst $3), joinMaps def.options (snd $3)) 
        } 
    | { ([], Map.empty) }
    | rule error { missing "SEMI"; raise Parse_error  }

rule: plus_opt LIDENT formal_meta_param_opt param_opt COLON option_opt alts
      { 
        let newRule = {Rule._public = $1
                        ; Rule.name = Source.toString $2
                        ; Rule.metaArgs = getList $3
                        ; Rule.body = $7
                        ; Rule.args = o2l $4
                        }
        in
        match $6 with
        | Some m ->
            (newRule, Map.empty.Add (newRule, m))
        | None ->
            (newRule, Map.empty)
       }

plus_opt: PLUS      {true}
        | /*empty*/ {false}

formal_meta_param_opt: DLESS formal_meta_list DGREAT {Some $2}
                     | /* empty */ {None}

formal_meta_list: LIDENT {[$1]}
                | LIDENT formal_meta_list {$1::$2}

param_opt: PARAM {Some $1} | /* empty */ {None}

alts: seq { $1 } | seq bar_seq_nlist {PAlt ($1,$2)}

bar_seq_nlist : BAR seq bar_seq_nlist {PAlt($2,$3)}  
              | BAR seq {$2}

seq: seq_elem seq_elem_list action_opt { PSeq ($1::$2, $3) }
   | ACTION {PSeq([],Some $1)}

seq_elem_list: seq_elem seq_elem_list {$1::$2}
             | /* empty */ {[]}

seq_elem: omit_opt bound predicate_opt {{$2 with checker = $3; omit = $1 }}

omit_opt: MINUS { true } | /*empty*/ { false }

predicate_opt: PREDICATE   { Some $1 }
             | /* empty */ { None    }

bound: patt EQUAL prim { createSeqElem (Some $1) false $3 None }
     | prim            { createSeqElem None false $1 None      }

patt: LIDENT {$1} | PATTERN {$1}

prim: prim STAR           {PMany $1}
    | prim PLUS           {PSome $1}
    | prim QUESTION       {POpt $1}
    | LPAREN alts RPAREN  {$2}
    | call                {$1}
    | STRING              {PLiteral $1}

meta_param: prim {$1}

meta_params: meta_param {[$1]}
           | meta_param meta_params {$1 :: $2}

meta_param_opt: /* empty */ {None}
              | DLESS meta_params DGREAT {Some $2}

call: UIDENT             {PToken $1}
    | LIDENT meta_param_opt param_opt  
      { match $2 with
        None -> PRef  ($1, $3)
        | Some x -> PMetaRef ($1,$3,x)
      }

option_opt: SET option_params { Some $2 }
    | /* empty */ { None }

option_params: option_param { Map.empty.Add $1}
    | option_param COMMA option_params {($3).Add $1}

option_param: LIDENT EQUAL STRING { (Source.toString $1, Source.toString $3) }