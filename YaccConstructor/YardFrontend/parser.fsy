%{
//  Copyright 2009 Jake Kirilenko
//
//  This file is part of YaccConctructor.
//
//  YaccConstructor is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.

#nowarn "62";; 
open Microsoft.FSharp.Text
open Yard.Core.IL
open Yard.Core
open Yard.Core.IL.Production
open Yard.Core.IL.Grammar
open Yard.Core.IL.Definition
 
type Range = struct
    val Start: Lexing.Position
    val End: Lexing.Position

    new (start,end_) = {Start = start; End = end_}
end

exception Parse_error
let parseFile = ref Unchecked.defaultof<_>
let FrontendsManager = Yard.Core.FrontendsManager.FrontendsManager()  
let currentFilename = ref ""
let allPublic = ref false
let o2l = function Some x -> [x] | None -> []
let getList = function Some x -> x | None -> []

let joinMaps (p:Map<'a,'b>) (q:Map<'a,'b>) = 
    Map(Seq.concat [ (Map.toSeq p) ; (Map.toSeq q) ])

let makeNewSeq seq (lbl:Source.t) (w:Option<Source.t>) = 
    match seq,w with 
     | PSeq(els,ac,_),_ -> match w with
                           | None -> PSeq (els,ac,Some {label=lbl.text; weight=None})
                           | _ -> let wVal = w.Value
                                  try
                                      PSeq (els,ac,Some {label=lbl.text; weight = Some (float wVal.text)})
                                  with 
                                  | :? System.FormatException as ex ->
                                      failwithf "Parse error on position (%i,%i) on token %s: %s" wVal.startPos.line wVal.startPos.column wVal.text "illegal weight. Number expected."
     | x,_ -> x

let missing name = System.Console.WriteLine("Missing " + name)
let createSeqElem bnd omitted r check =
    { binding = bnd; omit = omitted; rule = r; checker = check }

let concatModOpt a b = fst a :: fst b, joinMaps (snd a) (snd b)

let parseRules (filename:string) : Definition.t<Source.t, Source.t> =
    let oldFileName = !currentFilename
    currentFilename := filename
    let ext = filename.Substring(filename.LastIndexOf(".") + 1)    
    let userDefs =
        let args = oldFileName.Trim().Split('%') in
        if args.Length = 2
        then args.[1]
        else ""
    let sameDirFilename = System.IO.Path.Combine(System.IO.Path.GetDirectoryName oldFileName, filename) in
    let res = !parseFile (sameDirFilename + "%" + userDefs)
    currentFilename := oldFileName
    res
%}

%token EOF
%token COLON
%token <Range> SEMICOLON
%token COMMA
%token EQUAL
%token BAR
%token STAR
%token START_RULE_SIGN
%token PLUS
%token MINUS
%token QUESTION
%token EXCLAMATION
%token <Range> LPAREN
%token <Range> RPAREN
%token DGREAT
%token DLESS
%token COMMUT
%token INCLUDE
%token SET
%token <IL.Source.t> STRING LIDENT UIDENT
%token <IL.Source.t> PREDICATE ACTION
%token <IL.Source.t> PATTERN PARAM
%token <string> SHARPLINE
%token <IL.Source.t> DLABEL

%start file
%type <IL.Definition.t<IL.Source.t, IL.Source.t>> file

%%

file: action_opt
      includes
      unnamed_module_opt
      modules
      foot_opt
      { 
        {
            info = { fileName = !currentFilename }
            head = $1
            grammar = fst $2 @ fst $3 @ fst $4
            foot = $5
            options = (snd $4) |> joinMaps (snd $3) |> joinMaps (snd $2)
        }
      }

unnamed_module_opt : rule_nlist
    {
        match fst $1 with
        | [] -> [], Map.empty
        | x ->  defaultModules x, snd $1
    }

modules : module_ modules { concatModOpt $1 $2 }
        | { [], Map.empty }

module_ : module_header ident openings rule_nlist
    {
        {
            allPublic = $1
            name = Some $2
            openings = $3
            rules = fst $4
        }
        , snd $4
    }

ident : UIDENT { $1 } | LIDENT { $1 }


module_header : ALL_PUBLIC MODULE {
                  (* It's important the word "module" is here. It guaranties, that it won't be an epsilon-tree, so allPublic will be evaluated before rules *)
                  allPublic := true; true
                }
              | MODULE { allPublic := false; false }

openings :  { [] } | OPEN ident open_list { $2::$3 }

open_list : COMMA ident open_list { $2::$3 } | { [] }

action_opt: { None } | ACTION { Some $1 }

foot_opt: { None } | SEMICOLON ACTION { Some $2 }

includes : include_ includes { fst $1 @ fst $2, joinMaps (snd $1) (snd $2) } | { [], Map.empty }

include_:
    INCLUDE STRING 
    {
        let def = parseRules $2.text in
        if def.grammar |> List.exists (fun m -> m.name.IsNone) then
            eprintfn "Error %s: Grammar in included files must be inside modules" $2.text
        def.grammar, def.options
    } 


rule_nlist: rule semi_opt rule_nlist 
      { concatModOpt $1 $3 }
    | { [], Map.empty }
    | rule error { missing "SEMI"; raise Parse_error  }

rule: start_rule_sign_opt access_modifier_opt LIDENT formal_meta_param_opt param_list COLON option_opt alts
      { 
        let newRule =
            {
                Rule.isStart = $1
                Rule.isPublic = $2
                Rule.name = $3
                Rule.metaArgs = getList $4
                Rule.body = $8
                Rule.args = $5
            }
        in
        match $7 with
        | Some m -> newRule, Map.empty.Add (newRule, m)
        | None -> newRule, Map.empty
       }

start_rule_sign_opt: {false} | START_RULE_SIGN {true}

access_modifier_opt: PUBLIC { true } | PRIVATE { false } | { !allPublic }

formal_meta_param_opt: { None } | DLESS formal_meta_list DGREAT {Some $2}

formal_meta_list: LIDENT {[$1]}
                | LIDENT formal_meta_list {$1::$2}

param_opt: { None } | PARAM {Some $1}

param_list: { [] } | PARAM param_list {$1::$2}

weight_opt: { None } | PARAM { Some $1}

alts: seq { $1 } | seq bar_seq_nlist {PAlt ($1,$2)}

bar_seq_nlist : BAR seq bar_seq_nlist {PAlt($2,$3) }  
              | BAR seq {$2}

seq: no_lbl_seq {$1} | lbl_seq {$1}

no_lbl_seq: seq_elem seq_elem_list action_opt { PSeq ($1::$2, $3, None)}
          | ACTION { PSeq([], Some $1, None) }

lbl_seq: DLABEL weight_opt LPAREN no_lbl_seq RPAREN {makeNewSeq $4 $1 $2}

seq_elem_list: { [] } | seq_elem seq_elem_list {$1::$2}

seq_elem: omit_opt bound predicate_opt {{$2 with checker = $3; omit = $1 }}

omit_opt: { false } | MINUS { true }

semi_opt : { false } | SEMICOLON {true}

predicate_opt: { None } | PREDICATE { Some $1 }

bound: patt EQUAL prim { createSeqElem (Some $1) false $3 None }
     | prim            { createSeqElem None false $1 None      }

patt: LIDENT {$1} | ACTION {$1}

prim: prim STAR           {PMany $1}
    | prim PLUS           {PSome $1}
    | prim QUESTION       {POpt $1}
    | LPAREN alts RPAREN  {$2}
    | call                {$1}
    | lbl_seq             {$1}
    | STRING              {PLiteral $1}

meta_param: prim {$1}

meta_params: meta_param {[$1]}
           | meta_param meta_params {$1 :: $2}

meta_param_opt: { None } | DLESS meta_params DGREAT {Some $2}

call: UIDENT {PToken $1}
    | LIDENT meta_param_opt param_opt  
      { match $2 with
        | None -> PRef  ($1, $3)
        | Some x -> PMetaRef ($1,$3,x)
      }

option_opt: { None } | SET option_params { Some $2 }
    
option_params: option_param { Map.empty.Add $1}
             | option_param COMMA option_params {($3).Add $1}

option_param: LIDENT EQUAL STRING { Source.toString $1, Source.toString $3 }

tada_rule : SHARPLINE {} | EOF {};