%{
//  Copyright 2009 Jake Kirilenko
//
//  This file is part of YaccConctructor.
//
//  YaccConstructor is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.

#nowarn "62";; 
open Microsoft.FSharp.Text
open Yard.Core.IL
open Yard.Core.IL.Production
 
type Range = struct
    val Start: Lexing.Position
    val End: Lexing.Position

    new (start,end_) = {Start = start; End = end_}
end

exception Parse_error
let FrontendsManager = Yard.Core.FrontendsManager.FrontendsManager()  
let currentFilename = ref ""
let o2l = function Some x -> [x] | None -> []
let getList = function Some x -> x | None -> []

let joinMaps (p:Map<'a,'b>) (q:Map<'a,'b>) = 
    Map(Seq.concat [ (Map.toSeq p) ; (Map.toSeq q) ])

let makeNewSeq seq (lbl:Source.t) (w:Option<Source.t>) = 
    match seq,w with 
     | PSeq(els,ac,_),_ -> match w with
                           | None -> PSeq (els,ac,Some {label=lbl.text; weight=None})
                           | _ -> PSeq (els,ac,Some {label=lbl.text; weight = Some (float w.Value.text)})
     | x,_ -> x

let missing name = System.Console.WriteLine("Missing " + name)
let createSeqElem bnd omitted r check =
    { binding = bnd; omit = omitted; rule = r; checker = check }

let parseRules (filename:string) : Definition.t<Source.t, Source.t> =
    let ext = filename.Substring(filename.LastIndexOf(".") + 1)
    let frontend = FrontendsManager.GetByExtension ext
    let userDefs =
        let args = (!currentFilename).Trim().Split('%') in
        if args.Length = 2
        then args.[1]
        else ""
    let sameDirFilename = System.IO.Path.Combine(System.IO.Path.GetDirectoryName !currentFilename, filename) in

    match FrontendsManager.GetByExtension ext with
    | Some(frontend) -> 
        frontend.Value.ParseGrammar (sameDirFilename + "%" + userDefs)
    | None -> 
        failwith (sprintf "Not supported extension %s in file %s" ext filename )
%}

%token EOF
%token COLON
%token <Range> SEMICOLON
%token COMMA
%token EQUAL
%token BAR
%token STAR
%token START_RULE_SIGN
%token PLUS
%token MINUS
%token QUESTION
%token EXCLAMATION
%token <Range> LPAREN
%token <Range> RPAREN
%token DGREAT
%token DLESS
%token COMMUT
%token INCLUDE
%token SET
%token <IL.Source.t> STRING LIDENT UIDENT
%token <IL.Source.t> PREDICATE ACTION
%token <IL.Source.t> PATTERN PARAM
%token <string> SHARPLINE
%token <IL.Source.t> DLABEL
%token <IL.Source.t> WEIGHT


%start file
%type <IL.Definition.t<IL.Source.t, IL.Source.t>> file

%%

file: action_opt
      rule_nlist
      foot_opt
      { 
        { Definition.empty with
            Definition.info = { fileName = !currentFilename }
            Definition.head = $1
            Definition.grammar = (fst $2)
            Definition.foot = $3
            Definition.options = (snd $2)
        }
      }

action_opt: { None } | ACTION { Some $1 }

foot_opt: { None } | SEMICOLON ACTION { Some $2 }

rule_nlist: rule semi_opt rule_nlist 
        { (fst $1) :: (fst $3), joinMaps (snd $1) (snd $3) }
    | INCLUDE STRING rule_nlist 
        { let def = parseRules $2.text in
          (def.grammar @ (fst $3), joinMaps def.options (snd $3)) 
        } 
    | { [], Map.empty }
    | rule error { missing "SEMI"; raise Parse_error  }

rule: start_rule_sign_opt LIDENT formal_meta_param_opt param_list COLON option_opt alts
      { 
        let newRule = { Rule._public = $1
                        Rule.name = $2
                        Rule.metaArgs = getList $3
                        Rule.body = $7
                        Rule.args = $4
                      }
        in
        match $6 with
        | Some m -> newRule, Map.empty.Add (newRule, m)
        | None -> newRule, Map.empty
       }

start_rule_sign_opt: {false} | START_RULE_SIGN {true}

formal_meta_param_opt: { None } | DLESS formal_meta_list DGREAT {Some $2}

formal_meta_list: LIDENT {[$1]}
                | LIDENT formal_meta_list {$1::$2}

param_opt: { None } | PARAM {Some $1}

param_list: { [] } | PARAM param_list {$1::$2}

weight_opt: { None } | PARAM { Some $1}

alts: seq { $1 } | seq bar_seq_nlist {PAlt ($1,$2)}

bar_seq_nlist : BAR seq bar_seq_nlist {PAlt($2,$3) }  
              | BAR seq {$2}

seq: no_lbl_seq {$1} | lbl_seq {$1}

no_lbl_seq: seq_elem seq_elem_list action_opt { PSeq ($1::$2, $3, None)}
          | ACTION { PSeq([], Some $1, None) }

lbl_seq: DLABEL weight_opt LPAREN no_lbl_seq RPAREN {makeNewSeq $4 $1 $2}

seq_elem_list: { [] } | seq_elem seq_elem_list {$1::$2}

seq_elem: omit_opt bound predicate_opt {{$2 with checker = $3; omit = $1 }}

omit_opt: { false } | MINUS { true }

semi_opt : { false } | SEMICOLON {true}

predicate_opt: { None } | PREDICATE { Some $1 }

bound: patt EQUAL prim { createSeqElem (Some $1) false $3 None }
     | prim            { createSeqElem None false $1 None      }

patt: LIDENT {$1} | PATTERN {$1}

prim: prim STAR           {PMany $1}
    | prim PLUS           {PSome $1}
    | prim QUESTION       {POpt $1}
    | LPAREN alts RPAREN  {$2}
    | call                {$1}
    | lbl_seq             {$1}
    | STRING              {PLiteral $1}

meta_param: prim {$1}

meta_params: meta_param {[$1]}
           | meta_param meta_params {$1 :: $2}

meta_param_opt: { None } | DLESS meta_params DGREAT {Some $2}

call: UIDENT {PToken $1}
    | LIDENT meta_param_opt param_opt  
      { match $2 with
        | None -> PRef  ($1, $3)
        | Some x -> PMetaRef ($1,$3,x)
      }

option_opt: { None } | SET option_params { Some $2 }
    
option_params: option_param { Map.empty.Add $1}
             | option_param COMMA option_params {($3).Add $1}

option_param: LIDENT EQUAL STRING { (Source.toString $1, Source.toString $3) }

tada_rule : SHARPLINE {} | EOF {};