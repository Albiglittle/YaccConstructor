//  RegexpGenerator.fs contains functions for list to treee by regexp loading generation
//
//  Copyright 2011 Semen Grigorev <rsdpisuy@gmail.com>
//
//  This file is part of YaccConctructor.
//
//  YaccConstructor is free software:you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.

namespace  Yard.Generators.GNESCCGenerator

open Yard.Core.IL
open Yard.Core.IL.Definition
open Yard.Core.IL.Production
open Yard.Core.IL.Rule
open Yard.Generators.GNESCCGenerator.LALR
open Yard.Generators.GNESCCGenerator.FAL
open Yard.Generators.GNESCCGenerator.CommonTypes
open Yard.Generators.GNESCCGenerator.CommonTableFunctions

open Microsoft.FSharp.Text.StructuredFormat
open Microsoft.FSharp.Text.StructuredFormat.LayoutOps

type RegexpGenerator(outPath: string) = 
    class       
        
        let enumerator = new Enumerator()
        
        let ruleToAction = ref []

        let textWriter = TextWriter outPath                                
        let write str = textWriter.Write(str)
         
        let generatePreheader grammarName =
            write "//this file was generated by GNESCC"
            write ("//source grammar:" + grammarName )
            write ("//date:" + System.DateTime.Now.ToString())
            write ""
            write "module GNESCC.Regexp"
            write ""
            write "open Yard.Generators.GNESCCGenerator" 
            write "open System.Text.RegularExpressions"
            write ""
            write "let buildIndexMap kvLst ="    
            write "    let ks = List.map (fun (x:string,y) -> x.Length + 2,y) kvLst"
            write "    List.fold (fun (bl,blst) (l,v) -> bl+l,((bl,v)::blst)) (0,[]) ks"
            write "    |> snd"
            write "    |> dict"
            write ""
            write "let buildStr kvLst ="
            write "    let sep = \";;\""
            write "    List.map fst kvLst "
            write "    |> String.concat sep"
            write "    |> fun s -> \";\" + s + \";\""
            write ""            

        let notMatched expectedType = 
            "| x -> getUnmatched x \"" + expectedType + "\""        

        let rec generateBody 
            (typeToTagMap: System.Collections.Generic.IDictionary<string,int>) 
            groupNum indentSize body asFun =
            let indentString l = String.replicate l "    "
                
            match body with 
            | PSeq(elems,expr) ->   

                let genElem i gNum elem =                    
                    generateBody typeToTagMap gNum (indentSize + 1) elem asFun
                    |> fun (body, re, gNum) -> 
                        indentString indentSize + "let e" + i.ToString() (*+ (if asFun then " i" else ""*) + " =\n"
                        + body
                        ,re
                        ,gNum

                let body,regexp,gns,gn = 
                    List.fold 
                        (fun (bs,rs,gns,gn,i) elem
                            ->
                                let b,re,gn = genElem i gn elem.rule
                                b::bs,re::rs,gn::gns,gn,i+1)
                            ([],[],[],groupNum + 1,0)
                        elems
                    |> fun (b,r,gns,gn,_) ->
                        b |> String.concat "\n"
                        ,
                        r
                        |> List.rev
                        |> String.concat ""
                        |> fun r -> "(" + r + ")"
                        ,List.rev gns
                        ,gn
                        
                body + "\n"
                + indentString indentSize + "RESeq [" + (List.mapi (fun i gn -> "e" + string i (*+ (if asFun then " i" else ""*)) gns |> String.concat "; ") + "]"
                ,regexp
                ,gn
                 
            | PAlt(alt1,alt2)  ->
                 let genAltItem i gNum elem =
                    generateBody typeToTagMap gNum (indentSize + 2) elem asFun
                    |> fun (body, re, gNum) -> 
                        indentString (indentSize + 1) + "let e" + i.ToString() (*+ (if asFun then " i" else ""*) + " =\n"
                        + body
                        ,re
                        ,gNum
                          
                 let lAltB,lAltR,lAltGn = genAltItem 1 (groupNum) alt1
                 let rAltB,rAltR,rAltGn = genAltItem 2 (lAltGn) alt2

                 let regexp = lAltR + "|" + rAltR
                 
                 indentString indentSize 
                 + "if elts.[" + (lAltGn |> string) + "].Value = \"\"\n" 
                 + indentString indentSize + "then\n"
                 + rAltB + "\n" 
                 + indentString (indentSize + 1) + "None, Some (e2"  (*+ (if asFun then " i" else ""*) + ")\n"
                 + indentString indentSize + "else\n"
                 + lAltB + "\n"
                 + indentString (indentSize + 1) + "Some (e1"  (*+ (if asFun then " i" else ""*) + "),None\n"
                 + indentString indentSize + "|> REAlt\n"
                 , regexp
                 , rAltGn
            
            | PRef(x,_) ->
                indentString (indentSize) + "idxValMap.[" +  (if asFun then "!ofset + " else "") + "elts.[" + (groupNum + 1).ToString() + "].Captures.[" (*+ (if asFun then "i" else "0"*) + "0].Index] |> RELeaf"
                , "(;" + typeToTagMap.["NT_" + Source.toString x].ToString() + ";)"
                , groupNum + 1

            | PToken (x) ->
                indentString (indentSize) + "idxValMap.[" +  (if asFun then "!ofset + " else "") + "elts.[" + (groupNum + 1).ToString() + "].Captures.[" (*+ (if asFun then "i" else "0"*) + "0].Index] |> RELeaf"
                , "(;" + typeToTagMap.[ "T_" + Source.toString x].ToString() + ";)"
                , groupNum + 1
               
            | PSome(expr)
            | PMany(expr) as x ->
               let body,re,gn = 
                   generateBody typeToTagMap (*groupNum + 1*)0 (indentSize + 2) expr true
               indentString indentSize + "let ofset = ref 0\n"
               + indentString indentSize + "let e i =\n" 
               + indentString (indentSize + 1) + "let str = elts.[" + string (groupNum + 1) + "].Captures.[i].Value\n"
               + indentString (indentSize + 1) + "let re = new Regex(\"" + re + "\")\n"
               + indentString (indentSize + 1) + "let elts =\n"
               + indentString (indentSize + 2) + "let res = re.Match(str)\n"
               + indentString (indentSize + 2) + "if Seq.fold (&&) true [for g in res.Groups -> g.Success]\n"
               + indentString (indentSize + 2) + "then res.Groups\n"
               + indentString (indentSize + 2) + "else (new Regex(\"" + re + "\",RegexOptions.RightToLeft)).Match(str).Groups\n"                
               + indentString (indentSize + 1) + "let res =\n"
               + body + "\n" 
               + indentString (indentSize + 1) + "ofset := !ofset + str.Length\n"
               + indentString (indentSize + 1) + "res\n"
               + indentString indentSize + "REClosure ["
               + "for i in [0..elts.[" + string (groupNum + 1) + "].Captures.Count-1] -> e i]\n"
               , "(" + re + ")" + match x with PSome _ -> "+"| PMany _ -> "*" | _ -> failwith "Expected PSome or PMany but get " + x.ToString()
               , gn 

            | POpt(expr) ->
               let body,re,gn = 
                   generateBody typeToTagMap groupNum (indentSize + 2) expr asFun
               
               indentString indentSize + "if elts.[" + (gn |> string) + "].Value <> \"\"\n" 
               + indentString indentSize + "then\n"
               + indentString (indentSize + 1) + "let e " (*+ (if asFun then "i" else ""*) + " =\n" + body + "\n"                
               + indentString (indentSize + 1) + "Some (e" (*+ (if asFun then " i" else ""*) + ")\n"
               + indentString (indentSize) + "else None \n"
               + indentString indentSize + "|>REOpt\n"
               , re + "?"
               , gn
               
            | _ -> "NotSupported","NotSupported",groupNum

        let generateRules typeToTagMap rules =            
            let genRule rule =
                let actName =  rule.name
                let arg = "childsLst"
                ruleToAction := (rule.name, actName) :: !ruleToAction
                let body,regexp,gn = generateBody typeToTagMap 0 1 rule.body false
                "let " + actName + " " + arg 
                + " = \n    let str = buildStr " + arg 
                + "\n    let idxValMap = buildIndexMap " + arg                
                + "\n    let re = new Regex(\"" + regexp + "\")"
                + "\n    let elts ="
                + "\n        let res = re.Match(str)"
                + "\n        if Seq.fold (&&) true [for g in res.Groups -> g.Success]"
                + "\n        then res.Groups"
                + "\n        else (new Regex(\"" + regexp + "\",RegexOptions.RightToLeft)).Match(str).Groups"
                + "\n" + body

            List.map genRule rules

        let generate grammar (typeToTagMap: System.Collections.Generic.IDictionary<string,int>)= 
            generatePreheader grammar.info.fileName            
            generateRules typeToTagMap grammar.grammar |> String.concat "\n" |> write
            List.map 
                (fun r2a -> "(" + (typeToTagMap.["NT_" + fst r2a] |> string) + "," + snd r2a + ")")
                !ruleToAction
            |> String.concat "; "
            |> fun x -> "\nlet ruleToRegex = dict [|" + x + "|]\n"
            |> write
            textWriter.CloseOutStream()

        member self.Generate grammar typeToTagMap  = generate grammar typeToTagMap
                
    end