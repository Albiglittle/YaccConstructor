// CodeGenerator.fs
//
// Copyright 2009-2010 Semen Grigorev
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation.

namespace Yard.Generators.RecursiveAscent

open Yard.Core
open Utils
open IO


type CodeGenerator(sourceGramamr: string ,outPath: string) = class

  let outStream = IO.text_writer outPath
  
  let generateValueExtraction = ref true
  
  let resetValueExtruction() = generateValueExtraction:=true
  
  let varEnumerator = new Enumerator()
  
  let tab = "    "
  
  let resetValueEnumerator() = varEnumerator.Reset()
  
  let defaultParams = "(seqNum,varNum)" 
  
  let genHeader = 
      "//this file was generated by YARD Recursive-Ascent \r\n//source grammar:"+
      sourceGramamr +
      "\r\n//date:" + System.DateTime.Now.ToString() +
      "\r\n#light \"off\"\r\n" +      
      "\r\nmodule Actions\r\n"+
      "open Yard.Core\r\n"+
      "open open Yard.Generators.RecursiveAscent.REAST\r\n"
                  
  let genDefaultFanctions = ""               
                  
  let genSome code bindings = 
       "(fun arg0 -> \r\n"
     + "     match arg0 with \r\n"
     + "|REClosure (lst) -> List.map ("+code+") lst)"          

  let genBindingMap bindings =
      List.map (fun (k:Option<_>) -> ((if k.IsNone then None else Some(IL.Source.toString k.Value)) ,"x"+(varEnumerator.Next()).ToString()))  bindings  

  let genParamsList bindingLst =
      match bindingLst with
      | [] -> ""
      | hd::[] -> hd + "::tl"
      | hd::tl -> List.fold (fun buf name -> buf + "::" + name) (List.head  bindingLst ) (List.tail  bindingLst) + "::tl"
         
  let genParams bindingLst =
      List.fold (fun buf (_,name) -> buf + " " + name) (snd (List.head  bindingLst )) (List.tail  bindingLst)
        
  let genSeq  codeBlocks bindings bindingLst action =
      let getName b = 
          match b with 
          | Some(x) -> IL.Source.toString x
          | None -> "_" 
      in            
        "(fun arg0 ->  match arg0 with \n"
      + "    | RESeq(lst) -> \n"  
      + "        match lst with \n"
      + "        | "+ genParamsList bindingLst + " -> "
      + String.concat "" (List.map3 (fun code binding b -> "let ("+ getName binding + ") = \r\n"+ (code)+b+ "\r\n in \r\n")
                                    codeBlocks
                                    bindings
                                    bindingLst)
                                    
      + if String.trim [' ';'\n'] action  = "" then "())" else action + ")"

  
  let genLeaf = "(fun x -> \r\n    match x with \r\n    | RELeaf(_val) -> _val :?> _)"
  
  let close () = outStream.Close();
  
  let write (str:string) = outStream.WriteLine(str)
  
  let genTopLEvelBinding name code binding = 
      let argNames =
          List.fold (fun buf arg -> buf + " " + arg)
                    "" 
                    (List.init (List.length binding)
                               (fun i -> "arg"+i.ToString()))
                               
      "\r\n\r\nlet " + name + " "+argNames+" = \r\n "+ code + argNames
      
  let genAlt code1 code2 bindings1 bindings2 =
      "(fun arg0 -> \r\n    match arg0 with \r\n"
    + "| REAlt(Some(x),None) -> \r\n"+ code1 + "x\r\n" 
    + "| REAlt(None,Some(x)) -> \r\n"+ code2 + "x)\r\n"
     
  member self.GenSome code bindings = genSome code bindings
  member self.GenBindingMap bindings = genBindingMap bindings  
  member self.GenSeq codeBlocks bindings bindingLst action = genSeq codeBlocks bindings bindingLst action
  member self.CloseOutStream () = close ()
  member self.Write str = write str
  member self.GenTopLEvelBinding name code binding = genTopLEvelBinding name code binding
  member self.GenHeader () = genHeader
  member self.GenDefaultFunctions with get() = genDefaultFanctions
  member self.GenAlt code1 code2 bindings1 bindings2 = genAlt code1 code2 bindings1 bindings2
  member self.ResetValueEnumerator () = resetValueEnumerator()
  member self.ResetValueExtraction () = resetValueExtruction()
  member self.GenLeaf() = genLeaf
end