//this file was generated by GNESCC
//source grammar:../../../Tests/GNESCC/customers/rl/RL.yrd
//date:12/7/2011 11:30:09

module GNESCC.Regexp_RL

open Yard.Generators.GNESCCGenerator
open System.Text.RegularExpressions

let buildIndexMap kvLst =
    let ks = List.map (fun (x:string,y) -> x.Length + 2,y) kvLst
    List.fold (fun (bl,blst) (l,v) -> bl+l,((bl,v)::blst)) (0,[]) ks
    |> snd
    |> dict

let buildStr kvLst =
    let sep = ";;"
    List.map fst kvLst 
    |> String.concat sep
    |> fun s -> ";" + s + ";"

let file childsLst = 
    let str = buildStr childsLst
    let idxValMap = buildIndexMap childsLst
    let re = new Regex("((((;1;)(;6;)))*)")
    let elts =
        let res = re.Match(str)
        if Seq.fold (&&) true [for g in res.Groups -> g.Success]
        then res.Groups
        else (new Regex("((((;1;)(;6;)))*)",RegexOptions.RightToLeft)).Match(str).Groups
    let e0 =
        let ofset = ref 0
        let e i =
            let str = elts.[2].Captures.[i].Value
            let re = new Regex("((;1;)(;6;))")
            let elts =
                let res = re.Match(str)
                if Seq.fold (&&) true [for g in res.Groups -> g.Success]
                then res.Groups
                else (new Regex("((;1;)(;6;))",RegexOptions.RightToLeft)).Match(str).Groups
            let res =
                let e1 =
                    idxValMap.[!ofset + elts.[3].Captures.[0].Index] |> RELeaf
                let e0 =
                    idxValMap.[!ofset + elts.[2].Captures.[0].Index] |> RELeaf
                RESeq [e0; e1]
            ofset := !ofset + str.Length
            res
        REClosure [for i in [0..elts.[2].Captures.Count-1] -> e i]

    RESeq [e0]
let name childsLst = 
    let str = buildStr childsLst
    let idxValMap = buildIndexMap childsLst
    let re = new Regex("((;7;))")
    let elts =
        let res = re.Match(str)
        if Seq.fold (&&) true [for g in res.Groups -> g.Success]
        then res.Groups
        else (new Regex("((;7;))",RegexOptions.RightToLeft)).Match(str).Groups
    let e0 =
        idxValMap.[elts.[2].Captures.[0].Index] |> RELeaf
    RESeq [e0]
let module childsLst = 
    let str = buildStr childsLst
    let idxValMap = buildIndexMap childsLst
    let re = new Regex("((;21;)((;3;))*(;10;)?)")
    let elts =
        let res = re.Match(str)
        if Seq.fold (&&) true [for g in res.Groups -> g.Success]
        then res.Groups
        else (new Regex("((;21;)((;3;))*(;10;)?)",RegexOptions.RightToLeft)).Match(str).Groups
    let e2 =
        if elts.[2].Value <> ""
        then
            let e  =
                idxValMap.[elts.[2].Captures.[0].Index] |> RELeaf
            Some (e)
        else None 
        |>REOpt

    let e1 =
        let ofset = ref 0
        let e i =
            let str = elts.[3].Captures.[i].Value
            let re = new Regex("(;3;)")
            let elts =
                let res = re.Match(str)
                if Seq.fold (&&) true [for g in res.Groups -> g.Success]
                then res.Groups
                else (new Regex("(;3;)",RegexOptions.RightToLeft)).Match(str).Groups
            let res =
                idxValMap.[!ofset + elts.[1].Captures.[0].Index] |> RELeaf
            ofset := !ofset + str.Length
            res
        REClosure [for i in [0..elts.[3].Captures.Count-1] -> e i]

    let e0 =
        idxValMap.[elts.[2].Captures.[0].Index] |> RELeaf
    RESeq [e0; e1; e2]
let moduleHeader childsLst = 
    let str = buildStr childsLst
    let idxValMap = buildIndexMap childsLst
    let re = new Regex("((;11;)(;12;)(;4;)(;14;))")
    let elts =
        let res = re.Match(str)
        if Seq.fold (&&) true [for g in res.Groups -> g.Success]
        then res.Groups
        else (new Regex("((;11;)(;12;)(;4;)(;14;))",RegexOptions.RightToLeft)).Match(str).Groups
    let e3 =
        idxValMap.[elts.[5].Captures.[0].Index] |> RELeaf
    let e2 =
        idxValMap.[elts.[4].Captures.[0].Index] |> RELeaf
    let e1 =
        idxValMap.[elts.[3].Captures.[0].Index] |> RELeaf
    let e0 =
        idxValMap.[elts.[2].Captures.[0].Index] |> RELeaf
    RESeq [e0; e1; e2; e3]
let fields childsLst = 
    let str = buildStr childsLst
    let idxValMap = buildIndexMap childsLst
    let re = new Regex("(((;5;)(((;16;)(;5;)))*)?)")
    let elts =
        let res = re.Match(str)
        if Seq.fold (&&) true [for g in res.Groups -> g.Success]
        then res.Groups
        else (new Regex("(((;5;)(((;16;)(;5;)))*)?)",RegexOptions.RightToLeft)).Match(str).Groups
    let e0 =
        if elts.[3].Value <> ""
        then
            let e  =
                let e1 =
                    let ofset = ref 0
                    let e i =
                        let str = elts.[4].Captures.[i].Value
                        let re = new Regex("((;16;)(;5;))")
                        let elts =
                            let res = re.Match(str)
                            if Seq.fold (&&) true [for g in res.Groups -> g.Success]
                            then res.Groups
                            else (new Regex("((;16;)(;5;))",RegexOptions.RightToLeft)).Match(str).Groups
                        let res =
                            let e1 =
                                idxValMap.[!ofset + elts.[3].Captures.[0].Index] |> RELeaf
                            let e0 =
                                idxValMap.[!ofset + elts.[2].Captures.[0].Index] |> RELeaf
                            RESeq [e0; e1]
                        ofset := !ofset + str.Length
                        res
                    REClosure [for i in [0..elts.[4].Captures.Count-1] -> e i]

                let e0 =
                    idxValMap.[elts.[3].Captures.[0].Index] |> RELeaf
                RESeq [e0; e1]
            Some (e)
        else None 
        |>REOpt

    RESeq [e0]
let attribute childsLst = 
    let str = buildStr childsLst
    let idxValMap = buildIndexMap childsLst
    let re = new Regex("((;17;)(;5;)(((;11;)(;6;)))*(;19;))")
    let elts =
        let res = re.Match(str)
        if Seq.fold (&&) true [for g in res.Groups -> g.Success]
        then res.Groups
        else (new Regex("((;17;)(;5;)(((;11;)(;6;)))*(;19;))",RegexOptions.RightToLeft)).Match(str).Groups
    let e3 =
        idxValMap.[elts.[4].Captures.[0].Index] |> RELeaf
    let e2 =
        let ofset = ref 0
        let e i =
            let str = elts.[4].Captures.[i].Value
            let re = new Regex("((;11;)(;6;))")
            let elts =
                let res = re.Match(str)
                if Seq.fold (&&) true [for g in res.Groups -> g.Success]
                then res.Groups
                else (new Regex("((;11;)(;6;))",RegexOptions.RightToLeft)).Match(str).Groups
            let res =
                let e1 =
                    idxValMap.[!ofset + elts.[3].Captures.[0].Index] |> RELeaf
                let e0 =
                    idxValMap.[!ofset + elts.[2].Captures.[0].Index] |> RELeaf
                RESeq [e0; e1]
            ofset := !ofset + str.Length
            res
        REClosure [for i in [0..elts.[4].Captures.Count-1] -> e i]

    let e1 =
        idxValMap.[elts.[3].Captures.[0].Index] |> RELeaf
    let e0 =
        idxValMap.[elts.[2].Captures.[0].Index] |> RELeaf
    RESeq [e0; e1; e2; e3]
let attributeEntry childsLst = 
    let str = buildStr childsLst
    let idxValMap = buildIndexMap childsLst
    let re = new Regex("((;5;)(;20;)(;6;))")
    let elts =
        let res = re.Match(str)
        if Seq.fold (&&) true [for g in res.Groups -> g.Success]
        then res.Groups
        else (new Regex("((;5;)(;20;)(;6;))",RegexOptions.RightToLeft)).Match(str).Groups
    let e2 =
        idxValMap.[elts.[4].Captures.[0].Index] |> RELeaf
    let e1 =
        idxValMap.[elts.[3].Captures.[0].Index] |> RELeaf
    let e0 =
        idxValMap.[elts.[2].Captures.[0].Index] |> RELeaf
    RESeq [e0; e1; e2]
let moduleBody childsLst = 
    let str = buildStr childsLst
    let idxValMap = buildIndexMap childsLst
    let re = new Regex("((;22;)(((;1;)(;6;)))*(;23;))")
    let elts =
        let res = re.Match(str)
        if Seq.fold (&&) true [for g in res.Groups -> g.Success]
        then res.Groups
        else (new Regex("((;22;)(((;1;)(;6;)))*(;23;))",RegexOptions.RightToLeft)).Match(str).Groups
    let e2 =
        idxValMap.[elts.[4].Captures.[0].Index] |> RELeaf
    let e1 =
        let ofset = ref 0
        let e i =
            let str = elts.[3].Captures.[i].Value
            let re = new Regex("((;1;)(;6;))")
            let elts =
                let res = re.Match(str)
                if Seq.fold (&&) true [for g in res.Groups -> g.Success]
                then res.Groups
                else (new Regex("((;1;)(;6;))",RegexOptions.RightToLeft)).Match(str).Groups
            let res =
                let e1 =
                    idxValMap.[!ofset + elts.[3].Captures.[0].Index] |> RELeaf
                let e0 =
                    idxValMap.[!ofset + elts.[2].Captures.[0].Index] |> RELeaf
                RESeq [e0; e1]
            ofset := !ofset + str.Length
            res
        REClosure [for i in [0..elts.[3].Captures.Count-1] -> e i]

    let e0 =
        idxValMap.[elts.[2].Captures.[0].Index] |> RELeaf
    RESeq [e0; e1; e2]
let statement childsLst = 
    let str = buildStr childsLst
    let idxValMap = buildIndexMap childsLst
    let re = new Regex("((;6;)(;13;)(((;16;)(;13;)))*)")
    let elts =
        let res = re.Match(str)
        if Seq.fold (&&) true [for g in res.Groups -> g.Success]
        then res.Groups
        else (new Regex("((;6;)(;13;)(((;16;)(;13;)))*)",RegexOptions.RightToLeft)).Match(str).Groups
    let e2 =
        let ofset = ref 0
        let e i =
            let str = elts.[4].Captures.[i].Value
            let re = new Regex("((;16;)(;13;))")
            let elts =
                let res = re.Match(str)
                if Seq.fold (&&) true [for g in res.Groups -> g.Success]
                then res.Groups
                else (new Regex("((;16;)(;13;))",RegexOptions.RightToLeft)).Match(str).Groups
            let res =
                let e1 =
                    idxValMap.[!ofset + elts.[3].Captures.[0].Index] |> RELeaf
                let e0 =
                    idxValMap.[!ofset + elts.[2].Captures.[0].Index] |> RELeaf
                RESeq [e0; e1]
            ofset := !ofset + str.Length
            res
        REClosure [for i in [0..elts.[4].Captures.Count-1] -> e i]

    let e1 =
        idxValMap.[elts.[3].Captures.[0].Index] |> RELeaf
    let e0 =
        idxValMap.[elts.[2].Captures.[0].Index] |> RELeaf
    RESeq [e0; e1; e2]
let operation childsLst = 
    let str = buildStr childsLst
    let idxValMap = buildIndexMap childsLst
    let re = new Regex("(((;7;))|(((;8;))|((;9;))))")
    let elts =
        let res = re.Match(str)
        if Seq.fold (&&) true [for g in res.Groups -> g.Success]
        then res.Groups
        else (new Regex("(((;7;))|(((;8;))|((;9;))))",RegexOptions.RightToLeft)).Match(str).Groups
    if elts.[3].Value = ""
    then
        let e2 =
            if elts.[6].Value = ""
            then
                let e2 =
                    let e0 =
                        idxValMap.[elts.[8].Captures.[0].Index] |> RELeaf
                    RESeq [e0]
                None, Some (e2)
            else
                let e1 =
                    let e0 =
                        idxValMap.[elts.[6].Captures.[0].Index] |> RELeaf
                    RESeq [e0]
                Some (e1),None
            |> REAlt

        None, Some (e2)
    else
        let e1 =
            let e0 =
                idxValMap.[elts.[3].Captures.[0].Index] |> RELeaf
            RESeq [e0]
        Some (e1),None
    |> REAlt

let assign childsLst = 
    let str = buildStr childsLst
    let idxValMap = buildIndexMap childsLst
    let re = new Regex("((;28;)(;6;))")
    let elts =
        let res = re.Match(str)
        if Seq.fold (&&) true [for g in res.Groups -> g.Success]
        then res.Groups
        else (new Regex("((;28;)(;6;))",RegexOptions.RightToLeft)).Match(str).Groups
    let e1 =
        idxValMap.[elts.[3].Captures.[0].Index] |> RELeaf
    let e0 =
        idxValMap.[elts.[2].Captures.[0].Index] |> RELeaf
    RESeq [e0; e1]
let bind childsLst = 
    let str = buildStr childsLst
    let idxValMap = buildIndexMap childsLst
    let re = new Regex("((;29;)(;6;))")
    let elts =
        let res = re.Match(str)
        if Seq.fold (&&) true [for g in res.Groups -> g.Success]
        then res.Groups
        else (new Regex("((;29;)(;6;))",RegexOptions.RightToLeft)).Match(str).Groups
    let e1 =
        idxValMap.[elts.[3].Captures.[0].Index] |> RELeaf
    let e0 =
        idxValMap.[elts.[2].Captures.[0].Index] |> RELeaf
    RESeq [e0; e1]
let bindHandler childsLst = 
    let str = buildStr childsLst
    let idxValMap = buildIndexMap childsLst
    let re = new Regex("((;30;)(((;5;))|((;19;))))")
    let elts =
        let res = re.Match(str)
        if Seq.fold (&&) true [for g in res.Groups -> g.Success]
        then res.Groups
        else (new Regex("((;30;)(((;5;))|((;19;))))",RegexOptions.RightToLeft)).Match(str).Groups
    let e1 =
        if elts.[5].Value = ""
        then
            let e2 =
                let e0 =
                    idxValMap.[elts.[7].Captures.[0].Index] |> RELeaf
                RESeq [e0]
            None, Some (e2)
        else
            let e1 =
                let e0 =
                    idxValMap.[elts.[5].Captures.[0].Index] |> RELeaf
                RESeq [e0]
            Some (e1),None
        |> REAlt

    let e0 =
        idxValMap.[elts.[2].Captures.[0].Index] |> RELeaf
    RESeq [e0; e1]
let expression childsLst = 
    let str = buildStr childsLst
    let idxValMap = buildIndexMap childsLst
    let re = new Regex("(((;18;))|(((;14;))|(((;15;))|((;16;)))))")
    let elts =
        let res = re.Match(str)
        if Seq.fold (&&) true [for g in res.Groups -> g.Success]
        then res.Groups
        else (new Regex("(((;18;))|(((;14;))|(((;15;))|((;16;)))))",RegexOptions.RightToLeft)).Match(str).Groups
    if elts.[3].Value = ""
    then
        let e2 =
            if elts.[6].Value = ""
            then
                let e2 =
                    if elts.[9].Value = ""
                    then
                        let e2 =
                            let e0 =
                                idxValMap.[elts.[11].Captures.[0].Index] |> RELeaf
                            RESeq [e0]
                        None, Some (e2)
                    else
                        let e1 =
                            let e0 =
                                idxValMap.[elts.[9].Captures.[0].Index] |> RELeaf
                            RESeq [e0]
                        Some (e1),None
                    |> REAlt

                None, Some (e2)
            else
                let e1 =
                    let e0 =
                        idxValMap.[elts.[6].Captures.[0].Index] |> RELeaf
                    RESeq [e0]
                Some (e1),None
            |> REAlt

        None, Some (e2)
    else
        let e1 =
            let e0 =
                idxValMap.[elts.[3].Captures.[0].Index] |> RELeaf
            RESeq [e0]
        Some (e1),None
    |> REAlt

let expressionList childsLst = 
    let str = buildStr childsLst
    let idxValMap = buildIndexMap childsLst
    let re = new Regex("((;17;)((;6;)(((;16;)(;6;)))*)?(;19;))")
    let elts =
        let res = re.Match(str)
        if Seq.fold (&&) true [for g in res.Groups -> g.Success]
        then res.Groups
        else (new Regex("((;17;)((;6;)(((;16;)(;6;)))*)?(;19;))",RegexOptions.RightToLeft)).Match(str).Groups
    let e2 =
        idxValMap.[elts.[4].Captures.[0].Index] |> RELeaf
    let e1 =
        if elts.[3].Value <> ""
        then
            let e  =
                let e1 =
                    let ofset = ref 0
                    let e i =
                        let str = elts.[5].Captures.[i].Value
                        let re = new Regex("((;16;)(;6;))")
                        let elts =
                            let res = re.Match(str)
                            if Seq.fold (&&) true [for g in res.Groups -> g.Success]
                            then res.Groups
                            else (new Regex("((;16;)(;6;))",RegexOptions.RightToLeft)).Match(str).Groups
                        let res =
                            let e1 =
                                idxValMap.[!ofset + elts.[3].Captures.[0].Index] |> RELeaf
                            let e0 =
                                idxValMap.[!ofset + elts.[2].Captures.[0].Index] |> RELeaf
                            RESeq [e0; e1]
                        ofset := !ofset + str.Length
                        res
                    REClosure [for i in [0..elts.[5].Captures.Count-1] -> e i]

                let e0 =
                    idxValMap.[elts.[4].Captures.[0].Index] |> RELeaf
                RESeq [e0; e1]
            Some (e)
        else None 
        |>REOpt

    let e0 =
        idxValMap.[elts.[2].Captures.[0].Index] |> RELeaf
    RESeq [e0; e1; e2]
let expression_b childsLst = 
    let str = buildStr childsLst
    let idxValMap = buildIndexMap childsLst
    let re = new Regex("((;20;)((((;37;))|(((;38;))|(((;39;))|(((;40;))|((;41;))))))(;20;))?)")
    let elts =
        let res = re.Match(str)
        if Seq.fold (&&) true [for g in res.Groups -> g.Success]
        then res.Groups
        else (new Regex("((;20;)((((;37;))|(((;38;))|(((;39;))|(((;40;))|((;41;))))))(;20;))?)",RegexOptions.RightToLeft)).Match(str).Groups
    let e1 =
        if elts.[18].Value <> ""
        then
            let e  =
                let e1 =
                    idxValMap.[elts.[18].Captures.[0].Index] |> RELeaf
                let e0 =
                    if elts.[6].Value = ""
                    then
                        let e2 =
                            if elts.[9].Value = ""
                            then
                                let e2 =
                                    if elts.[12].Value = ""
                                    then
                                        let e2 =
                                            if elts.[15].Value = ""
                                            then
                                                let e2 =
                                                    let e0 =
                                                        idxValMap.[elts.[17].Captures.[0].Index] |> RELeaf
                                                    RESeq [e0]
                                                None, Some (e2)
                                            else
                                                let e1 =
                                                    let e0 =
                                                        idxValMap.[elts.[15].Captures.[0].Index] |> RELeaf
                                                    RESeq [e0]
                                                Some (e1),None
                                            |> REAlt

                                        None, Some (e2)
                                    else
                                        let e1 =
                                            let e0 =
                                                idxValMap.[elts.[12].Captures.[0].Index] |> RELeaf
                                            RESeq [e0]
                                        Some (e1),None
                                    |> REAlt

                                None, Some (e2)
                            else
                                let e1 =
                                    let e0 =
                                        idxValMap.[elts.[9].Captures.[0].Index] |> RELeaf
                                    RESeq [e0]
                                Some (e1),None
                            |> REAlt

                        None, Some (e2)
                    else
                        let e1 =
                            let e0 =
                                idxValMap.[elts.[6].Captures.[0].Index] |> RELeaf
                            RESeq [e0]
                        Some (e1),None
                    |> REAlt

                RESeq [e0; e1]
            Some (e)
        else None 
        |>REOpt

    let e0 =
        idxValMap.[elts.[2].Captures.[0].Index] |> RELeaf
    RESeq [e0; e1]
let expression_b1 childsLst = 
    let str = buildStr childsLst
    let idxValMap = buildIndexMap childsLst
    let re = new Regex("((;17;)(((;43;)(;17;)))*)")
    let elts =
        let res = re.Match(str)
        if Seq.fold (&&) true [for g in res.Groups -> g.Success]
        then res.Groups
        else (new Regex("((;17;)(((;43;)(;17;)))*)",RegexOptions.RightToLeft)).Match(str).Groups
    let e1 =
        let ofset = ref 0
        let e i =
            let str = elts.[3].Captures.[i].Value
            let re = new Regex("((;43;)(;17;))")
            let elts =
                let res = re.Match(str)
                if Seq.fold (&&) true [for g in res.Groups -> g.Success]
                then res.Groups
                else (new Regex("((;43;)(;17;))",RegexOptions.RightToLeft)).Match(str).Groups
            let res =
                let e1 =
                    idxValMap.[!ofset + elts.[3].Captures.[0].Index] |> RELeaf
                let e0 =
                    idxValMap.[!ofset + elts.[2].Captures.[0].Index] |> RELeaf
                RESeq [e0; e1]
            ofset := !ofset + str.Length
            res
        REClosure [for i in [0..elts.[3].Captures.Count-1] -> e i]

    let e0 =
        idxValMap.[elts.[2].Captures.[0].Index] |> RELeaf
    RESeq [e0; e1]
let expression_b2 childsLst = 
    let str = buildStr childsLst
    let idxValMap = buildIndexMap childsLst
    let re = new Regex("((;26;)(((;45;)(;26;)))*)")
    let elts =
        let res = re.Match(str)
        if Seq.fold (&&) true [for g in res.Groups -> g.Success]
        then res.Groups
        else (new Regex("((;26;)(((;45;)(;26;)))*)",RegexOptions.RightToLeft)).Match(str).Groups
    let e1 =
        let ofset = ref 0
        let e i =
            let str = elts.[3].Captures.[i].Value
            let re = new Regex("((;45;)(;26;))")
            let elts =
                let res = re.Match(str)
                if Seq.fold (&&) true [for g in res.Groups -> g.Success]
                then res.Groups
                else (new Regex("((;45;)(;26;))",RegexOptions.RightToLeft)).Match(str).Groups
            let res =
                let e1 =
                    idxValMap.[!ofset + elts.[3].Captures.[0].Index] |> RELeaf
                let e0 =
                    idxValMap.[!ofset + elts.[2].Captures.[0].Index] |> RELeaf
                RESeq [e0; e1]
            ofset := !ofset + str.Length
            res
        REClosure [for i in [0..elts.[3].Captures.Count-1] -> e i]

    let e0 =
        idxValMap.[elts.[2].Captures.[0].Index] |> RELeaf
    RESeq [e0; e1]
let expression_b3 childsLst = 
    let str = buildStr childsLst
    let idxValMap = buildIndexMap childsLst
    let re = new Regex("(((;46;))|(((;47;))|(((;5;))|(((;22;))|(((;12;)(;18;)(;14;)))))))")
    let elts =
        let res = re.Match(str)
        if Seq.fold (&&) true [for g in res.Groups -> g.Success]
        then res.Groups
        else (new Regex("(((;46;))|(((;47;))|(((;5;))|(((;22;))|(((;12;)(;18;)(;14;)))))))",RegexOptions.RightToLeft)).Match(str).Groups
    if elts.[3].Value = ""
    then
        let e2 =
            if elts.[6].Value = ""
            then
                let e2 =
                    if elts.[9].Value = ""
                    then
                        let e2 =
                            if elts.[12].Value = ""
                            then
                                let e2 =
                                    let e0 =
                                        let e2 =
                                            idxValMap.[elts.[17].Captures.[0].Index] |> RELeaf
                                        let e1 =
                                            idxValMap.[elts.[16].Captures.[0].Index] |> RELeaf
                                        let e0 =
                                            idxValMap.[elts.[15].Captures.[0].Index] |> RELeaf
                                        RESeq [e0; e1; e2]
                                    RESeq [e0]
                                None, Some (e2)
                            else
                                let e1 =
                                    let e0 =
                                        idxValMap.[elts.[12].Captures.[0].Index] |> RELeaf
                                    RESeq [e0]
                                Some (e1),None
                            |> REAlt

                        None, Some (e2)
                    else
                        let e1 =
                            let e0 =
                                idxValMap.[elts.[9].Captures.[0].Index] |> RELeaf
                            RESeq [e0]
                        Some (e1),None
                    |> REAlt

                None, Some (e2)
            else
                let e1 =
                    let e0 =
                        idxValMap.[elts.[6].Captures.[0].Index] |> RELeaf
                    RESeq [e0]
                Some (e1),None
            |> REAlt

        None, Some (e2)
    else
        let e1 =
            let e0 =
                idxValMap.[elts.[3].Captures.[0].Index] |> RELeaf
            RESeq [e0]
        Some (e1),None
    |> REAlt

let expression_v childsLst = 
    let str = buildStr childsLst
    let idxValMap = buildIndexMap childsLst
    let re = new Regex("(((;23;))|(((;24;))|(((;25;))|(((;19;))|((;5;))))))")
    let elts =
        let res = re.Match(str)
        if Seq.fold (&&) true [for g in res.Groups -> g.Success]
        then res.Groups
        else (new Regex("(((;23;))|(((;24;))|(((;25;))|(((;19;))|((;5;))))))",RegexOptions.RightToLeft)).Match(str).Groups
    if elts.[3].Value = ""
    then
        let e2 =
            if elts.[6].Value = ""
            then
                let e2 =
                    if elts.[9].Value = ""
                    then
                        let e2 =
                            if elts.[12].Value = ""
                            then
                                let e2 =
                                    let e0 =
                                        idxValMap.[elts.[14].Captures.[0].Index] |> RELeaf
                                    RESeq [e0]
                                None, Some (e2)
                            else
                                let e1 =
                                    let e0 =
                                        idxValMap.[elts.[12].Captures.[0].Index] |> RELeaf
                                    RESeq [e0]
                                Some (e1),None
                            |> REAlt

                        None, Some (e2)
                    else
                        let e1 =
                            let e0 =
                                idxValMap.[elts.[9].Captures.[0].Index] |> RELeaf
                            RESeq [e0]
                        Some (e1),None
                    |> REAlt

                None, Some (e2)
            else
                let e1 =
                    let e0 =
                        idxValMap.[elts.[6].Captures.[0].Index] |> RELeaf
                    RESeq [e0]
                Some (e1),None
            |> REAlt

        None, Some (e2)
    else
        let e1 =
            let e0 =
                idxValMap.[elts.[3].Captures.[0].Index] |> RELeaf
            RESeq [e0]
        Some (e1),None
    |> REAlt

let expression_i childsLst = 
    let str = buildStr childsLst
    let idxValMap = buildIndexMap childsLst
    let re = new Regex("((;33;)((((;53;))|((;54;)))(;14;))?)")
    let elts =
        let res = re.Match(str)
        if Seq.fold (&&) true [for g in res.Groups -> g.Success]
        then res.Groups
        else (new Regex("((;33;)((((;53;))|((;54;)))(;14;))?)",RegexOptions.RightToLeft)).Match(str).Groups
    let e1 =
        if elts.[9].Value <> ""
        then
            let e  =
                let e1 =
                    idxValMap.[elts.[9].Captures.[0].Index] |> RELeaf
                let e0 =
                    if elts.[6].Value = ""
                    then
                        let e2 =
                            let e0 =
                                idxValMap.[elts.[8].Captures.[0].Index] |> RELeaf
                            RESeq [e0]
                        None, Some (e2)
                    else
                        let e1 =
                            let e0 =
                                idxValMap.[elts.[6].Captures.[0].Index] |> RELeaf
                            RESeq [e0]
                        Some (e1),None
                    |> REAlt

                RESeq [e0; e1]
            Some (e)
        else None 
        |>REOpt

    let e0 =
        idxValMap.[elts.[2].Captures.[0].Index] |> RELeaf
    RESeq [e0; e1]
let expression_i1 childsLst = 
    let str = buildStr childsLst
    let idxValMap = buildIndexMap childsLst
    let re = new Regex("((;30;)((((;56;))|((;57;)))(;14;))?)")
    let elts =
        let res = re.Match(str)
        if Seq.fold (&&) true [for g in res.Groups -> g.Success]
        then res.Groups
        else (new Regex("((;30;)((((;56;))|((;57;)))(;14;))?)",RegexOptions.RightToLeft)).Match(str).Groups
    let e1 =
        if elts.[9].Value <> ""
        then
            let e  =
                let e1 =
                    idxValMap.[elts.[9].Captures.[0].Index] |> RELeaf
                let e0 =
                    if elts.[6].Value = ""
                    then
                        let e2 =
                            let e0 =
                                idxValMap.[elts.[8].Captures.[0].Index] |> RELeaf
                            RESeq [e0]
                        None, Some (e2)
                    else
                        let e1 =
                            let e0 =
                                idxValMap.[elts.[6].Captures.[0].Index] |> RELeaf
                            RESeq [e0]
                        Some (e1),None
                    |> REAlt

                RESeq [e0; e1]
            Some (e)
        else None 
        |>REOpt

    let e0 =
        idxValMap.[elts.[2].Captures.[0].Index] |> RELeaf
    RESeq [e0; e1]
let expression_i2 childsLst = 
    let str = buildStr childsLst
    let idxValMap = buildIndexMap childsLst
    let re = new Regex("((;27;)(((;59;)(((;5;))|((;22;)))))*)")
    let elts =
        let res = re.Match(str)
        if Seq.fold (&&) true [for g in res.Groups -> g.Success]
        then res.Groups
        else (new Regex("((;27;)(((;59;)(((;5;))|((;22;)))))*)",RegexOptions.RightToLeft)).Match(str).Groups
    let e1 =
        let ofset = ref 0
        let e i =
            let str = elts.[3].Captures.[i].Value
            let re = new Regex("((;59;)(((;5;))|((;22;))))")
            let elts =
                let res = re.Match(str)
                if Seq.fold (&&) true [for g in res.Groups -> g.Success]
                then res.Groups
                else (new Regex("((;59;)(((;5;))|((;22;))))",RegexOptions.RightToLeft)).Match(str).Groups
            let res =
                let e1 =
                    if elts.[5].Value = ""
                    then
                        let e2 =
                            let e0 =
                                idxValMap.[!ofset + elts.[7].Captures.[0].Index] |> RELeaf
                            RESeq [e0]
                        None, Some (e2)
                    else
                        let e1 =
                            let e0 =
                                idxValMap.[!ofset + elts.[5].Captures.[0].Index] |> RELeaf
                            RESeq [e0]
                        Some (e1),None
                    |> REAlt

                let e0 =
                    idxValMap.[!ofset + elts.[2].Captures.[0].Index] |> RELeaf
                RESeq [e0; e1]
            ofset := !ofset + str.Length
            res
        REClosure [for i in [0..elts.[3].Captures.Count-1] -> e i]

    let e0 =
        idxValMap.[elts.[2].Captures.[0].Index] |> RELeaf
    RESeq [e0; e1]
let expression_i3 childsLst = 
    let str = buildStr childsLst
    let idxValMap = buildIndexMap childsLst
    let re = new Regex("(((;31;))|(((;5;))|(((;22;))|(((;12;)(;14;)(;14;))))))")
    let elts =
        let res = re.Match(str)
        if Seq.fold (&&) true [for g in res.Groups -> g.Success]
        then res.Groups
        else (new Regex("(((;31;))|(((;5;))|(((;22;))|(((;12;)(;14;)(;14;))))))",RegexOptions.RightToLeft)).Match(str).Groups
    if elts.[3].Value = ""
    then
        let e2 =
            if elts.[6].Value = ""
            then
                let e2 =
                    if elts.[9].Value = ""
                    then
                        let e2 =
                            let e0 =
                                let e2 =
                                    idxValMap.[elts.[14].Captures.[0].Index] |> RELeaf
                                let e1 =
                                    idxValMap.[elts.[13].Captures.[0].Index] |> RELeaf
                                let e0 =
                                    idxValMap.[elts.[12].Captures.[0].Index] |> RELeaf
                                RESeq [e0; e1; e2]
                            RESeq [e0]
                        None, Some (e2)
                    else
                        let e1 =
                            let e0 =
                                idxValMap.[elts.[9].Captures.[0].Index] |> RELeaf
                            RESeq [e0]
                        Some (e1),None
                    |> REAlt

                None, Some (e2)
            else
                let e1 =
                    let e0 =
                        idxValMap.[elts.[6].Captures.[0].Index] |> RELeaf
                    RESeq [e0]
                Some (e1),None
            |> REAlt

        None, Some (e2)
    else
        let e1 =
            let e0 =
                idxValMap.[elts.[3].Captures.[0].Index] |> RELeaf
            RESeq [e0]
        Some (e1),None
    |> REAlt

let apply childsLst = 
    let str = buildStr childsLst
    let idxValMap = buildIndexMap childsLst
    let re = new Regex("((;5;)(;12;)((;6;)(((;16;)(;6;)))*)?(;14;))")
    let elts =
        let res = re.Match(str)
        if Seq.fold (&&) true [for g in res.Groups -> g.Success]
        then res.Groups
        else (new Regex("((;5;)(;12;)((;6;)(((;16;)(;6;)))*)?(;14;))",RegexOptions.RightToLeft)).Match(str).Groups
    let e3 =
        idxValMap.[elts.[4].Captures.[0].Index] |> RELeaf
    let e2 =
        if elts.[3].Value <> ""
        then
            let e  =
                let e1 =
                    let ofset = ref 0
                    let e i =
                        let str = elts.[6].Captures.[i].Value
                        let re = new Regex("((;16;)(;6;))")
                        let elts =
                            let res = re.Match(str)
                            if Seq.fold (&&) true [for g in res.Groups -> g.Success]
                            then res.Groups
                            else (new Regex("((;16;)(;6;))",RegexOptions.RightToLeft)).Match(str).Groups
                        let res =
                            let e1 =
                                idxValMap.[!ofset + elts.[3].Captures.[0].Index] |> RELeaf
                            let e0 =
                                idxValMap.[!ofset + elts.[2].Captures.[0].Index] |> RELeaf
                            RESeq [e0; e1]
                        ofset := !ofset + str.Length
                        res
                    REClosure [for i in [0..elts.[6].Captures.Count-1] -> e i]

                let e0 =
                    idxValMap.[elts.[5].Captures.[0].Index] |> RELeaf
                RESeq [e0; e1]
            Some (e)
        else None 
        |>REOpt

    let e1 =
        idxValMap.[elts.[3].Captures.[0].Index] |> RELeaf
    let e0 =
        idxValMap.[elts.[2].Captures.[0].Index] |> RELeaf
    RESeq [e0; e1; e2; e3]
let value_i childsLst = 
    let str = buildStr childsLst
    let idxValMap = buildIndexMap childsLst
    let re = new Regex("(((;61;))|((;62;)))")
    let elts =
        let res = re.Match(str)
        if Seq.fold (&&) true [for g in res.Groups -> g.Success]
        then res.Groups
        else (new Regex("(((;61;))|((;62;)))",RegexOptions.RightToLeft)).Match(str).Groups
    if elts.[3].Value = ""
    then
        let e2 =
            let e0 =
                idxValMap.[elts.[5].Captures.[0].Index] |> RELeaf
            RESeq [e0]
        None, Some (e2)
    else
        let e1 =
            let e0 =
                idxValMap.[elts.[3].Captures.[0].Index] |> RELeaf
            RESeq [e0]
        Some (e1),None
    |> REAlt

let function childsLst = 
    let str = buildStr childsLst
    let idxValMap = buildIndexMap childsLst
    let re = new Regex("((;29;)((;3;))*(;32;))")
    let elts =
        let res = re.Match(str)
        if Seq.fold (&&) true [for g in res.Groups -> g.Success]
        then res.Groups
        else (new Regex("((;29;)((;3;))*(;32;))",RegexOptions.RightToLeft)).Match(str).Groups
    let e2 =
        idxValMap.[elts.[2].Captures.[0].Index] |> RELeaf
    let e1 =
        let ofset = ref 0
        let e i =
            let str = elts.[3].Captures.[i].Value
            let re = new Regex("(;3;)")
            let elts =
                let res = re.Match(str)
                if Seq.fold (&&) true [for g in res.Groups -> g.Success]
                then res.Groups
                else (new Regex("(;3;)",RegexOptions.RightToLeft)).Match(str).Groups
            let res =
                idxValMap.[!ofset + elts.[1].Captures.[0].Index] |> RELeaf
            ofset := !ofset + str.Length
            res
        REClosure [for i in [0..elts.[3].Captures.Count-1] -> e i]

    let e0 =
        idxValMap.[elts.[2].Captures.[0].Index] |> RELeaf
    RESeq [e0; e1; e2]
let functionHeader childsLst = 
    let str = buildStr childsLst
    let idxValMap = buildIndexMap childsLst
    let re = new Regex("((;65;)(;12;)(;4;)(;14;))")
    let elts =
        let res = re.Match(str)
        if Seq.fold (&&) true [for g in res.Groups -> g.Success]
        then res.Groups
        else (new Regex("((;65;)(;12;)(;4;)(;14;))",RegexOptions.RightToLeft)).Match(str).Groups
    let e3 =
        idxValMap.[elts.[5].Captures.[0].Index] |> RELeaf
    let e2 =
        idxValMap.[elts.[4].Captures.[0].Index] |> RELeaf
    let e1 =
        idxValMap.[elts.[3].Captures.[0].Index] |> RELeaf
    let e0 =
        idxValMap.[elts.[2].Captures.[0].Index] |> RELeaf
    RESeq [e0; e1; e2; e3]
let functionBody childsLst = 
    let str = buildStr childsLst
    let idxValMap = buildIndexMap childsLst
    let re = new Regex("((;22;)(((;1;)(;6;)))*(;23;))")
    let elts =
        let res = re.Match(str)
        if Seq.fold (&&) true [for g in res.Groups -> g.Success]
        then res.Groups
        else (new Regex("((;22;)(((;1;)(;6;)))*(;23;))",RegexOptions.RightToLeft)).Match(str).Groups
    let e2 =
        idxValMap.[elts.[4].Captures.[0].Index] |> RELeaf
    let e1 =
        let ofset = ref 0
        let e i =
            let str = elts.[3].Captures.[i].Value
            let re = new Regex("((;1;)(;6;))")
            let elts =
                let res = re.Match(str)
                if Seq.fold (&&) true [for g in res.Groups -> g.Success]
                then res.Groups
                else (new Regex("((;1;)(;6;))",RegexOptions.RightToLeft)).Match(str).Groups
            let res =
                let e1 =
                    idxValMap.[!ofset + elts.[3].Captures.[0].Index] |> RELeaf
                let e0 =
                    idxValMap.[!ofset + elts.[2].Captures.[0].Index] |> RELeaf
                RESeq [e0; e1]
            ofset := !ofset + str.Length
            res
        REClosure [for i in [0..elts.[3].Captures.Count-1] -> e i]

    let e0 =
        idxValMap.[elts.[2].Captures.[0].Index] |> RELeaf
    RESeq [e0; e1; e2]
let event childsLst = 
    let str = buildStr childsLst
    let idxValMap = buildIndexMap childsLst
    let re = new Regex("((((;12;)((;3;))*))|(((;67;)(;12;)(;6;)(;16;)(;28;)(;14;))))")
    let elts =
        let res = re.Match(str)
        if Seq.fold (&&) true [for g in res.Groups -> g.Success]
        then res.Groups
        else (new Regex("((((;12;)((;3;))*))|(((;67;)(;12;)(;6;)(;16;)(;28;)(;14;))))",RegexOptions.RightToLeft)).Match(str).Groups
    if elts.[1].Value = ""
    then
        let e2 =
            let e0 =
                let e5 =
                    idxValMap.[elts.[9].Captures.[0].Index] |> RELeaf
                let e4 =
                    idxValMap.[elts.[8].Captures.[0].Index] |> RELeaf
                let e3 =
                    idxValMap.[elts.[7].Captures.[0].Index] |> RELeaf
                let e2 =
                    idxValMap.[elts.[6].Captures.[0].Index] |> RELeaf
                let e1 =
                    idxValMap.[elts.[5].Captures.[0].Index] |> RELeaf
                let e0 =
                    idxValMap.[elts.[4].Captures.[0].Index] |> RELeaf
                RESeq [e0; e1; e2; e3; e4; e5]
            RESeq [e0]
        None, Some (e2)
    else
        let e1 =
            let e0 =
                let e1 =
                    let ofset = ref 0
                    let e i =
                        let str = elts.[5].Captures.[i].Value
                        let re = new Regex("(;3;)")
                        let elts =
                            let res = re.Match(str)
                            if Seq.fold (&&) true [for g in res.Groups -> g.Success]
                            then res.Groups
                            else (new Regex("(;3;)",RegexOptions.RightToLeft)).Match(str).Groups
                        let res =
                            idxValMap.[!ofset + elts.[1].Captures.[0].Index] |> RELeaf
                        ofset := !ofset + str.Length
                        res
                    REClosure [for i in [0..elts.[5].Captures.Count-1] -> e i]

                let e0 =
                    idxValMap.[elts.[4].Captures.[0].Index] |> RELeaf
                RESeq [e0; e1]
            RESeq [e0]
        Some (e1),None
    |> REAlt

let eventHeader childsLst = 
    let str = buildStr childsLst
    let idxValMap = buildIndexMap childsLst
    let re = new Regex("((;69;))")
    let elts =
        let res = re.Match(str)
        if Seq.fold (&&) true [for g in res.Groups -> g.Success]
        then res.Groups
        else (new Regex("((;69;))",RegexOptions.RightToLeft)).Match(str).Groups
    let e0 =
        idxValMap.[elts.[2].Captures.[0].Index] |> RELeaf
    RESeq [e0]
let handler childsLst = 
    let str = buildStr childsLst
    let idxValMap = buildIndexMap childsLst
    let re = new Regex("((;34;)((;3;))*(;35;))")
    let elts =
        let res = re.Match(str)
        if Seq.fold (&&) true [for g in res.Groups -> g.Success]
        then res.Groups
        else (new Regex("((;34;)((;3;))*(;35;))",RegexOptions.RightToLeft)).Match(str).Groups
    let e2 =
        idxValMap.[elts.[2].Captures.[0].Index] |> RELeaf
    let e1 =
        let ofset = ref 0
        let e i =
            let str = elts.[3].Captures.[i].Value
            let re = new Regex("(;3;)")
            let elts =
                let res = re.Match(str)
                if Seq.fold (&&) true [for g in res.Groups -> g.Success]
                then res.Groups
                else (new Regex("(;3;)",RegexOptions.RightToLeft)).Match(str).Groups
            let res =
                idxValMap.[!ofset + elts.[1].Captures.[0].Index] |> RELeaf
            ofset := !ofset + str.Length
            res
        REClosure [for i in [0..elts.[3].Captures.Count-1] -> e i]

    let e0 =
        idxValMap.[elts.[2].Captures.[0].Index] |> RELeaf
    RESeq [e0; e1; e2]
let handlerHeader childsLst = 
    let str = buildStr childsLst
    let idxValMap = buildIndexMap childsLst
    let re = new Regex("(((;72;))|((;73;)))")
    let elts =
        let res = re.Match(str)
        if Seq.fold (&&) true [for g in res.Groups -> g.Success]
        then res.Groups
        else (new Regex("(((;72;))|((;73;)))",RegexOptions.RightToLeft)).Match(str).Groups
    if elts.[3].Value = ""
    then
        let e2 =
            let e0 =
                idxValMap.[elts.[5].Captures.[0].Index] |> RELeaf
            RESeq [e0]
        None, Some (e2)
    else
        let e1 =
            let e0 =
                idxValMap.[elts.[3].Captures.[0].Index] |> RELeaf
            RESeq [e0]
        Some (e1),None
    |> REAlt

let handlerBody childsLst = 
    let str = buildStr childsLst
    let idxValMap = buildIndexMap childsLst
    let re = new Regex("((;22;)(((;1;)(;6;)))*(;23;))")
    let elts =
        let res = re.Match(str)
        if Seq.fold (&&) true [for g in res.Groups -> g.Success]
        then res.Groups
        else (new Regex("((;22;)(((;1;)(;6;)))*(;23;))",RegexOptions.RightToLeft)).Match(str).Groups
    let e2 =
        idxValMap.[elts.[4].Captures.[0].Index] |> RELeaf
    let e1 =
        let ofset = ref 0
        let e i =
            let str = elts.[3].Captures.[i].Value
            let re = new Regex("((;1;)(;6;))")
            let elts =
                let res = re.Match(str)
                if Seq.fold (&&) true [for g in res.Groups -> g.Success]
                then res.Groups
                else (new Regex("((;1;)(;6;))",RegexOptions.RightToLeft)).Match(str).Groups
            let res =
                let e1 =
                    idxValMap.[!ofset + elts.[3].Captures.[0].Index] |> RELeaf
                let e0 =
                    idxValMap.[!ofset + elts.[2].Captures.[0].Index] |> RELeaf
                RESeq [e0; e1]
            ofset := !ofset + str.Length
            res
        REClosure [for i in [0..elts.[3].Captures.Count-1] -> e i]

    let e0 =
        idxValMap.[elts.[2].Captures.[0].Index] |> RELeaf
    RESeq [e0; e1; e2]
let fieldList childsLst = 
    let str = buildStr childsLst
    let idxValMap = buildIndexMap childsLst
    let re = new Regex("((;17;)(;4;)(;19;))")
    let elts =
        let res = re.Match(str)
        if Seq.fold (&&) true [for g in res.Groups -> g.Success]
        then res.Groups
        else (new Regex("((;17;)(;4;)(;19;))",RegexOptions.RightToLeft)).Match(str).Groups
    let e2 =
        idxValMap.[elts.[4].Captures.[0].Index] |> RELeaf
    let e1 =
        idxValMap.[elts.[3].Captures.[0].Index] |> RELeaf
    let e0 =
        idxValMap.[elts.[2].Captures.[0].Index] |> RELeaf
    RESeq [e0; e1; e2]

let ruleToRegex = dict [|(28,fieldList); (35,handlerBody); (34,handlerHeader); (19,handler); (12,eventHeader); (25,event); (32,functionBody); (29,functionHeader); (24,function); (31,value_i); (22,apply); (27,expression_i3); (30,expression_i2); (33,expression_i1); (14,expression_i); (15,expression_v); (26,expression_b3); (17,expression_b2); (20,expression_b1); (18,expression_b); (16,expressionList); (6,expression); (9,bindHandler); (8,bind); (7,assign); (13,operation); (1,statement); (10,moduleBody); (11,attributeEntry); (3,attribute); (4,fields); (21,moduleHeader); (23,module); (5,name); (0,file)|]

