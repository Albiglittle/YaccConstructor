// CodeGenerator.fs
//
// Copyright 2009 Semen Grigorev
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation.

#light
module Yard.Core.CodeGenerator
open Utils
open IO


type CodeGenerator(sourceGramamr: string ,outPath: string) = class

  let outStream = IO.text_writer outPath
  
  let varEnumerator = new Enumerator()
  
  let defaultParams = "(seqNum,varNum)" 
  
  let genHeader = 
      "//this file was generated by YARD Recursive-Ascent \n//source grammar:"+
      sourceGramamr +
      "\n//date:" + System.DateTime.Now.ToString() +
      "\n#light \"off\"\n" +      
      "\nmodule Actions\n"+
      "open Yard.Core\n"
                  
  let genDefaultFanctions = 
      "let getValue,getSeqNum =\n"+
      "    let _getV arg = snd arg in\n"+
      "    let _getSeqNum arg = fst arg in\n"+
      "    _getV,_getSeqNum\n"
         

                  
  let genSome code bindings = 
      let param = 
          if bindings = []
          then "_"
          else "((" + (List.fold (fun prms prm -> prms + "),(" + prm + ")") "" bindings) + ")"
      "List.map (fun "+param+"->\n  "+code+")"    

  let genBindingMap bindings =
      List.map (fun (k:Option<_>) -> ((if k.IsNone then None else Some(IL.Source.toString k.Value)) ,"x"+(varEnumerator.Next()).ToString()))  bindings

  let genBynding (bnd,var) code =
      let codeIsEmpty = String.trim [' ';'\n'] code <> ""
      match bnd with
      |Some(_bnd) -> "let (" + _bnd + ") = "+ (if codeIsEmpty 
                                               then "\n(" + code + ")" 
                                               else "") + "(getValue " +  var + ") in \n"
      |None        ->  if codeIsEmpty 
                       then "(" + code + ")" + "(getValue " +  var + ") \n"
                       else "" 
         
  let genSeq code bindingLst action=     
      let bnpl =  bindingLst 
      let _params = List.fold (fun buf (_,name) -> buf + " " + name) (snd (List.hd bnpl)) (List.tl bnpl)
      "fun " + _params + " ->\n  " + code + action
  
  let close () = outStream.Close();
  
  let write (str:string) = outStream.WriteLine(str)
  
  let genTopLEvelBinding name code binding = 
      let argNames = List.fold (fun buf arg -> buf + " " + arg) "" 
                               (List.init (List.length binding) (fun i -> "arg"+i.ToString()))
      "\n\nlet " + name + " "+argNames+" = \n (" + code + ")"+argNames
      
  //let genAlt seqNum code1 code2 =        
  
  let genAlt lAltNum rAltNum code1 code2 bindings = 
      "if getSeqNum" + (snd bindings) + ")>=" + lAltNum.ToString() + "\n"+
      "then " + code1 + "\n"+
      "else " + code2 + "\n"
  
  member self.GenSome code bindings = genSome code bindings
  member self.GenBindingMap bindings = genBindingMap bindings
  member self.GenBynding bndVarMap code = genBynding bndVarMap code
  member self.GenSeq code bindingLst action = genSeq code bindingLst action
  member self.CloseOutStream () = close ()
  member self.Write str = write str
  member self.GenTopLEvelBinding name code binding = genTopLEvelBinding name code binding
  member self.GenHeader () = genHeader
  member self.GenDefaultFunctions with get() = genDefaultFanctions
  member self.GenAlt lAltNum rAltNum code1 code2 bindings =genAlt lAltNum rAltNum code1 code2 bindings
end