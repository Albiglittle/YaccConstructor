{
//  UserLexer.fs contains simple lexer for testing.
//
//  for build:  fslex Lexer.fsl --unicode -o Lexer.fs
//
//  Copyright 2010, 2011, 2011 Semen Grigorev <rsdpisuy@gmail.com>
//
//  This file is part of YaccConctructor.
//
//  YaccConstructor is free software:you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.

module Lexer_alt
open Microsoft.FSharp.Text.Lexing
open Microsoft.FSharp.Text
open Yard.Generators.GNESCCGenerator
open Yard.Generators.GNESCCGenerator.Tables
open Microsoft.FSharp.Reflection
open LexerHelper

exception IdentToken
let getKwToken (name: string) = 
  try
    match name.ToUpper() with
    | "BEGIN"     -> T_KW_BEGIN
    | "END"       -> T_KW_END
    | "EXEC" 
    | "IF"        -> T_KW_IF
(*    | "ELSE"      -> T_KW_ELSE *)
    | "THEN"      -> T_KW_THEN 
    | _           -> raise IdentToken
  with
    | IdentToken -> T_IDENT

(*    let nameToUnionCtor (uci:UnionCaseInfo) = (uci.Name, FSharpValue.PreComputeUnionConstructor(uci))
    let ucis = FSharpType.GetUnionCases(typeof<token>) 
                    |> Array.map nameToUnionCtor                       
                    |> dict
    fun (name:string) startPos endPos ->
    let upperName = "KW_" + name.ToUpper()
    let (present, ctor) = ucis.TryGetValue(upperName) 
    if present then
        Some(ctor [| SourceText.ofTuple(name, (startPos, endPos)) |] :?>token)
    else
        None *)

let comment_depth = ref 0
let startPos = ref Position.Empty
let str_buf = new System.Text.StringBuilder()

let appendBuf (str:string) = str_buf.Append(str) |> ignore
let clearBuf () = str_buf.Clear() |> ignore
  
let makeIdent notKeyWord (name:string) =
  let prefix = 
    if String.length name >=2 
    then name.[0..1] 
    else ""
  if name.[0] = '@' then T_LOCALVAR
  else if notKeyWord then T_IDENT
  else getKwToken name 

type MyLexeme (tag,_value) =
    member self.MValue = _value
    interface ILexeme with    
       member self.tag = tag
       member self.CompareTo x =  compare (hash self) (hash x)
    end

}

let anything = ['a'-'z' 'A'-'Z' '0'-'9' '\n' '\r' ' ' ] + 
let lparen = '('
let rparen = ')'
let eol = '\r' | '\n' | '\r' '\n' (* See script.sql position (4560,27) *)
let string_const = ''' ['a'-'z' 'A'-'Z' '0'-'9' '-' '+' '*' '/' ' ' ]+ ''' (* TODO: support line like 'aaa''aa' *)
let whitespaces = [' '  '\t']+
let ident_start_char  = ['A'-'Z' 'a'-'z' '_' '@' '#' 'а'-'я' 'А'-'Я' ] 
let ident_body_char  = ['A'-'Z' 'a'-'z' '_' '0'-'9' '@' '#' '$' 'а'-'я' 'А'-'Я' ] 
// Разобраться с идентификаторами cyrillic с,а (885574,_) (1004524)
let with_dot = '.' | ident_body_char
let ident = ident_start_char with_dot*
let decnumber = ['0'-'9']+ 
let hexnumber = "0x" ['0'-'9' 'a'-'f' 'A'-'F']+
let float_e = 'e' | 'E'
let floatnumber = decnumber ('.' decnumber)? ( float_e decnumber) ? (* what with 100.   ?? *)
let label = ident ':'


rule tokens = parse
 | eol          { tokens lexbuf }
 | string_const { MyLexeme(getTag T_STRING_CONST, LexBuffer<_>.LexemeString(lexbuf) ) }
 | decnumber    { MyLexeme(getTag T_DEC_NUMBER,   LexBuffer<_>.LexemeString(lexbuf) ) }
 | whitespaces  { tokens lexbuf }
 | "="          { MyLexeme(getTag T_OP_EQ, "=") }
 | "("		{ MyLexeme(getTag T_LPAREN, "(") }
 | ")"		{ MyLexeme(getTag T_RPAREN, ")") }
 | "+"		{ MyLexeme(getTag T_OP_PLUS, "+") }
 | "-"		{ MyLexeme(getTag T_OP_MINUS, "-") }
 | "~"		{ MyLexeme(getTag T_OP_TILDA, "~") }
 | ">"		{ MyLexeme(getTag T_OP_MT, ">") }
 | "<"		{ MyLexeme(getTag T_OP_LT, "<") }
 | ">="		{ MyLexeme(getTag T_OP_MT_EQ, ">=") }
 | "<="		{ MyLexeme(getTag T_OP_LT_EQ, "<=") }

 | ident {  let l = LexBuffer<_>.LexemeString(lexbuf) in
            let hasdot = l.IndexOf '.' <> -1 in
            match makeIdent false l with
            | x -> MyLexeme(getTag x,l)
         }
 | eof  {MyLexeme(Constants.gnesccEndStreamTag, LexBuffer<_>.LexemeString(lexbuf))}
{

type Lexer(lb) = 
    let locBuf = ref []
    interface ILexer with        
    
       member self.Get pos = 
        let l = !locBuf |> List.length
        if l >= pos
        then (!locBuf).[l-pos]
        else
            let t = (tokens lb) :> ILexeme
            locBuf := t :: !locBuf
            t      
    end

}