//this file was generated by RACC
//source grammar:RaccParser.yrd
//date:4/1/2011 17:10:53

module RACC.Actions

open Yard.Generators.RACCGenerator

let getUnmatched x expectedType =
    "Unexpected type of node\nType " + x.ToString() + " is not expected in this position\n" + expectedType + " was expected." |> failwith


//let print l = (l:>MyLexeme).MValue |> sprintf "%A"
let value l = (l:>RaccLexer.MyLexeme).MValue
let f list =
  match list with
  | elem::t -> 
      List.fold
        (fun list list_elem -> (printfn "%A %A" list_elem list; list_elem::list) )
        (printfn "list_start from %A" elem; [elem] )
        t
  | [] -> failwith "Expected 1 or more elements"

let start0 expr = 
    let inner  = 
        match expr with
        | RESeq [x0] -> 
            let (list) =
                let yardElemAction expr = 
                    match expr with
                    | RELeaf list -> (list :?> _ ) 
                    | x -> getUnmatched x "RELeaf"

                yardElemAction(x0)
            ( list )
        | x -> getUnmatched x "RESeq"
    box (inner)
let list1 expr = 
    let inner  = 
        match expr with
        | RESeq [x0] -> 
            let (list) =
                let yardElemAction expr = 
                    match expr with
                    | REClosure(lst) -> 
                        let yardClsAction expr = 
                            match expr with
                            | RESeq [x0] -> 
                                let (elem) =
                                    let yardElemAction expr = 
                                        match expr with
                                        | RELeaf list_elem -> (list_elem :?> _ ) 
                                        | x -> getUnmatched x "RELeaf"

                                    yardElemAction(x0)
                                ( elem )
                            | x -> getUnmatched x "RESeq"

                        List.map yardClsAction lst 
                    | x -> getUnmatched x "REClosure"

                yardElemAction(x0)
            (f list)
        | x -> getUnmatched x "RESeq"
    box (inner)
let list_elem2 expr = 
    let inner  = 
        match expr with
        | RESeq [x0] -> 
            let (x) =
                let yardElemAction expr = 
                    match expr with
                    | RELeaf tINT -> tINT :?> 'a
                    | x -> getUnmatched x "RELeaf"

                yardElemAction(x0)
            ( printfn "int %A" (value x); value x )
        | x -> getUnmatched x "RESeq"
    box (inner)

let ruleToAction = dict [|(3,list_elem2); (2,list1); (1,start0)|]

