//this file was generated by GNESCC
//source grammar:grlang.yrd
//date:10/23/2011 7:38:05 PM

module GNESCC.Regexp

open Yard.Generators.GNESCCGenerator
open System.Text.RegularExpressions

let buildIndexMap kvLst =
    let ks = List.map (fun (x:string,y) -> x.Length + 2,y) kvLst
    List.fold (fun (bl,blst) (l,v) -> bl+l,((bl,v)::blst)) (0,[]) ks
    |> snd
    |> dict

let buildStr kvLst =
    let sep = ";;"
    List.map fst kvLst 
    |> String.concat sep
    |> fun s -> ";" + s + ";"

let grammar childsLst = 
    let str = buildStr childsLst
    let idxValMap = buildIndexMap childsLst
    let re = new Regex("((((;2;)(;6;)))+)")
    let elts =
        let res = re.Match(str)
        if Seq.fold (&&) true [for g in res.Groups -> g.Success]
        then res.Groups
        else res.Groups
        //else (new Regex("((((;2;)(;6;)))+)",RegexOptions.RightToLeft)).Match(str).Groups
    let e0 =
        let l = 0//(elts.[2].Index - 3)
        let ofset = ref 0
        let e i =
            let str = elts.[2].Captures.[i].Value
            let re = new Regex("((;2;)(;6;))")
            let elts =
                let res = re.Match(str)
                if Seq.fold (&&) true [for g in res.Groups -> g.Success]
                then res.Groups
                else res.Groups
        //else (new Regex("((;2;)(;6;))",RegexOptions.RightToLeft)).Match(str).Groups
            let res =
                let e1 =
                    idxValMap.[l + !ofset + elts.[3].Captures.[0].Index] |> RELeaf
                let e0 =
                    idxValMap.[l + !ofset + elts.[2].Captures.[0].Index] |> RELeaf
                RESeq [e0; e1]
            ofset := !ofset + str.Length
            res
        REClosure [for i in [0..elts.[2].Captures.Count-1] -> e i]

    RESeq [e0]
let rule childsLst = 
    let str = buildStr childsLst
    let idxValMap = buildIndexMap childsLst
    let re = new Regex("((;7;)(;8;)(((;7;))|((;9;)))*)")
    let elts =
        let res = re.Match(str)
        if Seq.fold (&&) true [for g in res.Groups -> g.Success]
        then res.Groups
        else res.Groups
        //else (new Regex("((;7;)(;8;)(((;7;))|((;9;)))*)",RegexOptions.RightToLeft)).Match(str).Groups
    let e2 =
        let ofset = ref 0
        let l = elts.[3].Captures.[0].Index + 3
        let e i =            
            let str = elts.[4].Captures.[i].Value
            let re = new Regex("((;7;))|((;9;))")
            let elts =
                let res = re.Match(str)
                if Seq.fold (&&) true [for g in res.Groups -> g.Success]
                then res.Groups
                else res.Groups
        //else (new Regex("((;7;))|((;9;))",RegexOptions.RightToLeft)).Match(str).Groups
            let res =
                if elts.[2].Value = ""
                then
                    let e2 =
                        let e0 =
                            idxValMap.[l + !ofset + elts.[4].Captures.[0].Index] |> RELeaf
                        RESeq [e0]
                    None, Some (e2)
                else
                    let e1 =
                        let e0 =
                            idxValMap.[l + !ofset + elts.[2].Captures.[0].Index] |> RELeaf
                        RESeq [e0]
                    Some (e1),None
                |> REAlt

            ofset := !ofset + str.Length
            res
        REClosure [for i in [0..elts.[4].Captures.Count-1] -> e i]

    let e1 =
        idxValMap.[elts.[3].Captures.[0].Index] |> RELeaf
    let e0 =
        idxValMap.[elts.[2].Captures.[0].Index] |> RELeaf
    RESeq [e0; e1; e2]

let ruleToRegex = dict [|(2,rule); (1,grammar)|]

