<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>Convertions</name></assembly>
<members>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Yard.Core.Convertions.AddDefaultAC.addAcToProduction(Microsoft.FSharp.Core.FSharpRef{Microsoft.FSharp.Collections.FSharpList{System.String}},Yard.Core.IL.Production.t{System.Tuple`2{System.String,System.Tuple`2{System.Int32,System.Int32}},System.Tuple`2{System.String,System.Tuple`2{System.Int32,System.Int32}}})">
<summary>
 Adds action code to production considering it is used somewhere
</summary>
</member>
<member name="T:Yard.Core.Convertions.AddDefaultAC">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Yard.Core.Convertions.AddEOF">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Yard.Core.Convertions.BuildAST">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Yard.Core.Convertions.BuildAstSimple._buildAstSimple(System.String,Yard.Core.IL.Production.t{System.Tuple`2{System.String,System.Tuple`2{System.Int32,System.Int32}},System.Tuple`2{System.String,System.Tuple`2{System.Int32,System.Int32}}})">
<summary>
 ruleName is empty when production is inner and action code returns list of nodes
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Yard.Core.Convertions.BuildAstSimple">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Yard.Core.Convertions.EliminateLeftRecursion">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Yard.Core.Convertions.ExpandAlter">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Yard.Core.Convertions.ExpandBrackets">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Yard.Core.Convertions.ExpandEbnfStrict">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Yard.Core.Convertions.ExpandMeta.expandMeta(Yard.Core.IL.Production.t{System.Tuple`2{System.String,System.Tuple`2{System.Int32,System.Int32}},System.Tuple`2{System.String,System.Tuple`2{System.Int32,System.Int32}}},System.Collections.Generic.Dictionary{System.String,Yard.Core.IL.Rule.t{System.Tuple`2{System.String,System.Tuple`2{System.Int32,System.Int32}},System.Tuple`2{System.String,System.Tuple`2{System.Int32,System.Int32}}}},System.Collections.Generic.Dictionary{System.String,Yard.Core.IL.Production.t{System.Tuple`2{System.String,System.Tuple`2{System.Int32,System.Int32}},System.Tuple`2{System.String,System.Tuple`2{System.Int32,System.Int32}}}},Microsoft.FSharp.Collections.FSharpList{Yard.Core.IL.Rule.t{System.Tuple`2{System.String,System.Tuple`2{System.Int32,System.Int32}},System.Tuple`2{System.String,System.Tuple`2{System.Int32,System.Int32}}}})">
 <summary>
 <para> Replace rule with new one, replacing references to metarules, </para>
 <para> and generate new rules for every such reference </para>
 <para> body: t - production which can contain metareferences </para>
 <para> metaRules: Dictionary&lt;string,Rule.t&lt;Source.t,Source.t&gt;&gt; - table, which contains expanding metareferences rules </para>
 <para> expanded: Dictionary&lt;string,Production.t&gt; - map of metareference with actual params to generated rule name </para>
 <para> res: Rule.t list - currently generated rules </para>
 <para> returns (new body, generated rules + old rules) </para>
 </summary>
</member>
<member name="M:Yard.Core.Convertions.ExpandMeta.getRuleBindings(Yard.Core.IL.Rule.t{System.Tuple`2{System.String,System.Tuple`2{System.Int32,System.Int32}},System.Tuple`2{System.String,System.Tuple`2{System.Int32,System.Int32}}},Microsoft.FSharp.Collections.FSharpList{System.Tuple`2{System.Tuple`2{System.String,System.Tuple`2{System.Int32,System.Int32}},System.Tuple`2{System.String,System.Tuple`2{System.Int32,System.Int32}}}})">
<summary>
 Bind all heritable attributes of rule
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Yard.Core.Convertions.ExpandMeta.addBindingPair``1(Microsoft.FSharp.Collections.FSharpList{System.Tuple`2{System.Tuple`2{System.String,System.Tuple`2{System.Int32,System.Int32}},``0}},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Create pair (formal argument name, actual argument name)
</summary>
</member>
<member name="M:Yard.Core.Convertions.ExpandMeta.findMetaRule(System.Collections.Generic.Dictionary{System.String,Yard.Core.IL.Rule.t{System.Tuple`2{System.String,System.Tuple`2{System.Int32,System.Int32}},System.Tuple`2{System.String,System.Tuple`2{System.Int32,System.Int32}}}},System.String)">
<summary>
 find metarule with given name in hash map of collected metarules
</summary>
</member>
<member name="T:Yard.Core.Convertions.ExpandMeta">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Yard.Core.Convertions.LeaveLast">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Yard.Core.Convertions.MergeAlter">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Yard.Core.Convertions.ReplaceLiterals">

</member>
<member name="">

</member>
<member name="M:Yard.Core.Convertions.TransformAux.list2opt``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Create option from empty or one element list
</summary>
</member>
<member name="M:Yard.Core.Convertions.TransformAux.createParams(Microsoft.FSharp.Collections.FSharpList{System.Tuple`2{System.String,System.Tuple`2{System.Int32,System.Int32}}})">
<summary>
 Reduce param list to string. Arguments are separated by spaces
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Yard.Core.Convertions.TransformAux.getNewSource``4(``0,System.Tuple`2{``1,``2},``3)">
<summary>
 Replace first (name) field in Source.t with new source 
</summary>
</member>
<member name="M:Yard.Core.Convertions.TransformAux.createSimpleRule``2(System.String,Microsoft.FSharp.Collections.FSharpList{``0},Yard.Core.IL.Production.t{``0,``1})">
<summary>
 Non-start rule with empty meta-arguments list
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Yard.Core.Convertions.TransformAux">

</member>
<member name="P:Yard.Core.Namer.getEofTokenName">
<summary>
 returns token name for EOF (End Of File)
</summary>
</member>
<member name="P:Yard.Core.Namer.createLiteralToken">
<summary>
 returns token type for literal
</summary>
</member>
<member name="M:Yard.Core.Namer.createTknFileName(System.String)">
<summary>
 returns file name for tokens
</summary>
</member>
<member name="P:Yard.Core.Namer.createTypeName">
<summary>
 type of semantic value
</summary>
</member>
<member name="P:Yard.Core.Namer.withTokenPrefix">
<summary>
 token type (need for using bindings with tokens)
</summary>
</member>
<member name="M:Yard.Core.Namer.withElkPrefix(System.String)">
<summary>
 prefix for Elkhound bindings
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Yard.Core.Namer.isItem(System.String)">
<summary>
 Does name have prefix &apos;item&apos;
</summary>
</member>
<member name="">

</member>
<member name="P:Yard.Core.Namer.getItem">
<summary>
 formal parameter name in metarules for EBNF clauses
</summary>
</member>
<member name="">

</member>
<member name="M:Yard.Core.Namer.createNewName``2(System.String,System.Tuple`2{``0,``1})">
<summary>
 Create new Source.t item with name, consisting of yard prefix, specified middle
    and postfix, generated as regularly incrementing number
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Yard.Core.Namer.Names">

</member>
<member name="T:Yard.Core.Namer">

</member>
</members>
</doc>
