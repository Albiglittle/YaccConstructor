%description: Курсовая по программированию. GLR-анализатор.

\documentclass[a4paper,12pt]{article}

\usepackage[cp1251]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{graphicx}

\pagestyle{headings}

\textwidth=190mm
\textheight=250mm
\topmargin=-20mm
\oddsidemargin=-15mm
\evensidemargin=-15mm
\sloppy
\title{Разработка GLR-анализатора для среды .NET}

\author{Григорьев Семён}


% Document
\begin{document}
%\oddsidemargin{1}
%\textwidth{50}
% create title page and toc
\maketitle\thispagestyle{empty}\clearpage
\tableofcontents\clearpage

\section{Введение.}

\hspace{1,5cm}Задачи автоматизированного \hspace{0,1cm} реинжиниринга \hspace{0,1cm} программ \hspace{0,1cm} выдвигают особые \hspace{0,1cm}требования к генераторам синтаксических анализаторов.

\hspace{0,9cm}Для устаревшего языка сложно (а зачастую и невозможно) задать однозначную контекстно-свободную грамматику. Необходимо существенно преобразовать его спецификацию, которая приводится в документации, чтобы получить такую грамматику, но при этом она перестает быть сопровождаемой \cite{CurrentParsTechn}. Поэтому устаревший язык обычно задается с помощью неоднозначной контекстно-свободной грамматики.

\hspace{0,9cm}При поддержке нескольких диалектов языка необходима возможность лёгкой трансформации грамматики. Однако,зачастую, изменение одного правила приводит к появлению десятков конфликтов в грамматике \cite{CurrentParsTechn}, которые необходимо разрешать вручную.
Это требует большого количества времени. 

\hspace{0,9cm}Как вариант решения этих задач в статье \cite{CurrentParsTechn} предлагается использовать GLR грамматики и соответствующие инструменты построения анализаторов. Действительно, GLR-алгоритм разрешает неоднозначности в грамматике на уровне концепции. По этому  задание спецификации трансляции становится проще, требует меньше времени. Получившийся код компактнее и сопровождаемее. 
      
\hspace{0,9cm}Главным достоинством GLR-алгоритма является обработка неоднозначных грамматик. \linebreak Анализатор, построенный с помощью данного алгоритма, в результате разбора строит не единственное дерево, а несколько деревьев — лес, который можно сократить, используя специальные фильтры, а можно ,при задании в одной спецификации нескольких диалектов, вернуть весь лес для дальнейшего выбора нужного дерева/диалекта.   

\hspace{0,9cm}Стоит отметить, что по производительности такой анализатор, являясь некоторой “надстройкой” над LR-анализатором, незначительно ему уступает. На сегодняшний день в соотношении производитель-ность/класс разбираемых языков GLR-алгоритм выглядит наиболее предпочтительно.
\section{Цель.}
\hspace{1,5cm}Целью работы является разработка GLR-анализатора для среды .NET. Такое решение принято потому, что :
\begin{itemize}
\item 
На данный момент нет реализации подобного инструмента на этой платформе.
\item
В рамках .NET есть возможность легко комбинировать функциональный и объектно ориентированный подходы. Это может быть полезным при разработке.
\end{itemize}

\section{Ожидаемые результаты.}
\hspace{1,5cm}Результатом работы будет являться представление спецификации трансляции на основе атрибутной GLR-грамматики в среде .NET и алгоритм построения GLR-анализаторов на основе подобного представления.
\section{Реализация.}
\hspace{1,5cm}Платформой для создания инструмента выбран .NET . Основным языком реализации является F\# \cite{FS}. Так же предлагается использовать C\#. 
\subsection{Внутреннее представление.}
\hspace{1,5cm}За основу внутреннего представления грамматики взято представление инструмента YARD. Это представление и ,соответственно, входной язык инструмента, содержит такие конструкции, как
\begin{itemize}
\item
Конструкции расширенной формы Бэкуса-Наура;
\item
Макроправила (параметризация одних правил другими);
\item
Сгруппированные альтернативы;
\item
Предикаты;
\end{itemize}
\hspace{1,5cm}Планируется расширить представление конструкциями для расширенных регулярных выражений и перестановок.
  
\hspace{0,9cm}Так как для реализации GLR-алгоритма требуется построение LR(k)  таблицы и предварительный анализ и преобразоване грамматики \cite{Practical Guide},например удаление циклов (преобразование правил вида $A\stackrel{}{\rightarrow}B$ ; $B\stackrel{}{\rightarrow}A$), то необходимо преобразовать входную грамматику. Для преобразований воспользуемся алгоритмами предложенными в работе \cite{Diploma}. Но кроме этого ,возможно ,придётся проводить дальнейшие преобразования. В частности скорее всего потребуется явное раскрытие сгруппированных альтернатив. 
\begin{verbatim}  
nonterm yard_alt_1 {
-> a ;
-> b ;
} 
в
yard_alt_1 -> a;
yard_alt_1 -> b; 
\end{verbatim}
\section{Обзор.}
\hspace{1,5cm}Стоит задача разработки анализатора для произвольной контекстно свободных грамматик на платформе .NET и реализации его на функциональном языке программирования F\#. Необходимость такой разработки была обоснована выше. 
         
\hspace{0,9cm}Автоматизированный реинжиниринг программ выдвигает особые требования к инструменту анализа и языку спецификаций трансляции \cite{Diploma}. Используемые в разрабатываемом инструменте грамматики YARD удовлетворяют основным таким требованиям.  Поэтому наибольший интерес сейчас представляет анализ внутренних алгоритмов анализа в существующих инструментах. 
          
\hspace{0,9cm}Предпочтительным алгоритмам анализа является алгоритм разбора произвольной контекстно свободной грамматики. Поэтому нужно рассмотреть инструменты, основанные на этом алгоритме. Важен способ реализации алгоритма, так как существуют несколько альтернатив: алгоритм Томиты (GLR-алгоритм), алгоритм Эрли (Early), рекурсивно-восходящий алгоритм. Так-же следует обратить преобразования грамматики, необходимые для  построения анализатора. 
          
\hspace{0,9cm}Так как язык программирования F\# является функциональным, то особый интерес представляет рекурсивно-восходящий алгоритм, так как GLR-алгоритм и алгоритм Эрли суть императивно. В связи с этим интерес представляет инструмент Jade – генератор рекурсивно восходящих парсеров. 
       
\hspace{0,9cm}В настоящее время нет GLR анализаторов на платформе .NET. Но существуют другие инструменты основанные на GLR-алгоритме.
\begin{itemize}
\item
 ASF+SDF \cite{ASF+SDF} (Algebraic Specification Formalism + Syntax Definition Formalism)
— генератор с широкими возможностями, но достаточно сложным входным
языком. Является SGLR-инструментом (Scannerless, Generalized-LR).
\item
 Bison \cite{Bison} — развитие инструмента YACC. Все грамматики, созданные
для оригинального YACC, будут работать и в Bison. Является одним
из самых популярных и совершенных “потомков” YACC. При включении
соответствующей опции использует GLR-алгоритм (по умолчанию LALR).
\item
 Elkhound \cite{Elkhound} — позиционируется как быстрый и удобный GLR-инструмент,
созданный в университете Беркли (США), тем не менее обладает достаточно
“бедным” входным языком (например, он не поддерживает конструкций
расширенной формы Бэкуса-Наура).
\end{itemize}

\hspace{1,5cm}В работе \cite{Diploma} проведён подробный анализ этих инструментов. Подводя итог, можно сказать, что на текущий момент нет инструмента, полностью удовлетворяющего требованиям автоматизированного реинжиниринга программ.

\hspace{0,9cm}Так же нас будут интересовать такой инструменты как Jade, так как он является генератором рекурсивно-восходящих парсеров.
       
\hspace{0,9cm}Jade это генератор рекурсивно-восходящих LALR(1) парсеров с целевым языком С. Его подробное описание приводится в статье \cite{Jade}. При его реализации появилась проблема объёма кода целевого парсера. Так как при построении детерминированного парсера необходимо генерировать процедуры для каждого состояния, то объём объём коба быстро растёт, с ростом количества правил в грамматике. Так для языка Java, по расчётам, приведённым в статье\cite{Jade}, объём кода составляет примерно 4 мегабайта. В Jade  эта проблема решается путём создания глобальной структуры(массива состояний), где хранится информация, позволяющая переиспользовать процедуры. (Подробнее об этом можно прочесть в статье \cite{Jade}). 

\subsection{Рекурсивно восходящий алгоритм.}
\hspace{1,5cm}Существует альтернатива табличным анализаторам – рекурсивно-восходящие   анализаторы. Идея состоит в том, чтобы не использовать стек явно, а заменить его стеком вызова рекурсивных функций и эмулировать поведения автомата вызовом функций. Для этого можно построить функцию соответствующую каждому состоянию, как это делается в статье \cite{RECURSIVE-ASCENT PARSING}. В этом случае можно получить детерминированный LR анализ. 

\hspace{0,9cm}Таким образом – рекурсивно восходящий алгоритм это аналог рекурсивного спуска, но для LR грамматики.  Однако, как показано в статье \cite{Jade}, при такой реализации возникают проблемы с быстрым ростом объёма кода целевых функций. 

\hspace{0,9cm}В статье \cite{RecursiveAscentParsing} показан подход к решению этой задачи несколько с другой стороны. Показано, что кожно построить функции, оперирующие уже не одним состоянием, а множеством состояний, и свести ,таким образом, количество необходимых функций к двум взаимно рекурсивным:  
\begin{itemize}
	\item parse  q i =$\{(A\stackrel{}{\rightarrow}a. , i) | A\stackrel{}{\rightarrow} a. \in q\}\bigcup$
  
  \hspace{1,9cm}       $\{(A\stackrel{}{\rightarrow}a.b , k) | i = xj ,(A\stackrel{}{\rightarrow}a.b, k) \in climb$ q x j$  \}
  \bigcup$
  
  \hspace{1,9cm}       $\{(A\stackrel{}{\rightarrow}a.b , k) | B\stackrel{}{\rightarrow}e , (A\stackrel{}{\rightarrow}a.b, k) \in climb$ q B j $\}$
  \item climb q X  i = $\{(A\stackrel{}{\rightarrow}a.Xb , k) | (A\stackrel{}{\rightarrow}aX.b, k)\in parse($goto q X$) i , a\neq e, A\stackrel{}{\rightarrow}a.Xb \in q\}\bigcup$
  
  \hspace{2,5cm}          $\{(A\stackrel{}{\rightarrow}a.b , l) | (C\stackrel{}{\rightarrow}X.c,j)\in parse($goto q X$) i, (A\stackrel{}{\rightarrow}a.b ,l)\in climb$ q C j$\} $
\end{itemize}
 
 Определим также функцию:
\begin{itemize}
       \item goto  q X = $\{A\stackrel{}{\rightarrow}aX.b | A\rightarrow a.Xb \in $q*$\}, $
       
       где 
       \item q* = q$ \bigcup \{B\rightarrow.c | A \rightarrow a.Bb \in $q*$\} \bigcup \{x\stackrel{}{\rightarrow}.x | A\stackrel{}{\rightarrow} a.xb \in $q*$\}$
\end{itemize}
\hspace{1,5cm}Пользуясь таким определением можно построить функции из статьи\cite{RECURSIVE-ASCENT PARSING}, однако сейчас интереснее их реализация, согласно определению.

\hspace{0,9cm}Важно, что при решении нашей задачи нет необходимости генерации функции для каждого состояния. Так как цель – получение недетерминированного разбора, то можно реализовать всего две функции: parse и climb, определённые выше. Это позволит решить проблему объёма кода, возникшую в Jade. Объём кода резко сократится и, более того, будет получен недетерминированный вариант разбора.  

\hspace{0,9cm}Используя рекурсивно-восходящий алгоритм можно получить эквивалент  алгоритму Томиты. При  использовать описанных ваше функции ,автоматически получается ветвление в момент возникновения неоднозначности (разделение стека в алгоритме Томиты). Это получается благодаря тому, что они принимают на вход состояние и возвращают множество всех возможных состояний. 

\hspace{0,9cm}Однако возникает проблема – сложность алгоритма, основанного на функциях parse и climb экспоненциальная. Для борьбы с этим в статье \cite{Non-det-rec-asc} предлагается дополнить функции  механизмом запоминания результатов предыдущих вызовов, чтобы при очередном вызове , в случае, если эта функция уже вызывалась с такими параметрами, то результат возвращался без повторного вычисления. Доказывается \cite{Non-det-rec-asc}, что в при такой реализации оценки по времени будут порядка О($n^{3}$).

\hspace{0,9cm}Запоминание результатов предыдущих вычислений и будет аналогом объединения состояний и получения структурированного в виде графа стека (graph-structured stack) в алгоритме Томиты.

\hspace{0,9cm}Технически этого можно добиться реализовав функцию memoize. На языке F\# её можно   реализовать так:
\begin{verbatim}
      let memoize (f: 'a ->'b) =
           let t = new System.Collections.Generic.Dictionary<'a,'b>() 
           in
           fun a ->    
                  if t.ContainsKey(a)
                  then t.[a]
                  else 
                     let res = f a 
                     in
                    t.Add(a,res);
                    res 
\end{verbatim}
В дальнейшем в качестве функции f будет выступать функция parse и climb.     

\hspace{0,9cm}Дополнительного ускорения можно добиться заранее вычислив функцию goto. Действительно, построение замыкания (closure), необходимое для вычисления функции goto дорогая операция, а вызов goto происходит при каждом вызове функции climb. Поэтому можно вычислить goto на этапе построения анализатора, и в целевой программе (в функции climb) свести вызов (goto q X) к поиску по ключу.

\subsection{Расширенные контекстно свободные грамматики.}

\hspace{1,5cm}На практике удобно пользоваться расширенной контекстно свободной грамматикой.
То-есть такой грамматикой, у которой в правых частях правил могут использоваться конструкции регулярных выражений. Необходимость использования EBNF обоснована в работе \cite{Diploma}.

\hspace{0,9cm}Для того, чтобы построить табличный LR анализатор необходимо преобразовать расширенную  контекстно свободную грамматику. Нужно избавиться от конструкции BNF в правых частях.  Однако можно попробовать обойтись без преобразований грамматики.

\hspace{0,9cm}Существуют способы поддержки расширенной контекстно свободной грамматики на уровне анализатора, без преобразований входной грамматики \cite{Non-det-rec-asc}. Для этого нужно переопределить функцию goto. Можно заменить позицию точки в правиле на номер состояния конечного автомата, построенного по соответствующему регулярному выражению. Заметим, что определённая выше функция goto может быть описана в терминах конечного автомата. В этом случае регулярное выражение и ,следовательно ,  построенный по нему автомат очень прост.  
      
 
\begin{thebibliography}{50}
\bibitem {CurrentParsTechn} \emph{Mark G.J. van den Brand, Alex Sellink, Chris Verhoef} 
        Current Parsing Techniques in Software Renovation Considered Harmful.// IWPC ’98: Proceedings of the 6th International Workshop on Program Comprehension. — IEEE Computer Society, Washington,1998.
        
\bibitem {FS} \emph http://www.research.microsoft.com/fsharp (дистрибутивы и документация по языку F\#)

\bibitem {Diploma} \emph{Чемоданов И.С.} Генератор синтаксических анализаторов  для решения задач автоматизированного реинжиниринга программ.

\bibitem {Practical Guide} \emph{Dick Grune, Ceriel Jacobs} PARSING TECHNIQUES A Practical Guide

\bibitem {DrgBook} \emph {Ахо А., Сети Р., Ульман Дж.} Компиляторы: принципы, технологии, инструменты.  М:. Издательский дом «Вильямс»2003. 768 с.

\bibitem {Jade} \emph {Ronald Veldena} Jade, a recursive ascent LALR(1) parser generator. September 8,1998

\bibitem {Non-det-rec-asc} \emph {Rene Leermakers} Non-deterministic Recursive Ascent Parsing. Philips Research Laboratories,
      P.O. Box 80.000, 5600 JA Eindhoven, The Netherlands. 

\bibitem {RECURSIVE-ASCENT PARSING} \emph {Larry Morell, David Middleton} RECURSIVE-ASCENT PARSING. Arkansas Tech    
       University Russellville, Arkansas. 

\bibitem {RecursiveAscentParsing} \emph {Lex Augusteijn} Recursive Ascent Parsing (Re: Parsing techniques). lex@prl.philips.nl (Lex Augusteijn)
      Mon, 10 May 1993 07:03:39 GMT 

\bibitem {ASF+SDF} \emph {} http://www.cwi.nl/projects/MetaEnv (сайт разработчиков ASF+SDF)

\bibitem {Bison} \emph {} http://www.gnu.org/software/bison (сайт разработчиков Bison)

\bibitem {Elkhound} \emph {} http://www.cs.berkeley.edu/smcpeak/elkhound (сайт разработчиков Elkhound )
\end{thebibliography}
\end{document}

