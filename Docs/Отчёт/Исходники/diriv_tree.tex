\subsection{Построение деревьев вывода.}

Для практических целей одна только информация о том, принадлежит входная цепочка данному языку или нет, не очень полезна. Гораздо более ценный результат - дерево вывода цепочки в данной грамматике. Так как обсуждается недетерминированый алгоритм, то в нашем случае речь будет идти о множестве деревьев (лесе) вывода. Для краткости будем называть его лесом вывода.

Рекурсивно-восходящий алгоритм анализа, описанный выше, будет основой следующего шага. Теперь необходимо получить деревья вывода.

Строить дерево вывода можно в два этапа. Сперва, в результате, анализа цепочки, получить проядок применения правил, а затем построить по нему дерево вывода. Мы же будем строить дерево сразу во время анализа. Для этого потребуется изменить функции \verb parse и \verb climb, описанные ранее.

Вначале рассмотрим детерминированный случай, а затем перейдём к недетерменированному.

При детерминированном разборе, если цепочка пораждается входной грамматикой, должно быть получено единственное дерево вывода.


%%Написать правильные сигнатуры.
$parse q (u: A->a.b, u=vx, b=>v)$$\rightarrow$$(A->a.b) (x) (узлы СД для b)$

$climb (q) (X) (u: A->aX.b, u=vx, b=>v) (узел СД для X)$$\rightarrow$$(A->a.Xb) (x) (узлы СД для Xb)$

На данном этапе структуру дерева можно сделать минимално простой. В вершине можно хранить только имя сооветствущего нетерминала или теоминала и информацию о сыновьях. Для представления дерева опишим соответствующий алгебраический тип: tree = Node of string*tree*tree|Leaf of string.
 
Теперь надо изменить эти функции так, чтобы они строили дерево вывода. Для этого добавим дополнительный параметр....

%%описать переход. и что и как делаем.
$parse q (u: A->a.b, u=vx, b=>v)$\rightarrow$(A->a.b) (x) (узлы СД для b)$

$climb (q) (X) (u: A->aX.b, u=vx, b=>v) (узел СД для X)$\rightarrow$(A->a.Xb) (x) (узлы СД для Xb)$


%инфа из письма
A->R -- правило грамматики: A - нетерминал, R - ДКА, построенный по регулярному выражнению
(A->R,i) -- LR-ситуация, i - состояние ДКА
is-final(R,i) -- проверка, что i - конечное состояние R
%q - LR-состояние (core)
%q* - замыкание q
 
%(leaf:a), (A->...) -- конструкции дерева разбора
 
 
%сигнатура функций:
 
%parse (q) (u: A->a.b, u=vx, b=>v) -> (A->a.b) (x) (узлы СД для b)
%climb (q) (X) (u: A->aX.b, u=vx, b=>v) (узел СД для X) -> (A->a.Xb) (x) (узлы СД для Xb)
 
 
%сами фукнции:
 
%parse q u =
 % if (A->R,i) in q & is-final(R,i) then (A->R,i;u;[])
 % elsif u=av & (A->R,i) in q* & R(i,a)=j then climb q a v (leaf:a)
 % elsif (A->R,0) in q* & is-final(R,0) then climb q A v (A->[])
 
%climb q X u h =
 % let (A->R,j;w;s) = parse (goto q* X) u in
  %if R(i,X)=j & (A->R,i) in q then (A->R,i;w;h::s)
  %else climb q A w (A->h::s)
 %конец
 
Дополним эту грамматику и пронумеруем правила. Введём стартовый нетерминал S и соответственно правило $S \rightarrow E$ и получим следующую грамматику:

\hspace{0,9cm} 1) $S \rightarrow E$
 
\hspace{0,9cm} 2) $E \rightarrow E + E$

\hspace{0,9cm} 3) $E \rightarrow E * E$

\hspace{0,9cm} 4) $E \rightarrow (E)$ 

\hspace{0,9cm} 5) $E \rightarrow a$

Данная грамматика порождает арифметические выражения с двумя бинарными операциями и скобками.

Очевидно, что такая грамматика неоднозначна. Существуют цепочки, которые выводимы несколькими способами. Например: возьмём цепочку a+a+a. Она имеет два левосторонних вывода: 

$S\stackrel{1}{\rightarrow}E\stackrel{2}{\rightarrow}E+E \stackrel{5}{\rightarrow}a+E\stackrel{2}{\rightarrow}a+E+E\stackrel{5}{\rightarrow}a+a+E\stackrel{5}{\rightarrow}a+a+a$

и

$S\stackrel{1}{\rightarrow}E\stackrel{2}{\rightarrow}E+E \stackrel{2}{\rightarrow}E+E+E\stackrel{5}{\rightarrow}a+E+E\stackrel{5}{\rightarrow}a+a+E\stackrel{5}{\rightarrow}a+a+a$

Над стрелкой - номер применяемого на данном шаге вывода правила.

Видим, что существует два вывода цепочки в данной граматике:

 $(1)\rightarrow(2)\rightarrow(5)\rightarrow(2)\rightarrow(5)\rightarrow(5)$
 
 $(1)\rightarrow(2)\rightarrow(2)\rightarrow(5)\rightarrow(5)\rightarrow(5)$ 
 
 Им соотвтствуют деревия вывода:
 
\begin{figure}[h]
	\centering
		\includegraphics[width=10cm,height=10cm]{Pictures/div_tree1.jpeg}
	\label{fig:div_tree1}
\end{figure}

 Соответ
 
Так как инструмент предназначен для работы с неоднозначными грамматиками, то в общем случае он должен строить лес вывода. То есть в случае если грамматика неоднозначна и существует несколько способов вывода некоторой входной цепочки, то должны быть построены все возможные деревья вывода.


