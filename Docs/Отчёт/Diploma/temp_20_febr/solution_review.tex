\section{Описание решения}

Необходимость поддержки неоднозначных грамматик предопределила выбор GLR-алгоритма в качестве анализатора. Для реализации выбран рекурсивно-восходящий алгоритм, модернизированный для работы с расширенными контекстно-свободными грамматиками без их преобразования.

В качестве фронтенда, обладающего мощным и удобным языком спецификации трансляции был выбран YARD.%Вопрос к Якову Александровичу - как правильно писать? будет ли ребрендинг?

Для вычисления атрибутов выбран второй подход - интерпретация дерева вывода. Основная идея заключается в том, что генератор строит набор функций - каждая функция соответствует одному правилу грамматики. После построения дерева вывода, оно обходится снизу вверх и в каждом узле вычисляется соответствующая ему функция. Параметры функции - сыновья данного узла. Функции вызываются по рефлексии, что показывает возможность в будущем сделать инструмент более гибким благодаря возможности динамической компиляции пользовательского action-кода. 
 
Так как инструмент должен работать с EBNF грамматиками без их преобразования, то при вычислении над деревом вывода возникли сложности, связанные с тем, что для конкретного узла сыновья одного уровня образуют строку языка, заданного регулярным выражением в правой части правила, соответствующего этому узлу. Для вычислений нужна более подробная информация о выводе данной строки. Для решения этой проблемы возможны несколько вариантов: 
\begin{itemize}
     \item С преобразованием входной грамматики. Добавление правил в грамматику, соответствующих атрибутам в исходной грамматике.
     \item Без преобразования входной грамматики. Добавление меток к узлам дерева вывода, с помощью которых можно восстановить дерево вывода этой строки.
\end{itemize}     

Был выбран второй вариант, так как одним из требований к инструменту было минимальное преобразование входной грамматики.

Инструмент реализуется на платформе .NET~\cite{.NET}, на функциональном языке F\#~\cite{FS}.