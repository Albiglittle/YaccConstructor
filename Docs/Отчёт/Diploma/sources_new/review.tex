%\section{Цели и задачи}
%Или лучше локальные цели???


%Стоит задача разработки анализатора для произвольной контекстно-свободных грамматик на платформе .NET и реализации его на %функциональном языке программирования F\#. Необходимость такой разработки была обоснована выше. 

%В рамках данной работы ставится цель разработки прототипа генератора анализаторов, удовлетворяющего основным перечисленным требованиям и предоставляющего, в то же время, ставшие привычными средства автоматизации трансляции (дополнение грамматики атрибутами, средства автоматического восстановления после ошибок, средства диагностики).
        
%Необходимость поддержки неоднозначных грамматик (на практике, как правило,грамматики лишь «слегка» неоднозначные) предопределила %выбор алгоритма GLR в качестве анализатора. В рассматриваемом проекте данный алгоритм реализован на функциональном языке F\# в %среде .NET, при этом склеивание реализовано с помощью конструкции замыкания.
          
\section{Обзор}

Предпочтительным алгоритмом анализа является алгоритм для работы с произвольными контекстно-свободными грамматиками. Поэтому были рассмотрены инструменты, обладающие соответствующими возможностями. Важным моментом является внутренняя реализация, так как существуют несколько альтернативных подходов к работе с произвольными контекстно-свободными грамматиками: алгоритм Томиты (GLR-алгоритм), алгоритм Эрли (Early), рекурсивно-восходящий алгоритм. 
       
В настоящее время существуют следующие инструменты основанные на GLR-алгоритме.
\begin{itemize}
\item
 ASF+SDF~\cite{ASF+SDF} (Algebraic Specification Formalism + Syntax Definition Formalism)
- генератор с широкими возможностями, но достаточно сложным входным
языком. Является SGLR-инструментом (Scannerless, Generalized-LR).
\item
 Bison~\cite{Bison} - развитие инструмента YACC. Все грамматики, созданные
для оригинального YACC, будут работать и в Bison. Является одним
из самых популярных и совершенных "потомков" \ YACC. При включении
соответствующей опции использует GLR-алгоритм (по умолчанию LALR).
\item
 Elkhound~\cite{Elkhound} - позиционируется как быстрый и удобный GLR-инструмент,
созданный в университете Беркли (США), тем не менее обладает достаточно
"бедным" \ входным языком (например, он не поддерживает конструкций
расширенной формы Бэкуса-Наура).
\end{itemize}

В работе~\cite{CCReview} проведён подробный анализ этих инструментов.

Необходимо отметить, что все рассмотренные инструменты либо обладают сравнительно бедным входным языком, что усложняет разработку, либо проводят сильные преобразования грамматики во время работы, что может серьёзно усложнить отладку.

Так же был рассмотрен инструмент Jade.
Jade это генератор рекурсивно-восходящих LALR(1) парсеров с целевым языком С. Его подробное описание приводится в статье~\cite{Jade}. При реализации данного инструмента появилась проблема объёма кода целевого парсера. Так как при построении детерминированного парсера необходимо генерировать процедуры для каждого состояния, то объём кода быстро растёт, с ростом количества правил в грамматике. Так для языка Java объём кода составляет примерно 4 мегабайта~\cite{Jade}. В Jade  эта проблема решается путём создания глобальной структуры(массива состояний), где хранится информация, позволяющая переиспользовать процедуры~\cite{Jade}.

\subsection{Вычисление атрибутов}

При работе с произвольными грамматиками выдвигаются дополнительные требования к алгоритму вычисления атрибутов. В качестве атрибута пользователь может указать действие, обладающее побочным эффектом. Так как в момент разбора мы не можем сказать, завершиться ли текущая ветвь удачно, то нельзя вычислять атрибуты непосредственно по ходу разбора входной строки, так как в этом случае могут быть совершены лишние действия.

Были рассмотрены два подхода к решению этой проблемы: 
\begin{itemize}
	\item Отложенные вычисления (continuation passing style, CPS). Непосредственно во время разбора атрибуты не вычисляются. Вычисления откладываются. Строится функция, которая вычисляется только один раз, после удачного завершения разбора.
	
	\item Построение леса вывода и последующее вычисление атрибутов над ним. Первым шагом строится лес вывода. В него попадают только деревья, соответствующие успешным вариантам разбора. Следующим шагом над полученным лесом производятся вычисления, соответствующие заданным атрибутам. Назовём это действие интерпретацией дерева вывода.
\end{itemize}

Оба этих подхода гарантируют, что будут выполнены действия, соответствующие только успешным вариантам разбора.

Второй подход является более удобным для конечного пользователя, так как позволяет явно получить дерево вывода, что упрощает отладку.

Вторым важным требованием к алгоритму вычисления атрибутов является минимизация, а в идеале - отсутствие, преобразований входной грамматики/дерева вывода.

Так как инструмент должен работать с EBNF грамматиками без их преобразования, то при вычислении над деревом вывода возникли сложности, связанные с тем, что для конкретного узла сыновья одного уровня образуют строку языка, заданного регулярным выражением в правой части правила, соответствующего этому узлу. Для вычислений нужна более подробная информация о выводе данной строки. Для решения этой проблемы возможны несколько вариантов: 
\begin{itemize}
     \item С преобразованием входной грамматики. Добавление правил в грамматику, соответствующих атрибутам в исходной грамматике.
     \item Без преобразования входной грамматики. Добавление меток к узлам дерева вывода, с помощью которых можно восстановить дерево вывода этой строки.
\end{itemize}

\includepdf{sampleforlabelgeneral.pdf}

Был выбран второй вариант, так как одним из требований к инструменту было минимальное преобразование входной грамматики.

Результат обзора - в качестве алгоритма анализа выбран рекурсивно-восходящий алгоритм, для вычисления атрибутов выбран второй подход(интерпретация дерева вывода).