\section{Реализация}
 
\input{solution_review.tex}


\subsection{Алгоритм анализа. Основные функции}

На практике оказывается удобно пользоваться расширенной контекстно-свободной или EBNF-грамматикой. То-есть такой грамматикой, у которой в правых частях правил могут использоваться конструкции регулярных выражений. Необходимость использования EBNF в инструментах генерации анализаторов обоснована в работе~\cite{Diploma}. Поэтому анализатор должен работать с EBNF-грамматиками, обеспечивая их непосредственную поддержку.

Кроме того, для практических целей одна только информация о том, принадлежит входная цепочка данному языку или нет, не очень полезна. Гораздо более ценный результат - дерево вывода цепочки в данной грамматике. Так как обсуждается недетерминированный алгоритм, то в нашем случае речь будет идти о необходимости получить множество деревьев -- лес вывода.

Таким образом, необходимо предложить алгоритм анализа, способный работать с неоднозначными EBNF-грамматиками и строящий лес вывода входной цепочки.

В качестве основы алгоритма анализа выбран рекурсивно-восходящий алгоритм. Он основан на наборе взаимно-рекурсивных функций, которые эмулируют переходы автомата. При этом стек автомата естественным образом заменяется на стек вызова функций  а ветвление при возникновении неоднозначности -- ветвление в одной из функций. Механизм для переиспользования результатов вычисления, слияние, просто реализовать с помощью замыкания. Таким образом, рекурсивно восходящий алгоритм это аналог рекурсивного спуска, но для LR грамматики.

Чтобы избежать проблем с объёмом кода, можно применить алгоритм, основанный всего на двух взаимно-рекурсивных функциях $parse$ и $climb$,  но оперирующих уже не одним состоянием, а множеством состояний~\cite{RecursiveAscentParsing}. Основные функции этого алгоритма определяются следующим образом:
\begin{itemize}
	\item parse  q i =$\{(A\stackrel{}{\rightarrow}a. , i) | A\stackrel{}{\rightarrow} a. \in q\}\bigcup$
  
  \hspace{1,9cm}       $\{(A\stackrel{}{\rightarrow}a.b , k) | i = xj ,(A\stackrel{}{\rightarrow}a.b, k) \in climb$ q x j$  \}
  \bigcup$
  
  \hspace{1,9cm}       $\{(A\stackrel{}{\rightarrow}a.b , k) | B\stackrel{}{\rightarrow}e , (A\stackrel{}{\rightarrow}a.b, k) \in climb$ q B j $\}$
  \item climb q X  i = $\{(A\stackrel{}{\rightarrow}a.Xb , k) | (A\stackrel{}{\rightarrow}aX.b, k)\in parse($goto q X$) i , a\neq e, A\stackrel{}{\rightarrow}a.Xb \in q\}\bigcup$
  
  \hspace{2,5cm}          $\{(A\stackrel{}{\rightarrow}a.b , l) | (C\stackrel{}{\rightarrow}X.c,j)\in parse($goto q X$) i, (A\stackrel{}{\rightarrow}a.b ,l)\in climb$ q C j$\} $
\end{itemize}

Эти функции, дополненные механизмом запоминания результатов, реализуют недетерминированный анализ. Нам необходимо таким образом модифицировать их, чтобы получить непосредственную поддержку EBNF-грамматик и чтобы результатом их работы являлся лес вывода.



\subsubsection{Поддержка расширенных контекстно-свободных грамматик}

Поддержка регулярных выражений в правых частях правил (EBNF-грамматики) получается естественным образом. Для этого правая часть правила представляется как конечный автомат. LR-ситуация в таком случае может быть представлена парой: правило (нетерминал+КА) и номер состояния (соответствует позиции маркера в классическом определении). Проблемы определения левой границы отрезка в магазине, соответствующего текущему правилу, в данном подходе не существует, так как стек вызовов рекурсивных функций хранит информацию о начале анализа по правилу.

Действительно, в правой части правила всегда находится регулярное выражение. В простом случае, когда это последовательность терминалов и нетерминалов, позиция маркера из классического определения LR-ситуации тривиальным образом соответствует состоянию конечного автомата, построенного по этой последовательности, а перемещение маркера -- переход КА из одного состояния в другое. В общем случае по  регулярному выражению из правой части правила по алгоритму Томпсона~\cite{DrgBook} строится недетерминированный конечный автомат (НКА). Заметим, что в в полученном НКА много $\varepsilon$-переходов. Например, каждая альтернатива вносит два дополнительных состояния и 4 $\varepsilon$-перехода. Чтобы уменьшить количество переходов в результирующем LR-автомате можно преобразовать НКА в детерминированный конечный автомат(ДКА). Для этого применим стандартный алгоритм преобразования НКА в ДКА~\cite{DrgBook}. После этого заменим позицию маркера номером состояния полученного ДКА.
 
Таким образом, мы можем строить LR-ситуации для EBNF-грамматик. Для каждой, построенной LR-ситуации, для дальнейшей работы необходимо хранить следующую информацию:
\begin{itemize}
  \item номер правила;
  \item левую часть правила(нетерминал);
  \item номер текущего состояния ДКА;
  \item символ принимаемый ДКА в данном состоянии;
  \item номер состояния ДКА, в которое он перейдёт приняв данный символ;
  \item номер начального состояния ДКА;
  \item номера конечных состояний ДКА;
\end{itemize}

Функция $goto$ для работы с новыми LR-ситуациями основана на стандартном алгоритме вычисления GOTO при LR анализе~\cite{DrgBook}. Его необходимо лишь изменить таким образом, чтобы он мог работать с LR-ситуациями, определённого нами вида. 

\subsubsection{Построение леса вывода}

Для того, чтобы построить лес вывода, необходимо добавить в функции механизм свёртки очередного узла дерева и предусмотреть сохранение леса.

В функции $parse$ необходимо производить конструирование нового листа, в случае, кгода происходит чтение очередного символа из входной цепочки.

В функции $climb$ необходимо конструировать новый внутренний узел из поддеревьев, в случае, когда нужно произвести свёртку по текущему правилу, и объединять множестав поддеревьев, в случае, если работа с текущем правилом ещё не закончена (сместился маркер в правой части).

Введём следующие обозначения:
\begin{itemize}
  \item $A \rightarrow R$ -- правило грамматики, где $A$ -- нетерминал, $R$ -- ДКА, построенный по регулярному выражению; 
  \item $(A \rightarrow R,i)$ -- LR-ситуация, где $i$ -- состояние ДКА;
  \item $is-final \ R \ i$ -- функця , осуществляющая проверку, что $i$ -- конечное состояние $R$;
  \item $(leaf:a)$, $(A->...)$ -- конструкции дерева разбора;
\end{itemize}

Тогда сигнатуры функции будут иметь следующий вид:

$parse$ $ q $ $ \{ u | A \rightarrow a.b, u = vx, b \rightarrow v \} \rightarrow (A \rightarrow a.b) x \{tree_i | tree_i  - $синтаксическое дерево вывода для $ t_i : t_1 .. t_n  \rightarrow \in b \})$

$climb$ $q$ $X$ $\{ u | A \rightarrow aX.b, u = vx, b \rightarrow v \} (tree: $синтаксическое дерево для X$) \rightarrow (A \rightarrow a.Xb) x \{tree_i | tree_i  - $синтаксическое дерево вывода для $ t_i : t_1 .. t_n  \rightarrow  Xb\}$

А сами функции будут выглядеть так:

\verb|parse q u =|

\ \ \ \ \ \  \verb|if exists (b A| $\rightarrow$ \verb|R,i) q| \ $\&$ \ \verb|is-final(R,i)| 
  
\ \ \ \ \ \  \verb|then (A| $\rightarrow$ \verb|R,i;u;[])|

\ \ \ \ \ \  \verb|else|

\ \ \ \ \ \ \ \ \ \verb|if u=av| $\&$ \verb|exists ( A| $\rightarrow$ \verb| R,i) q* | $\&$ \verb| R(i,a)=j| 
     
\ \ \ \ \ \ \ \ \ \verb|then climb q a v (leaf:a)|
     
\ \ \ \ \ \  \verb|else|
     
\ \ \ \ \ \  \verb|if exist (A| $\rightarrow$ \verb|R,0) q*| \ $\&$ \ \verb|is-final(R,0)| 
        
        
\ \ \ \ \ \  \verb|then climb q A v (A| $\rightarrow$ \verb|[])|
        
\verb|climb q X u h = |

  \ \ \ \ \ \ \verb| let (A| $\rightarrow$ \verb|R,j;w;s) = parse (goto q* X) u in|
  
  \ \ \ \ \ \ \verb| if R(i,X)=j| \ $\&$ \ \verb|(A|$\rightarrow$ \verb| R,i) in q| 
  
  \ \ \ \ \ \ \verb| then (A| $\rightarrow$ \verb| R,i;w;h::s)|
   
  \ \ \ \ \ \ \verb| else climb q A w (A| $\rightarrow$ \verb| h::s)|


\subsection{Вычисление атрибутов}

На практике для задания семантических действий применяются наследуемые (l-атрибутные грамматики) и вычислимые (s-атрибутные грамматики) атрибуты. В рамках данной работы была поставлена задача поддержать работу с s-атрибутными грамматиками.

Далее будут подробнее описаны особенности вычисления атрибутов при непосредственной поддержке EBNF-грамматик и алгоритм вычисления атрибутов.


\subsubsection{Задание семантических атрибутов в YARD}

Грамматика YARD-а~\cite{Diploma} позволяет определять атрибуты для любой части продукции, которая является последовательностью. На практике это означает, что атрибут может быть ассоциирован не только с правилом целиком, а с любой его частью, которая является последовательностью. Например:

\begin{verbatim}
  someRule : val1 = (a {action1} | b {action2}) 
             val2 = c  {someFunc val1 val2};
\end{verbatim}

Здесь альтернатива \verb| ( a |\verb|b )| возвращает некоторое значение (\verb|action1| или \verb|action2|), которое сохраняется в переменной \verb|val1|, значение нетерминала сохраняется в переменной \verb|val2|, и далее обе эти переменные передаются в качестве аргументов в пользовательскую функцию \verb|someFunc|.

Возможность таким способом задавать атрибуты вызывает сложности при интерпретации дерева вывода. Связаны они с тем, что для вычисления атрибутов становится недостаточно информации только о дереве вывода входного выражения. 

Рассмотрим эту проблему более подробно. Допустим, в грамматике есть правило:

\begin{verbatim}
  someRule : val1 = (a {action1})* val2 = c  {someFunc val1 val2};
\end{verbatim}

Узел дерева вывода, соответствующий правилу, приведённому выше, может выглядеть следующим образом:

\begin{centering}
  \begin{dot2tex}[dot,autosize]

  digraph string_of_child
  {
          a1[label = "a"];
          a2[label = "a"];
          a3[label = "a"];
          c[label = "c"];
          S[label = "someRule"]
            
          S -> a1;
          S -> a2;
          S -> a3;
          S -> c;                            
  }
  \end{dot2tex}

\end{centering} 

Для вычисления атрибутов в этом узле необходимо знать,  что первые три сына были порождены из замыкания, их необходимо объединить в список и уже его передать в функцию \verb|someFun| в качестве первого параметра.

В общем случае можно  рассматривать непосредственных сыновей узла как строку, принадлежащую языку, задаваемому регулярным выражением в правой части правила.  Тогда можно сказать, что для вычисления атрибутов нам необходимо дерево разбора этой строки.

Для нашего примера:

\begin{centering}
  \begin{dot2tex}[dot,autosize]

  digraph string_of_child
  {
            S[label = "someRule"]

            c[label = "c"]; 
            a1[label = "a"];
            a2[label = "a"];
            a3[label = "a"];           
              
            S -> c;                            
            S -> a1;
            S -> a2;
            S -> a3;

          subgraph cluster_STR
          {                                                
                  bgcolor = grey;
                  str[label = "1",texlbl = "$Str:$",shape = plaintext]
                  c
                  a1;
                  a2;
                  a3;
                  
          };
  }
  \end{dot2tex}
%\captionof{figure}{ntcn}
%	\label{fig:rr}

\end{centering}
 
Где $Str$ -- строка, выводимая в грамматике, заданной регулярным выражением в правой части правила. Дерево разбора этой строки будет выглядеть так:

\begin{centering}
  \begin{dot2tex}[dot,autosize]

  digraph string_diriv_tree
  {

            Seq[label = "Seq"]
            Cls[label = "Cls"]
            a1[label = "a"];
            a2[label = "a"];
            a3[label = "a"];
            c[label = "c"];                        
                                   
            Seq -> Cls;            
            Seq -> c; 
            Cls -> a1;
            Cls -> a2; 
            Cls -> a3;                           

  }
  \end{dot2tex}
  %\captionof{figure}{ntcn}
  %	\label{fig:rr}

\end{centering}

Таким образом, для того, чтобы вычислять атрибуты, нам необходимо во время интерпретации дерева вывода входного выражения построить дерево разбора строки из сыновей узла, для которого непосредственно производятся вычисления. Для этого необходимо во время анализа поучить и сохранить информацию о выводе этой строки. 

Удобным механизмом для решения этой проблемы оказался конечный автомат с помеченными переходами (далее будем для простоты будем называть их LFA -- Labelled Finite Automaton). Общая схема решения такова: 
\begin{enumerate}
	\item строится недетерминированный конечный автомат с помеченными переходами (LNFA), в котором в качестве меток сохраняется информация о начале и завершении конструкций регулярного выражения, по которому строится этот LNFA;
  \item по LNFA строится детерминированный конечный автомат с помеченными переходами (LDFA);
  \item в процессе анализа собираются и сохраняются метки с совершённых переходов и на основе этой информации строится дерево разбора.
\end{enumerate}

Подробнее все эти шаги будут описаны далее.



\subsubsection{Построение LNFA по регулярному выражению}

Определим LNFA как пятёрку $(Q$, $\Sigma$, $L$, $T$, $q_0$, $F)$, состоящая из:
\begin{itemize}
	\item конечного множества состояний $Q$ 
	\item конечного множества входных символов $\Sigma$ 
	\item конечного множества меток $L$ 
	\item функции перехода $T: \; Q \times (Z \cup{ \epsilon })\rightarrow 2^{Q \times L}$
	\item начального состояния $q_0 \in Q$
	\item конечного множества финальных состояний $F \subseteq Q$ 
\end{itemize}

Таким образом переходы автомата снабжаются метками. При изображении автомата в виде графа, переходам соответствуют рёбра. Будем записывать метки через знак "/" \; после символа, принимаемого автоматом при данном переходе. 

Пример LNFA:

\begin{dot2tex}[dot]
digraph G
{
        rankdir = LR
        F [shape = doublecircle]
        S -> F [  label="a/l"
                , texlbl = "$a/someLbl$" ]
}
\end{dot2tex}


Где $a$ -- принимаемый символ, $someLbl$ -- метка.

Чтобы решить задачу вычисления атрибутов необходимо знать, когда началось и когда закончилось распознавание той или иной конструкции регулярного выражения. Для этого определим  метки специального типа:
\begin{itemize}
	\item для обозначения начала и конца конструкции
		\begin{itemize}
			\item лист: $LeafS,$ $LeafE$;
			\item последовательность: $SeqS,$ $SeqE$;
			\item замыкание: $ClsS,$ $ClsE$;
			\item альтернатива: $Alt1S,$ $Alt1E,$ $Alt2S,$ $Alt2E$ - пара меток для каждой ветви;
		\end{itemize}
			\item $\omega$ -- "`пустая"' метка;
\end{itemize}

Метка для конкретного ребра будет состоять из типа метки и уникального идентификатора, который совпадает у меток начала и конца одной и той же конструкции. Таким образом, множество меток $L$ можно определить так:

\begin{eqnarray}
     \label{def:L}
	   &L = \left\{ \right. t*k\; | \; t \in \left\{ \right.  SeqS,\; SeqE,\; LeafS,\; LeafE,\; ClsS,\; ClsE, & \nonumber \\
	   & \qquad Alt1S,\; Alt1E,\; Alt2S,\; Alt2E,\; \omega \; \left. \right\},\; k \in N \left.\right\} &
\end{eqnarray}

Для построения LNFA по регулярному выражению необходимо модернизировать алгоритм Томпсона. Его необходимо дополнить механизмом расстановки меток.

Будем рассматривать алгоритм, который работает с деревом вывода регулярного выражения, которое мы можем получить из YARD-а. Это дерево может содержать следующие конструкции:
\begin{itemize}
  \item Leaf(a) -- лист дерева. Соответствует символу в регулярном выражении.
  \item Seq(lst) -- последовательность. lst -- список элементов последовательности.
  \item Alt(L,R) -- альтернатива.
  \item Cls(T) -- замыкание.
\end{itemize}

Определим ряд функций:
\begin{itemize}
  \item $\mathop{buildL\!N\!F\!A:} \; 'Tree \rightarrow {'L\!N\!F\!A}$ -- строит LNFA по дереву вывода регулярного выражения.

  \item $map: \; ('T \rightarrow {'U}) \rightarrow {'T}  \; list \rightarrow {'U} \; list$ -- применяет функцию, переданную в качестве первого аргумента, к каждому элементу списка, перданного вторым аргументом.

  \item $concat: \; 'L\!N\!F\!A \; list \rightarrow {'L\!N\!F\!A}$ -- конкатенирует автоматы из списка, добавляя $\epsilon/\omega$-переходы.  
\end{itemize}

Так же предположим, что у нас есть функция для генерации уникального индекса $k$ для нумерации меток.

Модернизированный алгоритм будет выглядеть следующим образом:
  \begin{itemize}
    \item
      Лист : Leaf(a) \
      \begin{flushleft}
        \input{TNFACreateLeaf.tex}
      \end{flushleft}
    \item 
      Последовательность : Seq(lst) \
      \begin{flushleft}
        \input{TNFACreateSeq.tex}
      \end{flushleft}
    \item 
      Альтернатива : Alt(L,R) \
      \begin{flushleft}
        \input{TNFACreateAlt.tex}
      \end{flushleft}
    \item 
      Замыкание : Cls(T) \
      \begin{flushleft}
        \input{TNFACreateCls.tex}
      \end{flushleft}
  \end{itemize}

Таким образом, теперь мы можем по регулярному выражению построить LNFA с метками, соответствующими началу и концу каждой конструкции регулярного выражения.


\subsubsection{Построение LDFA по LNFA}

Для дальнейшего использования необходимо преобразовать недетерминированный автомат в детерминированный автомат. Для этого можно использовать стандартный алгоритм построения DFA по NFA~\cite{DrgBook}, расширенный для работы с метками.

Определим детерминированный конечный автомат с метками (LDFA), как как пятёрку $(Q$, $\Sigma$, $L'$, $T$, $q_0$, $F)$, состоящая из:
\begin{itemize}
	\item конечного множества состояний $Q$ 
	\item конечного множества входных символов $\Sigma$ 
	\item конечного множества меток $L$ 
	\item функции перехода $T: \; Q \times Z \rightarrow Q \times L'$
	\item начального состояния $q_0 \in Q$
	\item конечного множества финальных состояний $F \subseteq Q$ 
\end{itemize}

В нашем случае $L' = 2^{(2^L)}$, где $L$ -- множество меток LNFA $\eqref{def:L}$ и подмножества $L$ являются упорядоченными.

Процесс построения детерминированного автомата с помеченными переходами можно разбить на 2 этапа:
\begin{enumerate}
	\item построение детерминированного автомата с помощью стандартного алгоритма;
	\item вычисление и расстановка новых меток.
\end{enumerate}

Рассмотрим второй этап более подробно. Сперва необходимо разбить состояния DFA, построенного на первом шаге, на два множества: $F$ -- множество конечных состояний и $I = Q/F$ -- остальные (не конечные) состояния. 

Для дальнейшей работы нам понадобится функция $calculateN\!ewLabel:\; {'\!state} \rightarrow '\!l$, где $'\!l \in L'$. Она будет по состоянию автомата вычислять метку для перехода из этого состояния. Определим эту функцию следующим образом:
\\
$calculateN\!ewLabel \; state \; = $\\
$\phantom \qquad let \; e = \text{множество всех } \epsilon\text{-цепочек, заканчивающихся в state} $ \\
$\phantom \qquad let \; l = map \ (fun \ eLine \rightarrow \text{ пройти по } eLine \text{ из начала в конец}$ \\
$\phantom \qquad \qquad \quad \text{ и собрать по порядку все метки}) \; e \\$
$\phantom \qquad l$\\
Основная функция для вычисления и расстановки новых меток: \\
$setN\!ewLabel = $\\
$ \phantom \qquad \text{Для каждого состояния } f \in F \text{ добавить новое "висячее" \ ребро с началом в } f$ \\
$ \phantom \qquad \text{и установить ему метку равную } (calculateN\!ewLabel \ f)$\\
$ \phantom \qquad \text{Для каждого состояния } i \in I \text{, для каждого ребра, выходящего из } i$ \\
$ \phantom \qquad \text{установить метку равную } (calculateN\!ewLabel \ i)$

Рассмотрим работу данного алгоритма на примере. Пусть дано правило грамматики: $S \rightarrow a|b$. Необходимо построить ДКА с помеченными переходами для этого правила. По регулярному в правой части ,применив алгоритм, описанный выше, построим НКА. В результате мы получим следующий автомат:
 
\begin{centering}

  \begin{dot2tex}[dot]
  digraph G
  {
          1 [label = "1"]
          2 [label = "2"]
          3 [label = "3"]
          4 [label = "4"]
          5 [label = "9"]
          6 [label = "10", shape = doublecircle]
          15 [label = "5"]
          16 [label = "6"]
          17 [label = "7"]
          18 [label = "8"]


          5 -> 15[label = "1234567", texlbl = "$\epsilon/(Alt1S,1)$"]
          5 -> 17[label = "1234567", texlbl = "$\epsilon/(Alt2S,1)$"]
          15 -> 1[label = "1234567", texlbl = "$\epsilon/(LeafS,1)$"]
          1 -> 2 [label = "123", texlbl = "$a/\omega$"]
          2 -> 16[label = "1234567", texlbl = "$\epsilon/(LeafE,1)$"]
          17 -> 3[label = "1234567", texlbl = "$\epsilon/(LeafS,2)$"]
          3 -> 4 [label = "123", texlbl = "$b/\omega$"]
          4 -> 18[label = "1234567", texlbl = "$\epsilon/(LeafE,2)$"]
          16 -> 6[label = "1234567", texlbl = "$\epsilon/(Alt1E,1)$"]
          18 -> 6[label = "1234567", texlbl = "$\epsilon/(Alt2E,1)$"]
  }
  \end{dot2tex}

\end{centering}

Далее, по этому автомату строится ДКА. Для построения применяется стандартный алгоритм Томпсона. Метки на рёбрах можно опустить, они будут вычислены на следующем шаге. Результирующий автомат будет выглядеть следующим образом:

\begin{centering}

  \begin{dot2tex}[dot]
  digraph G 
  {
    1 
    2 [shape = doublecircle]
    3 [shape = doublecircle]
    1 -> 2[ label = "a"]
    1 -> 3[ label = "b"]
  }
  \end{dot2tex}

\end{centering}

После этого можно вычислить новые метки, способом описанным выше. Автомат изменится -- в нём появятся две "висячие" \ дуги -- для каждого из финальных состояний. Выглядеть результирующий автомат будет следующим образом: 

\begin{centering}

  \begin{dot2tex}[dot]
  digraph G 
  {
    1 
    2 [shape = doublecircle]
    3 [shape = doublecircle]
    4 [shape = none, label = ""]
    5 [shape = none, label = ""]
    1 -> 2[ label = "01234567901234", texlbl = "$a/[[(Alt1S,1); \ (LeafS,1)]]$"]
    1 -> 3[ label = "01234567901234", texlbl = "$b/[[(Alt2S,1); \ (LeafS,2)]]$"]
    2 -> 4[ label = "01234567901234", texlbl = "$\epsilon/[[(LeafE,1); \ (Alt1E,1)]]$"]
    3 -> 5[ label = "01234567901234", texlbl = "$\epsilon/[[(LeafE,2); \ (Alt2E,1)]]$"]
  }
  \end{dot2tex}

\end{centering}

Метками в полученном детерминированном автомате являются множества списков меток недетерминированного автомата. Заведём список и в процессе работы автомата, при очередном переходе, будем добавлять в его конец метку ребра, по которому произошёл переход. В случае, если входная строка была принята, нам нужно получить трассу вычислений. Для этого необходимо последовательно просмотреть полученный список меток начиная с конца и из текущего множества выбирать только те списки, начальный элемент которых являет закрывающим для какого либо из конечных элементов списка в следующем множестве.

Таким образом мы построили детерминированный конечный автомат с помеченными переходами, с помощью которого можно получить необходимую для дальнейшие работы информацию о выводе входной строки.


\subsubsection{Генерация кода для семантических действий пользователя}

При задании грамматики пользователь может, пользуясь атрибутами, указывать семантические действия. Необходимо на основе этих атрибутов построить код, который будет производить необходимые вычисления.

Для вычисления атрибутов был выбран подход интерпретации дерева (леса) вывода. Основная идея этого алгоритма --обход заранее построенного дерева вывода и вычисление необходимых функций в его узлах.

В нашем случае дерево будет обходиться снизу вверх, так на данном этапе было решено поддержать только s-атрибутные грамматики. 

При интерпретации дерева вывода оно обходится снизу вверх и в каждом узле вычисляется некоторая функция, основанная на атрибутах из пользовательской грамматики. Каждый внутренний узел в дереве вывода выражения в данной грамматике соответствует правилу из этой грамматики. Поэтому для интерпретации дерева достаточно построить функцию, соответствующую правилу грамматики и основанную на атрибутах, заданных в этом правиле. При обходе дерева в каждом его узле будет вычисляться соответствующая ему функция.

Функция всегда принимает один аргумент -- дерево разбора строки из сыновей узла, в котором она вычисляется, и является интерпретатором этого дерева. Результат вычислений помещается в узел, для которого функция вычислялась.

Параллельно с генерацией кода строится таблица соответствий между функцией и правилом, для которого она построена. Эта таблица будет применяться при интерпретации дерева вывода, для поиска функции для узла дерева. 


\subsubsection{Интерпретация дерева вывода}

Чтобы вычислить семантические действия, заданные пользователем, необходимо выполнить интерпретацию дерева вывода. Для этого нужно обойти дерево снизу вверх и в каждом внутреннем узле вычислить соответствующую функцию, которая ищется с помощью таблицы соответствий между правилом и функцией.

Общая схема интерпретации дерева выглядит следующим образом:
\begin{itemize}
  \item построенное дерево разбора обходится снизу вверх;
  \item для очередного внутреннего узла, на основе трассы, хранимой в нём, строится дерево разбора строки из сыновей;
  \item с помощью таблицы, построенной на этапе генерации, ищется функция, соответствующая данному узлу;
  \item найденная функция применяется к построенному дереву разбора;
  \item результат сохраняется в текущем узле;
\end{itemize} 

В процессе анализа в узлах дерева вывода накапливается информация, необходимая для построения дерева разбора строки из его сыновей в виде трасс вычислений соответствующих автоматов.

Полученная трасса является, по сути своей, правильной скобочной структурой, которую надо наложить на строку из сыновей. Сделать это не сложно, так как каждый символ строки окружён скобками. После этого становится возможным построить дерево разбора строки сыновей. Для этого скобочная пара сворачивается в узел дерева, а все элементы, лежащие внутри скобок, превращаются в сыновей этого узла.

Дерево разбора будет содержать четыре типа узлов:\\
$type \ aTree< \ '\!value> \ = \\
\phantom \qquad |\ ASeq \ of \ List<\!aTree\!>\\
\phantom \qquad |\ AAlt \ of \ Option<\!aTree\!> * Option<\!aTree\!>\\
\phantom \qquad |\ ACls \ of \ List<\!aTree\!>\\
\phantom \qquad |\ ALeaf \ of \ 'value\\
$

Алгоритм построения дерева выглядит следующим образом:
\\
$buildTree \ line = \\
\phantom \qquad let \ group = \ \text{первая скобочная пара из line}\\ 
\phantom \qquad let \ end = \ \text{line без group} \\
\phantom \qquad let \ tree = match \ \text{тип внешних скобок group} \ with\\
\phantom \qquad \qquad |\ Seq \rightarrow    ASeq( buildTree \ \text{значение внутри скобок group})\\
\phantom \qquad \qquad |\ Alt1 \rightarrow   AAlt( (buildTree \ \text{значение внутри скобок group}),N\!one)\\
\phantom \qquad \qquad |\ Alt2 \rightarrow   AAlt( N\!one, (buildrTree \ \text{значение внутри скобок group}))\\
\phantom \qquad \qquad |\ Cls \rightarrow    ACls( buildTree \ \text{значение внутри скобок group})\\
\phantom \qquad \qquad |\ Leaf \rightarrow ALeaf(\text{ значение внутри скобок group)}   \\
\phantom \qquad if \ end \ \text{пусто} \\
\phantom \qquad then \ [tree] \\
\phantom \qquad else \ tree::(buildTree \ end)\\
$

Предложенный выше алгоритм, позволяет вычислять пользовательские атрибуты, обеспечивая при этом непосредственную поддержку EBNF-грамматик. 

\subsection{Архитектура}
\input{architecture.tex}
