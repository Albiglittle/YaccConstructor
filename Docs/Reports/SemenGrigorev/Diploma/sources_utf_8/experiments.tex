\section{Эксперименты}

Был проведён ряд экспериментов, которые позволили оценить некоторые параметры инструмента.

Во всех приведённых ниже тестах грамматики описываются на языке YARD. Так же предположим, что у нас есть сторонний лексер со следующим набором лексем:
\begin{itemize}
  \item PLUS = '+'
  \item MINUS = '-'
  \item DIV = '/'
  \item MULT = '*'
  \item LEFT = '('
  \item RIGHT = ')'
  \item NUMBER = (0..9)+
\end{itemize}

По этому будем предполагать, что на вход инструменту поступает поток лексем.


\subsection{Работа с однозначными грамматиками} 

Необходимо показать, что по однозначной грамматике строится инструмент имеющий линейную временную сложность.
	<Пример грамматики> <Описание эксперимента>


\subsection{ Возможность работы с неоднозначными грамматиками} 

Для этого необходимо проверить, что при неоднозначной грамматике инструмент возвращает все возможные варианты вывода входной строки. В качестве примера была взята следующая грамматика:

\begin{verbatim}
+s : e;
e : e (PLUS | MINUS | MULT | DIV  ) e 
  | LEFT e RIGHT 
  | NUMBER ;
\end{verbatim}

Эта грамматика описывает арифметические выражения без приоритетов. Очевидно, что данная грамматика содержит неоднозначности. 

Рассмотрим несколько примеров входных цепочек:
\begin{itemize}

  \item \verb|[NUMBER; PLUS; NUMBER]|. Существует единственное дерево вывода для данной цепочки:
    \begin{centering}
      \begin{dot2tex}[dot]
       digraph g
       {
          S [label = "S"]
          e1 [label = "e"]
          e2 [label = "e"]
          plus [label = "PLUS"]
          e3 [label = "e"]
          num1 [label = "NUMBER"]
          num2 [label = "NUMBER"]
          S -> e1
          e1 -> e2
          e1 -> plus
          e1 -> e3
          e2 -> num1
          e3 -> num2
       }
      \end{dot2tex}
    \end{centering}

Инструмент возвращает единственное дерево:
\begin{verbatim}
<NODE name="S">
        <NODE name="e">
            <NODE name="e">
                <LEAF name="NUMBER"/>
            </NODE>
            <LEAF name="PLUS"/>
            <NODE name="e">
                <LEAF name="NUMBER"/>
            </NODE>
        </NODE>
</NODE>
\end{verbatim}

\item \verb|[NUMBER; PLUS; NUMBER; PLUS; NUMBER]|. Для данной цепочки существует два дерева вывода и инструмент возвращает оба:
\begin{verbatim}
<NODE name="s">
    <NODE name="e">
        <NODE name="e">
            <NODE name="e">
                <LEAF name="NUMBER"/>
            </NODE>
            <LEAF name="PLUS"/>
            <NODE name="e">
                <LEAF name="NUMBER"/>
            </NODE>
        </NODE>
        <LEAF name="PLUS"/>
        <NODE name="e">
            <LEAF name="NUMBER"/>
        </NODE>
    </NODE>
</NODE>

<NODE name="s">
    <NODE name="e">
        <NODE name="e">
            <LEAF name="NUMBER"/>
        </NODE>
        <LEAF name="PLUS"/>
        <NODE name="e">
            <NODE name="e">
                <LEAF name="NUMBER"/>
            </NODE>
            <LEAF name="PLUS"/>
            <NODE name="e">
                <LEAF name="NUMBER"/>
            </NODE>
        </NODE>
    </NODE>
</NODE>
\end{verbatim}
	
\end{itemize}
	


\subsection{Возможность работы с EBNF-грамматиками} 

Основные конструкции регулярных выражений, для которых необходимо провести проверку - последовательность, альтернатива, замыкание. Важно обратить внимание на соответствие получаемого дерева вывода ожидаемому результату. Для этого нужно проверить соответствие дерева вывода входной грамматике. В нём не должно быть новых терминалов и нетерминалов.
	


\subsection{Поддержка s-атрибутных грамматик}

 Необходимо показать корректность вычисления атрибутов в случае неоднозначной грамматики. Для этого необходимо, чтобы были получены все возможные результаты вычислений и чтобы операции с побочными эффектами работали корректно (например, проверить, что при наличии в атрибутах действия печати на экран, на экран  не выводится лишней информации). Так же необходимо показать возможность вычисления атрибутов в случае расширенной контекстно-свободной  грамматики. 
\\
<Описание эксперимента>
\\

Так же, в ходе этого эксперимента было выявлено, что предложенное решение, когда явным образом строится дерево вывода и для каждого правила строится своя семантическая функция, оказывается удобным. С одной стороны, это позволяет упростить отладку, потому, что всегда можно проверить правильность построения дерева и в отладчике просто проконтролировать вычисление в конкретном узле (мы знаем при свёртке какого правила появился этот узел и знаем какая функция должна вычисляться). С другой -- прямой доступ к лесу вывода позволяет совершать с ним дополнительные операции.  Дополнительную фильтрацию или, например печать, что оказалось полезным при получении результатов экспериментов (печать XML-представления деревьев). 
