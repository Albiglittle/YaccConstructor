\section{Обзор}


\subsection{Алгоритм анализа}

Одно из основных требований к инструментам автоматической генерации анализаторов, применяемым при решении задач реинжиниринга -- возможность работать с неоднозначными грамматиками, так как с их помощью часто описываются устаревшие языки.

Существует несколько подходов к реализации алгоритма, позволяющего работать с грамматиками, содержащими неоднозначности:
\begin{itemize}
  \item {\bfseries алгоритм Томиты} (GLR-алгоритм)~\cite{Practical Guide}, основанный на организованном в виде графа стеке;
  \item {\bfseries алгоритм Эрли} (Early)~\cite{Practical Guide}, основа которого -- специальным образом определённое состояние;
  \item {\bfseries рекурсивно-восходящий алгоритм} (recursive-ascent)~\cite{RECURSIVE-ASCENT PARSING}~\cite{RecursiveAscentParsing}, основанный на наборе взаимно-рекурсивных функций, эмулирующих переходы между состояниями, и механизме запоминания результатов предыдущих вычислений;
  \item {\bfseries CYK}~\cite{Practical Guide}
  \item {\bfseries Unger}~\cite{Practical Guide}
\end{itemize}
       
В настоящее время наиболее популярным в практическом применении является алгоритм Томиты. Существует ряд инструментов, основанных на этом алгоритме:
\begin{itemize}
	\item
	 ASF+SDF~\cite{ASF+SDF} (Algebraic Specification Formalism + Syntax Definition Formalism) -- генератор с широкими возможностями, но достаточно сложным входным языком. Является SGLR-инструментом (Scannerless, Generalized-LR).
	
	\item
	 Bison~\cite{Bison} -- развитие инструмента YACC. Все грамматики, созданные 	для оригинального YACC, будут работать и в Bison. Является одним 	из самых популярных и совершенных "потомков" \ YACC. При включении 	соответствующей опции использует GLR-алгоритм (по умолчанию LALR).
	
	\item
	Elkhound~\cite{Elkhound} -- позиционируется как быстрый и удобный GLR-инструмент, созданный в университете Беркли (США), тем не менее обладает достаточно 	"бедным" \ входным языком (например, он не поддерживает конструкций 	расширенной формы Бэкуса-Наура).

  \item 
  DMS~\cite{DMS} -- инструментарий "DMS Software Reengineering Toolkit" \ включает в себя парсер генератор, основанный на GLR алгоритме.

	\item
  Happy~\cite{Happy} -- парсер генератор с целевым языком Haskell~\cite{Haskell}. Формат описания входной грамматики очень похож на формат классического YACC.

	\item
  Dypgen~\cite{Dypgen} -- GLR-инструмент, обладающий такими особенностями как возможность удалять и добавлять правила во время синтаксического анализа, специфический способ задания приоритетов операций.

\end{itemize}

Все вышеперечисленные инструменты реализуют стековый механизм анализа. Так же существует ряд других инструментов, основанных на том же алгоритме: 
APaGeD~\cite{APaGeD}, 
DParser~\cite{DParser}, 
eu.h8me.Parsing~\cite{h8me}, 
GDK~\cite{GDK}, 
SmaCC~\cite{SmaCC}, 
Tom~\cite{Tom}, 
UltraGram~\cite{UltraGram}, 
Wormhole~\cite{Wormhole}. Все они реализуют GLR или SGLR алгоритм и ни один из них не реализует непосредственной поддержки EBNF-грамматик.

Интересующий нас рекурсивно-восходящий алгоритм реализуется на текущий момент только одним инструментом: Jade~\cite{Jade}. Jade -- это генератор рекурсивно-восходящих LALR(1) парсеров с целевым языком С. При реализации данного инструмента возникла серьёзная проблема появилась, связанная с большим объёмом кода целевого парсера. Так как при построении детерминированного парсера необходимо генерировать процедуры для каждого состояния, то объём кода быстро растёт с ростом количества правил в грамматике. Так, например, для языка Java объём кода составляет примерно 4 мегабайта~\cite{Jade}. В Jade  эта проблема решается путём создания глобальной структуры(массива состояний), где хранится информация, позволяющая переиспользовать процедуры.

Однако существует подход к реализации рекурсивно-восходящего алгоритма, позволяющий решить проблему объёма кода~\cite{Non-det-rec-asc}. С использованием этого подхода можно получить алгоритм для недетерминированного анализа, основанный всего на двух взаимно-рекурсивных функциях и позволяющий реализовать непосредственную поддержку EBNF-грамматик.

Таким образом, выяснено, что на текущий момент нет реализаций недетерминированного рекурсивно-восходящего алгоритма, реализующего непосредственную поддержку EBNF-грамматик. Единственная реализация рекурсивно-восходящего алгоритма имеет проблемы с объёмом целевого инструмента, но существует решение этой проблемы.


\subsection{Атрибутные грамматики. Подходы к вычислению атрибутов}

При работе с неоднозначными грамматиками выдвигаются особые требования к алгоритму вычисления атрибутов. Это связано с тем, что в качестве атрибута пользователь может указать действие, обладающее побочным эффектом (например, печать на экран). При наличии таких атрибутов нельзя проводить вычисления непосредственно в процессе анализа, так как в момент разбора не возможно определить, завершиться ли текущая ветвь удачно. В ситуациях, когда при непосредственном вычислении ветвь завершилась неудачно, могут быть совершены лишние действия (например, лишняя печать на экран).

Были рассмотрены два подхода к решению этой проблемы: 
\begin{itemize}

	\item {\bfseries Отложенные вычисления} (continuation passing style, CPS). Непосредственно во время разбора атрибуты не вычисляются. Вычисления откладываются. Строится функция, которая вычисляется только один раз, после удачного завершения разбора.
	
	\item {\bfseries Интерпретация леса вывода} - построение леса вывода и последующее вычисление атрибутов над ним. Первым шагом строится лес вывода, который содержит только деревья, соответствующие успешным вариантам разбора. Следующим шагом над полученным лесом производятся вычисления, соответствующие заданным атрибутам.
	
\end{itemize}

Оба этих подхода гарантируют, что будут выполнены действия, соответствующие только успешным вариантам разбора. Однако второй подход является более удобным для конечного пользователя, так как позволяет явно получить дерево вывода, что упрощает отладку. Именно он и был выбран для реализации.
