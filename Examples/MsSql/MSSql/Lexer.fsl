{
//  UserLexer.fs contains simple lexer for testing.
//
//  for build:  fslex Lexer.fsl --unicode -o Lexer.fs
//
//  Copyright 2011, 2012 Semen Grigorev <rsdpisuy@gmail.com>
//
//  This file is part of YaccConctructor.
//
//  YaccConstructor is free software:you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.

module Lexer_alt
open Microsoft.FSharp.Text.Lexing
open Microsoft.FSharp.Text
open Microsoft.FSharp.Reflection
open Yard.Examples.MSParser
open LexerHelper

exception IdentToken
let getKwToken (name: string) = 
  try
    match name.ToUpper() with
    | "SELECT"    -> KW_SELECT("")
    | "FROM"      -> KW_FROM("")
    | "CREATE"    -> KW_CREATE("")
    | "PROC"
    | "PROCEDURE" -> KW_PROCEDURE("")
    | "VARYING"   -> KW_VARYING("")
    | "OUT" 
    | "OUTPUT"    -> KW_OUTPUT("")
    | "WITH"      -> KW_WITH("")
    | "FOR"       -> KW_FOR("")
    | "REPLICATION" -> KW_REPLICATION("")
    | "AS"        -> KW_AS("")
    | "BEGIN"     -> KW_BEGIN("")
    | "END"       -> KW_END("")
    | "BIGINT"    -> KW_BIGINT("")
    | "INT"       -> KW_INT("")
    | "TINYINT"   -> KW_TINYINT("")
    | "NUMERIC"   -> KW_NUMERIC("")
    | "BIT"       -> KW_BIT("")
    | "SMALLINT"  -> KW_SMALLINT("")
    | "DECIMAL"   -> KW_DECIMAL("") 
    | "MONEY"     -> KW_MONEY("")
    | "SMALLMONEY"-> KW_SMALLMONEY("")
    | "FLOAT"     -> KW_FLOAT("")
    | "REAL"      -> KW_REAL("")
    | "CHAR"      -> KW_CHAR("")
    | "VARCHAR"   -> KW_VARCHAR("")
    | "NCHAR"     -> KW_NCHAR("")
    | "NVARCHAR"  -> KW_NVARCHAR("")
    | "MAX"       -> KW_MAX("")
    | "NULL"      -> KW_NULL("")
    | "EXEC" 
    | "EXECUTE"   -> KW_EXECUTE("")
    | "CALLER"    -> KW_CALLER("")
    | "SELF"      -> KW_SELF("")
    | "OWNER"     -> KW_OWNER("")
    | "DECLARE"   -> KW_DECLARE("")
    | "NOCOUNT"   -> NOCOUNT("")
    | "SET"       -> SET("")
    | "ON"        -> ON("")
    | "OFF"       -> OFF("")
    | "RECOMPILE" -> KW_RECOMPILE("")
    | "RETURN"    -> KW_RETURN("")
    | _           -> raise IdentToken
  with
    | IdentToken -> IDENT ("IdentToken")

(*    let nameToUnionCtor (uci:UnionCaseInfo) = (uci.Name, FSharpValue.PreComputeUnionConstructor(uci))
    let ucis = FSharpType.GetUnionCases(typeof<token>) 
                    |> Array.map nameToUnionCtor                       
                    |> dict
    fun (name:string) startPos endPos ->
    let upperName = "KW_" + name.ToUpper()
    let (present, ctor) = ucis.TryGetValue(upperName) 
    if present then
        Some(ctor [| SourceText.ofTuple(name, (startPos, endPos)) |] :?>token)
    else
        None *)

let commendepth = ref 0
let startPos = ref Position.Empty
let str_buf = new System.Text.StringBuilder()

let appendBuf (str:string) = str_buf.Append(str) |> ignore
let clearBuf () = str_buf.Clear() |> ignore
  
let makeIdent notKeyWord (name:string) =
  let prefix = 
    if String.length name >=2 
    then name.[0..1] 
    else ""
  if prefix = "@@" then GLOBALVAR(name)
  else if prefix = "##" then GLOBALTEMPOBJ(name)
  else if name.[0] = '@' then LOCALVAR(name)
  else if name.[0] = '#' then TEMPOBJ(name)
  else if notKeyWord then IDENT(name)
  else getKwToken name

}

let anything = ['a'-'z' 'A'-'Z' '0'-'9' '\n' '\r' ' ' ] + 
let lparen = '('
let rparen = ')'
let eol = '\r' | '\n' | '\r' '\n' (* See script.sql position (4560,27) *)
let string_const = '\'' ['a'-'z' 'A'-'Z' '0'-'9' '-' '+' '*' '/' ' ' ]+ '\'' (* TODO: support line like 'aaa''aa' *)
let whitespaces = [' '  '\t']+
let idenstarchar  = ['A'-'Z' 'a'-'z' '_' '@' '#' 'а'-'я' 'А'-'Я' ] 
let idenbody_char  = ['A'-'Z' 'a'-'z' '_' '0'-'9' '@' '#' '$' 'а'-'я' 'А'-'Я' ] 
// Разобраться с идентификаторами cyrillic с,а (885574,_) (1004524)
let with_dot = '.' | idenbody_char
let ident = idenstarchar idenbody_char*
let decnumber = ['0'-'9']+ 
let hexnumber = "0x" ['0'-'9' 'a'-'f' 'A'-'F']+
let floae = 'e' | 'E'
let floatnumber = decnumber ('.' decnumber)? ( floae decnumber) ? (* what with 100.   ?? *)
let label = ident ':'


rule tokens = parse
 | eol          { tokens lexbuf }
 | string_const { Printf.printf "string_const: %s\n" (LexBuffer<_>.LexemeString(lexbuf))
                  STRING_CONST(LexBuffer<_>.LexemeString(lexbuf)) }
 | decnumber    { (*Printf.printf "decnumber %s\n" ( LexBuffer<_>.LexemeString(lexbuf) )*)
                  DEC_NUMBER(LexBuffer<_>.LexemeString(lexbuf) ) }
 | whitespaces  { tokens lexbuf }
 | "."          { DOT(".") }
 | ","          { COMMA(",") }
 | "="          { OP_EQ("=") }
 | ";"          { SEMI(";") }
 | "("      { LPAREN("(") }
 | ")"      { RPAREN(")") }
 | "["      { LBRACKET("(") }
 | "]"      { RBRACKET("]") }
 | "+"      { OP_PLUS("+") }
 | "-"      { OP_MINUS("-") }
 | "~"      { OP_TILDA("~") }
 | "*"      { STAR("*") }
 | "$"      { DOLLAR("$") } 
 | ident {  let l = LexBuffer<_>.LexemeString(lexbuf)
            let hasdot = l.IndexOf '.' <> -1
            match makeIdent false l with
            | x -> x
         }
 | "--" [^'\r' '\n']*  { tokens lexbuf (* parser knows nothing about comments *) }  
 | "/*" { commendepth := 1; clearBuf(); multiline_comment lexbuf }
 | eof  {EOF("")}
 | _    { failwith (sprintf "fucking shit received %s\n" (LexBuffer<_>.LexemeString(lexbuf)) ) }
and multiline_comment = parse
  | "/*" 
    { incr commendepth; appendBuf(LexBuffer<_>.LexemeString(lexbuf)); multiline_comment lexbuf}
  | "*/"
    { decr commendepth; 
      if !commendepth = 0 then 
        tokens lexbuf
      else 
        appendBuf(LexBuffer<_>.LexemeString(lexbuf)); multiline_comment lexbuf 
    }
  | eol {lexbuf.EndPos <- lexbuf.EndPos.NextLine; appendBuf(LexBuffer<_>.LexemeString(lexbuf)); multiline_comment lexbuf }
  | eof { failwith "unclosed comment in the end of file" }
  | [^ '\r' '\n' '*' '/']+ { appendBuf(LexBuffer<_>.LexemeString(lexbuf)); multiline_comment lexbuf } 
  | _ { appendBuf(LexBuffer<_>.LexemeString(lexbuf)); multiline_comment lexbuf }