{
//  UserLexer.fs contains simple lexer for testing.
//
//  for build:  fslex Lexer.fsl --unicode -o Lexer.fs
//
//  Copyright 2011, 2012 Semen Grigorev <rsdpisuy@gmail.com>
//
//  This file is part of YaccConctructor.
//
//  YaccConstructor is free software:you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.

module Lexer
open Microsoft.FSharp.Text.Lexing
open Microsoft.FSharp.Text
open Microsoft.FSharp.Reflection
open Yard.Examples.MSParser
open LexerHelper
open System
}

let anything = ['a'-'z' 'A'-'Z' '0'-'9' '\n' '\r' ' ' ] + 
let lparen = '('
let rparen = ')'
let eol = '\r' | '\n' | '\r' '\n' (* See script.sql position (4560,27) *)
let string_const = '\'' ['a'-'z' 'A'-'Z' '0'-'9' '-' '+' '*' '/' ' ' '_' '.' '=' ',' '[' ']' ':' '\'']* '\'' (* TODO: support line like 'aaa''aa' *)
let whitespaces = [' '  '\t']+
let idenstarchar  = ['A'-'Z' 'a'-'z' '_' '@' '#' '%' 'а'-'я' 'А'-'Я' ] 
let idenbody_char  = ['A'-'Z' 'a'-'z' '_' '0'-'9' '@' '%' '#' '$' 'а'-'я' 'А'-'Я' ] 
// Разобраться с идентификаторами cyrillic с,а (885574,_) (1004524)
//let with_dot = '.' | idenbody_char
let ident = idenstarchar idenbody_char*
let decnumber = ['0'-'9']+ 
let hexnumber = "0x" ['0'-'9' 'a'-'f' 'A'-'F']+
let floae = 'e' | 'E'
let floatnumber = decnumber ('.' decnumber)? ( floae decnumber) ? (* what with 100.   ?? *)
let label = ident ':'


rule tokens = parse
 | eol          { lexbuf.EndPos <- lexbuf.EndPos.NextLine;tokens lexbuf }
 | string_const { Printf.printf "string_const: %s\n" (LexBuffer<_>.LexemeString(lexbuf))
                  STRING_CONST(defaultSourceText lexbuf (LexBuffer<_>.LexemeString(lexbuf))) }
 | decnumber    { (*Printf.printf "decnumber %s\n" ( LexBuffer<_>.LexemeString(lexbuf) )*)
                  DEC_NUMBER(defaultSourceText lexbuf  (LexBuffer<_>.LexemeString(lexbuf))) }
 | whitespaces  { tokens lexbuf }
 | "."          { DOT(defaultSourceText lexbuf ".") }
 | ","          { COMMA(defaultSourceText lexbuf ",") }
 | "="          { OP_EQ(defaultSourceText lexbuf "=") }
 | ">"          { OP_MT(defaultSourceText lexbuf ">") }
 | "<"          { OP_LT(defaultSourceText lexbuf "<") }
 | ";"          { SEMI(defaultSourceText lexbuf ";") }
 | "("      { LPAREN(defaultSourceText lexbuf "(") }
 | ")"      { RPAREN(defaultSourceText lexbuf ")") }
 | "["      { LBRACKET(defaultSourceText lexbuf "[") }
 | "]"      { RBRACKET(defaultSourceText lexbuf "]") }
 | "+"      { OP_PLUS(defaultSourceText lexbuf "+") }
 | "-"      { OP_MINUS(defaultSourceText lexbuf "-") }
 | "~"      { OP_TILDA(defaultSourceText lexbuf "~") }
 | "*"      { STAR(defaultSourceText lexbuf "*") }
 //| "$"      { DOLLAR(defaultSourceText lexbuf "$") } 
 | ident {  let l = LexBuffer<_>.LexemeString(lexbuf)
            let hasdot = l.IndexOf '.' <> -1
            match makeIdent false l (lexbuf.StartPos, lexbuf.EndPos) with
            | x -> x
         }
 | "--" [^'\r' '\n']*  { tokens lexbuf (* parser knows nothing about comments *) }  
 | "/*" { commendepth := 1; clearBuf(); multiline_comment lexbuf }
 | eof  {EOF(defaultSourceText lexbuf  "")}
 | _    { failwith (sprintf "fucking shit received %s\n" (LexBuffer<_>.LexemeString(lexbuf)) ) }
and multiline_comment = parse
  | "/*" 
    { incr commendepth; appendBuf(LexBuffer<_>.LexemeString(lexbuf)); multiline_comment lexbuf}
  | "*/"
    { decr commendepth; 
      if !commendepth = 0 then 
        tokens lexbuf
      else 
        appendBuf(LexBuffer<_>.LexemeString(lexbuf)); multiline_comment lexbuf 
    }
  | eol {lexbuf.EndPos <- lexbuf.EndPos.NextLine; appendBuf(LexBuffer<_>.LexemeString(lexbuf)); multiline_comment lexbuf }
  | eof { failwith "unclosed comment in the end of file" }
  | [^ '\r' '\n' '*' '/']+ { appendBuf(LexBuffer<_>.LexemeString(lexbuf)); multiline_comment lexbuf } 
  | _ { appendBuf(LexBuffer<_>.LexemeString(lexbuf)); multiline_comment lexbuf }