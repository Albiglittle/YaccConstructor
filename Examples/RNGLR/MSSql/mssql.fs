module mssql

open FParsec.Primitives

open Microsoft.FSharp.Text.Lexing
open Yard.Utils.SourceText
let rec private dec_num   = opt ( attempt(Lexer.literal -)) >>= fun (_  as _1) ->(Lexer.pDEC_NUMBER |>> fun (_ as _2)   -> (_1,_2 ))

 and private sql_value   = (attempt (Lexer.pSTRING_CONST |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (dec_num  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (ident  |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal NULL |>> fun (_ as _1)   -> (_1 ))))

 and private ident   = yard_rule_brace_opt_1  |>> fun (_ as _1)   -> (_1 )

 and private yard_rule_brace_opt_1   = (attempt ((attempt (Lexer.pIDENT |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal TYPE |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal CLASS |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal STATE |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal OWNER |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal IGNORE_DUP_KEY |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal COUNT |>> fun (_ as _1)   -> (_1 ))))))) |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal [ >>= fun (_  as _1) ->((attempt (Lexer.pIDENT |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal TYPE |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal CLASS |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal STATE |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal OWNER |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal IGNORE_DUP_KEY |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal COUNT |>> fun (_ as _1)   -> (_1 ))))))) >>= fun (_  as _2) ->(Lexer.literal ] |>> fun (_ as _3)   -> (_2 ))))

 and private full_ident   = yard_rule_not_empty_list_2  |>> fun (_ as _1)   -> (_1 )

 and private yard_rule_not_empty_list_2   = ident  >>= fun (hd ) -> (many ( attempt(Lexer.literal . >>= fun (_  as _1) ->(ident  |>> fun (_ as _2)   -> (_2 )))) |>> fun (tl) -> ( hd::tl ) )  

 and public root_rule   = many ( attempt(batch_body  >>= fun (_  as _1) ->(opt ( attempt(Lexer.literal GO)) |>> fun (_ as _2)   -> (_1,_2 )))) |>> fun (_ as _1)   -> (_1 )

 and private batch_body   = (attempt (create_proc  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (set_stmnt  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal USE >>= fun (_  as _1) ->(Lexer.literal [ >>= fun (_  as _2) ->(Lexer.literal mdw_control >>= fun (_  as _3) ->(Lexer.literal ] |>> fun (_ as _4)   -> (_1,_2,_3,_4 )))))) <|> ((attempt (begin_transaction  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (commit_transaction  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (declare  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (case  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (rollback_transaction  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (if_stmt  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (drop_procedure  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (create_table  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (insert  |>> fun (_ as _1)   -> (_1 ))) <|> (error  |>> fun (_ as _1)   -> (_1 )))))))))))))

 and private rollback_transaction   = Lexer.literal ROLLBACK >>= fun (_  as _1) ->(opt ( attempt((attempt (Lexer.literal TRAN |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal TRANSACTION |>> fun (_ as _1)   -> (_1 )))) >>= fun (_  as _2) ->(opt ( attempt((attempt (Lexer.pIDENT |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.pLOCALVAR |>> fun (_ as _1)   -> (_1 )))) >>= fun (_  as _3) ->(opt ( attempt(Lexer.literal ;)) |>> fun (_ as _4)   -> (_1,_2,_3,_4 ))))

 and private set_stmnt   = (attempt (Lexer.literal SET >>= fun (_  as _1) ->((attempt (Lexer.literal ANSI_NULLS |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal ANSI_DEFAULTS |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal ANSI_NULL_DFLT |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal ANSI_PADDING |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal ANSI_WARNINGS |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal CONCAT_NULL_YIELDS_NULL |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal CURSOR_CLOSE_ON_COMMIT |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal QUOTED_IDENTIFIER |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal FMTONLY |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal FORCEPLAN |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal IMPLICIT_TRANSACTIONS |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal NOCOUNT |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal NOEXEC |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal NUMERIC_ROUNDABORT |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal PARSEONLY |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal REMOTE_PROC_TRANSACTIONS |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal SHOWPLAN_ALL |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal SHOWPLAN_TEXT |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal SHOWPLAN_XML |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal STATISTICS >>= fun (_  as _1) ->((attempt (Lexer.literal IO |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal PROFILE |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal TIME |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal XML |>> fun (_ as _1)   -> (_1 )))) |>> fun (_ as _2)   -> (_1,_2 )))) <|> (Lexer.literal XACT_ABORT |>> fun (_ as _1)   -> (_1 ))))))))))))))))))))) >>= fun (_  as _2) ->((attempt (Lexer.literal ON |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal OFF |>> fun (_ as _1)   -> (_1 )) |>> fun (_ as _3)   -> (_1,_2,_3 ))))) <|> (set_localvar  |>> fun (_ as _1)   -> (_1 ))

 and private set_localvar   = (attempt (Lexer.literal SET >>= fun (_  as _1) ->((attempt (Lexer.pLOCALVAR >>= fun (_  as _1) ->(opt ( attempt(Lexer.pDOUBLE_COLON >>= fun (_  as _1) ->(ident  |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _2) ->(Lexer.literal = >>= fun (_  as _3) ->(sql_expr  |>> fun (_ as _4)   -> (_1,_2,_3,_4 )))))) <|> (Lexer.pSTRING_CONST >>= fun (_  as _1) ->((attempt (Lexer.literal . |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.pDOUBLE_COLON |>> fun (_ as _1)   -> (_1 )) >>= fun (_  as _2) ->(ident  >>= fun (_  as _3) ->(Lexer.literal ( >>= fun (_  as _4) ->(yard_rule_comma_list_3  >>= fun (_  as _5) ->(Lexer.literal ) |>> fun (_ as _6)   -> (_1,_2,_3,_4,_5,_6 ))))))) |>> fun (_ as _2)   -> (_1,_2 )))) <|> ((attempt (Lexer.pLOCALVAR >>= fun (_  as _1) ->(Lexer.literal = >>= fun (_  as _2) ->(Lexer.pLOCALVAR |>> fun (_ as _3)   -> (_1,_2,_3 ))))) <|> ((attempt (ident  |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal CURSOR >>= fun (_  as _1) ->(opt ( attempt((attempt (Lexer.literal FORWARD_ONLY |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal SCROLL |>> fun (_ as _1)   -> (_1 )))) >>= fun (_  as _2) ->(opt ( attempt((attempt (Lexer.literal STATIC |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal KEYSET |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal DYNAMIC |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal FAST_FORWARD |>> fun (_ as _1)   -> (_1 )))))) >>= fun (_  as _3) ->(opt ( attempt((attempt (Lexer.literal READ_ONLY |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal SCROLL_LOCKS |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal OPTIMISTIC |>> fun (_ as _1)   -> (_1 ))))) >>= fun (_  as _4) ->(opt ( attempt(Lexer.literal TYPE_WARNING)) >>= fun (_  as _5) ->(Lexer.literal FOR >>= fun (_  as _6) ->(select_stmnt  >>= fun (_  as _7) ->(opt ( attempt(Lexer.literal FOR >>= fun (_  as _1) ->((attempt (Lexer.literal READ >>= fun (_  as _1) ->(Lexer.literal ONLY |>> fun (_ as _2)   -> (_1,_2 )))) <|> (Lexer.literal UPDATE >>= fun (_  as _1) ->(opt ( attempt(Lexer.literal OF >>= fun (_  as _1) ->(yard_rule_comma_list_5  |>> fun (_ as _2)   -> (_1,_2 )))) |>> fun (_ as _2)   -> (_1,_2 ))) |>> fun (_ as _2)   -> (_1,_2 )))) |>> fun (_ as _8)   -> (_1,_2,_3,_4,_5,_6,_7,_8 )))))))))))

 and private yard_rule_comma_list_3   = yard_rule_list_4  |>> fun (_ as _1)   -> (_1 )

 and private yard_rule_list_4   = (attempt (preturn  [] )) <|> (proc_formal_param  >>= fun (hd ) -> (many ( attempt(Lexer.literal , >>= fun (_  as _1) ->(proc_formal_param  |>> fun (_ as _2)   -> (_2 )))) |>> fun (tl) -> (hd::tl) )  )

 and private yard_rule_comma_list_5   = yard_rule_list_6  |>> fun (_ as _1)   -> (_1 )

 and private yard_rule_list_6   = (attempt (preturn  [] )) <|> (ident  >>= fun (hd ) -> (many ( attempt(Lexer.literal , >>= fun (_  as _1) ->(ident  |>> fun (_ as _2)   -> (_2 )))) |>> fun (tl) -> (hd::tl) )  )

 and private drop_procedure   = Lexer.literal DROP >>= fun (_  as _1) ->((attempt (Lexer.literal PROC |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal PROCEDURE |>> fun (_ as _1)   -> (_1 )) >>= fun (_  as _2) ->(many1 ( attempt(opt ( attempt(ident  >>= fun (_  as _1) ->(Lexer.literal . |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _1) ->(ident  |>> fun (_ as _2)   -> (_1,_2 )))) |>> fun (_ as _3)   -> (_1,_2,_3 )))

 and private proc_formal_param   = Lexer.pLOCALVAR >>= fun (_  as _1) ->(opt ( attempt(full_ident  >>= fun (_  as _1) ->(Lexer.literal . |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _2) ->(opt ( attempt(sql_datatype )) >>= fun (_  as _3) ->(opt ( attempt(Lexer.literal VARYING |>> fun (_ as _1)   -> (_1 ))) >>= fun (_  as _4) ->(opt ( attempt(Lexer.literal = >>= fun (_  as _1) ->((attempt (Lexer.literal NULL |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.pDEC_NUMBER |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.pSTRING_CONST |>> fun (_ as _1)   -> (_1 ))) |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _5) ->(opt ( attempt((attempt (Lexer.literal OUT |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal OUTPUT |>> fun (_ as _1)   -> (_1 )))) >>= fun (_  as _6) ->(opt ( attempt(Lexer.literal READONLY)) |>> fun (_ as _7)   -> (_1,_2,_3,_4,_5,_6,_7 )))))))

 and private create_proc   = Lexer.literal CREATE >>= fun (_  as _1) ->((attempt (Lexer.literal PROCEDURE |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal PROC |>> fun (_ as _1)   -> (_1 )) >>= fun (_  as _2) ->(opt ( attempt(ident  >>= fun (_  as _1) ->(Lexer.literal . |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _3) ->(ident  >>= fun (_  as _4) ->(opt ( attempt(Lexer.literal ; >>= fun (_  as _1) ->(Lexer.pDEC_NUMBER |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _5) ->(yard_rule_brace_opt_7  >>= fun (_  as _6) ->(opt ( attempt(Lexer.literal WITH >>= fun (_  as _1) ->(many1 ( attempt(execute_as  |>> fun (_ as _1)   -> (_1 ))) |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _7) ->(opt ( attempt(Lexer.literal FOR >>= fun (_  as _1) ->(Lexer.literal REPLICATION |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _8) ->(Lexer.literal AS >>= fun (_  as _9) ->(many ( attempt(proc_body_stmnt  >>= fun (_  as _1) ->(opt ( attempt(Lexer.literal ;)) |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _10) ->(opt ( attempt(Lexer.literal ;)) |>> fun (_ as _11)   -> (_1,_2,_3,_4,_5,_6,_7,_8,_9,_10,_11 )))))))))))

 and private yard_rule_brace_opt_7   = (attempt (yard_rule_comma_list_3  |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal ( >>= fun (_  as _1) ->(yard_rule_comma_list_3  >>= fun (_  as _2) ->(Lexer.literal ) |>> fun (_ as _3)   -> (_2 ))))

 and private procedure_option   = opt ( attempt((attempt (Lexer.literal ENCRYPTION |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal RECOMPILE |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal EXECUTE_AS_Clause |>> fun (_ as _1)   -> (_1 ))))) |>> fun (_ as _1)   -> (_1 )

 and private proc_body_stmnt   = (attempt (select_stmnt  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (set_stmnt  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (execute_stmnt  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (declare  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal RETURN >>= fun (_  as _1) ->(sql_expr  |>> fun (_ as _2)   -> (_1,_2 )))) <|> ((attempt (if_stmt  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (raiserror_stmnt  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (stmt_block  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (begin_transaction  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (commit_transaction  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (rollback_transaction  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (drop_procedure  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (while_stmt  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (create_table  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (insert  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (fetch_stmnt  |>> fun (_ as _1)   -> (_1 ))) <|> (print_stmt  |>> fun (_ as _1)   -> (_1 )))))))))))))))))

 and private print_stmt   = Lexer.literal PRINT >>= fun (_  as _1) ->(sql_expr  >>= fun (_  as _2) ->(opt ( attempt(Lexer.literal ;)) |>> fun (_ as _3)   -> (_1,_2,_3 )))

 and private while_stmt   = Lexer.literal WHILE >>= fun (_  as _1) ->(sql_expr  >>= fun (_  as _2) ->(proc_body_stmnt  |>> fun (_ as _3)   -> (_1,_2,_3 )))

 and private stmt_block   = Lexer.literal BEGIN >>= fun (_  as _1) ->(many ( attempt(proc_body_stmnt  >>= fun (_  as _1) ->(opt ( attempt(Lexer.literal ;)) |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _2) ->(Lexer.literal END |>> fun (_ as _3)   -> (_1,_2,_3 )))

 and private if_stmt   = Lexer.literal IF >>= fun (_  as _1) ->(sql_expr  >>= fun (_  as _2) ->(proc_body_stmnt  >>= fun (_  as _3) ->(opt ( attempt(Lexer.literal ELSE >>= fun (_  as _1) ->(proc_body_stmnt  |>> fun (_ as _2)   -> (_1,_2 )))) |>> fun (_ as _4)   -> (_1,_2,_3,_4 ))))

 and private raiserror_stmnt   = Lexer.literal RAISERROR >>= fun (_  as _1) ->(Lexer.literal ( >>= fun (_  as _2) ->((attempt (dec_num  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.pSTRING_CONST |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.pLOCALVAR |>> fun (_ as _1)   -> (_1 ))) >>= fun (_  as _3) ->(Lexer.literal , >>= fun (_  as _1) ->(dec_num  >>= fun (_  as _2) ->(Lexer.literal , >>= fun (_  as _3) ->(dec_num  |>> fun (_ as _4)   -> (_1,_2,_3,_4 )))) >>= fun (_  as _4) ->(opt ( attempt(Lexer.literal , >>= fun (_  as _1) ->(yard_rule_comma_list_8  |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _5) ->(Lexer.literal ) >>= fun (_  as _6) ->(opt ( attempt(Lexer.literal WITH >>= fun (_  as _1) ->(yard_rule_comma_list_10  |>> fun (_ as _2)   -> (_1,_2 )))) |>> fun (_ as _7)   -> (_1,_2,_3,_4,_5,_6,_7 )))))))

 and private yard_rule_comma_list_10   = yard_rule_list_11  |>> fun (_ as _1)   -> (_1 )

 and private yard_rule_list_11   = (attempt (preturn  [] )) <|> ((attempt (Lexer.literal LOG |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal NOWAIT |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal SETERROR |>> fun (_ as _1)   -> (_1 ))) >>= fun (hd ) -> (many ( attempt(Lexer.literal , >>= fun (_  as _1) ->((attempt (Lexer.literal LOG |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal NOWAIT |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal SETERROR |>> fun (_ as _1)   -> (_1 ))) |>> fun (_ as _2)   -> (_2 )))) |>> fun (tl) -> (hd::tl) )  )

 and private yard_rule_comma_list_8   = yard_rule_list_9  |>> fun (_ as _1)   -> (_1 )

 and private yard_rule_list_9   = (attempt (preturn  [] )) <|> (sql_expr  >>= fun (hd ) -> (many ( attempt(Lexer.literal , >>= fun (_  as _1) ->(sql_expr  |>> fun (_ as _2)   -> (_2 )))) |>> fun (tl) -> (hd::tl) )  )

 and private declare   = Lexer.literal DECLARE >>= fun (_  as _1) ->(yard_rule_comma_list_12  >>= fun (_  as _2) ->(opt ( attempt(Lexer.literal ;)) |>> fun (_ as _3)   -> (_1,_2,_3 )))

 and private yard_rule_comma_list_12   = yard_rule_list_13  |>> fun (_ as _1)   -> (_1 )

 and private yard_rule_list_13   = (attempt (preturn  [] )) <|> ((attempt (Lexer.pLOCALVAR >>= fun (_  as _1) ->(opt ( attempt(Lexer.literal AS)) >>= fun (_  as _2) ->(sql_datatype  |>> fun (_ as _3)   -> (_1,_2,_3 ))))) <|> ((attempt (ident  >>= fun (_  as _1) ->(Lexer.literal CURSOR >>= fun (_  as _2) ->(opt ( attempt(Lexer.literal LOCAL)) >>= fun (_  as _3) ->(opt ( attempt(Lexer.literal STATIC)) >>= fun (_  as _4) ->(opt ( attempt(Lexer.literal FOR)) >>= fun (_  as _5) ->(sql_expr  |>> fun (_ as _6)   -> (_1,_2,_3,_4,_5,_6 )))))))) <|> (ident  >>= fun (_  as _1) ->(opt ( attempt(Lexer.literal AS)) >>= fun (_  as _2) ->(table_type_definition  |>> fun (_ as _3)   -> (_1,_2,_3 ))))) >>= fun (hd ) -> (many ( attempt(Lexer.literal , >>= fun (_  as _1) ->((attempt (Lexer.pLOCALVAR >>= fun (_  as _1) ->(opt ( attempt(Lexer.literal AS)) >>= fun (_  as _2) ->(sql_datatype  |>> fun (_ as _3)   -> (_1,_2,_3 ))))) <|> ((attempt (ident  >>= fun (_  as _1) ->(Lexer.literal CURSOR >>= fun (_  as _2) ->(opt ( attempt(Lexer.literal LOCAL)) >>= fun (_  as _3) ->(opt ( attempt(Lexer.literal STATIC)) >>= fun (_  as _4) ->(opt ( attempt(Lexer.literal FOR)) >>= fun (_  as _5) ->(sql_expr  |>> fun (_ as _6)   -> (_1,_2,_3,_4,_5,_6 )))))))) <|> (ident  >>= fun (_  as _1) ->(opt ( attempt(Lexer.literal AS)) >>= fun (_  as _2) ->(table_type_definition  |>> fun (_ as _3)   -> (_1,_2,_3 ))))) |>> fun (_ as _2)   -> (_2 )))) |>> fun (tl) -> (hd::tl) )  )

 and private table_type_definition   = Lexer.literal TABLE >>= fun (_  as _1) ->(Lexer.literal ( >>= fun (_  as _2) ->(many ( attempt((attempt (column_definition  |>> fun (_ as _1)   -> (_1 ))) <|> (table_constraint  |>> fun (_ as _1)   -> (_1 )))) >>= fun (_  as _3) ->(Lexer.literal ) |>> fun (_ as _4)   -> (_1,_2,_3,_4 ))))

 and private column_definition   = ident  >>= fun (_  as _1) ->((attempt (Lexer.literal scalar_data_type |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal AS >>= fun (_  as _1) ->(sql_expr  |>> fun (_ as _2)   -> (_1,_2 ))) >>= fun (_  as _2) ->(opt ( attempt(Lexer.literal COLLATE >>= fun (_  as _1) ->(ident  |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _3) ->(opt ( attempt((attempt (Lexer.literal DEFAULT >>= fun (_  as _1) ->(sql_expr  |>> fun (_ as _2)   -> (_1,_2 )))) <|> (Lexer.literal IDENTITY >>= fun (_  as _1) ->(opt ( attempt(Lexer.pDEC_NUMBER >>= fun (_  as _1) ->(Lexer.literal , >>= fun (_  as _2) ->(Lexer.pDEC_NUMBER |>> fun (_ as _3)   -> (_1,_2,_3 ))))) |>> fun (_ as _2)   -> (_1,_2 ))))) >>= fun (_  as _4) ->(opt ( attempt(Lexer.literal ROWGUIDCOL)) >>= fun (_  as _5) ->(opt ( attempt(column_constraint )) |>> fun (_ as _6)   -> (_1,_2,_3,_4,_5,_6 ))))))

 and private column_constraint   = opt ( attempt((attempt (opt ( attempt(Lexer.literal NOT |>> fun (_ as _1)   -> (_1 ))) >>= fun (_  as _1) ->(Lexer.literal NULL |>> fun (_ as _2)   -> (_1,_2 )))) <|> ((attempt (Lexer.literal PRIMARY >>= fun (_  as _1) ->(Lexer.literal KEY |>> fun (_ as _2)   -> (_1,_2 )))) <|> ((attempt (Lexer.literal UNIQUE |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal CHECK >>= fun (_  as _1) ->(sql_expr  |>> fun (_ as _2)   -> (_1,_2 ))))))) |>> fun (_ as _1)   -> (_1 )

 and private table_constraint   = (attempt ((attempt (Lexer.literal PRIMARY >>= fun (_  as _1) ->(Lexer.literal KEY |>> fun (_ as _2)   -> (_1,_2 )))) <|> (Lexer.literal UNIQUE |>> fun (_ as _1)   -> (_1 )) >>= fun (_  as _1) ->(Lexer.literal ( >>= fun (_  as _2) ->(yard_rule_comma_list_5  >>= fun (_  as _3) ->(Lexer.literal ) |>> fun (_ as _4)   -> (_1,_2,_3,_4 )))))) <|> (Lexer.literal CHECK >>= fun (_  as _1) ->(Lexer.literal ( >>= fun (_  as _2) ->(search_condition  >>= fun (_  as _3) ->(Lexer.literal ) |>> fun (_ as _4)   -> (_1,_2,_3,_4 )))))

 and private select_stmnt   = opt ( attempt(Lexer.literal WITH >>= fun (_  as _1) ->(yard_rule_comma_list_14  |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _1) ->(query_expression  >>= fun (_  as _2) ->(opt ( attempt(Lexer.literal ORDER >>= fun (_  as _1) ->(Lexer.literal BY >>= fun (_  as _2) ->(yard_rule_comma_list_16  |>> fun (_ as _3)   -> (_1,_2,_3 ))))) >>= fun (_  as _3) ->(opt ( attempt(Lexer.literal COMPUTE >>= fun (_  as _1) ->(yard_rule_comma_list_18  >>= fun (_  as _2) ->(opt ( attempt(Lexer.literal BY >>= fun (_  as _1) ->(yard_rule_comma_list_8  |>> fun (_ as _2)   -> (_1,_2 )))) |>> fun (_ as _3)   -> (_1,_2,_3 ))))) >>= fun (_  as _4) ->(opt ( attempt(for )) >>= fun (_  as _5) ->(opt ( attempt(Lexer.literal OPTION >>= fun (_  as _1) ->(Lexer.literal ( >>= fun (_  as _2) ->(yard_rule_comma_list_20  >>= fun (_  as _3) ->(Lexer.literal ) |>> fun (_ as _4)   -> (_1,_2,_3,_4 )))))) >>= fun (_  as _6) ->(opt ( attempt(Lexer.literal ;)) |>> fun (_ as _7)   -> (_1,_2,_3,_4,_5,_6,_7 )))))))

 and private yard_rule_comma_list_20   = yard_rule_list_21  |>> fun (_ as _1)   -> (_1 )

 and private yard_rule_list_21   = (attempt (preturn  [] )) <|> (query_hint  >>= fun (hd ) -> (many ( attempt(Lexer.literal , >>= fun (_  as _1) ->(query_hint  |>> fun (_ as _2)   -> (_2 )))) |>> fun (tl) -> (hd::tl) )  )

 and private yard_rule_comma_list_18   = yard_rule_list_19  |>> fun (_ as _1)   -> (_1 )

 and private yard_rule_list_19   = (attempt (preturn  [] )) <|> ((attempt (Lexer.literal AVG |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal COUNT |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal MAX |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal MIN |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal SUM |>> fun (_ as _1)   -> (_1 ))))) >>= fun (_  as _1) ->(sql_expr  |>> fun (_ as _2)   -> (_1,_2 )) >>= fun (hd ) -> (many ( attempt(Lexer.literal , >>= fun (_  as _1) ->((attempt (Lexer.literal AVG |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal COUNT |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal MAX |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal MIN |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal SUM |>> fun (_ as _1)   -> (_1 ))))) >>= fun (_  as _1) ->(sql_expr  |>> fun (_ as _2)   -> (_1,_2 )) |>> fun (_ as _2)   -> (_2 )))) |>> fun (tl) -> (hd::tl) )  )

 and private yard_rule_comma_list_16   = yard_rule_list_17  |>> fun (_ as _1)   -> (_1 )

 and private yard_rule_list_17   = (attempt (preturn  [] )) <|> ((attempt (ident  |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.pDEC_NUMBER |>> fun (_ as _1)   -> (_1 )) >>= fun (_  as _1) ->(opt ( attempt((attempt (Lexer.literal ASC |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal DESC |>> fun (_ as _1)   -> (_1 )))) |>> fun (_ as _2)   -> (_1,_2 )) >>= fun (hd ) -> (many ( attempt(Lexer.literal , >>= fun (_  as _1) ->((attempt (ident  |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.pDEC_NUMBER |>> fun (_ as _1)   -> (_1 )) >>= fun (_  as _1) ->(opt ( attempt((attempt (Lexer.literal ASC |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal DESC |>> fun (_ as _1)   -> (_1 )))) |>> fun (_ as _2)   -> (_1,_2 )) |>> fun (_ as _2)   -> (_2 )))) |>> fun (tl) -> (hd::tl) )  )

 and private yard_rule_comma_list_14   = yard_rule_list_15  |>> fun (_ as _1)   -> (_1 )

 and private yard_rule_list_15   = (attempt (preturn  [] )) <|> (common_table_expression  >>= fun (hd ) -> (many ( attempt(Lexer.literal , >>= fun (_  as _1) ->(common_table_expression  |>> fun (_ as _2)   -> (_2 )))) |>> fun (tl) -> (hd::tl) )  )

 and private for   = Lexer.literal FOR >>= fun (_  as _1) ->((attempt (Lexer.literal BROWSE |>> fun (_ as _1)   -> (_1 ))) <|> (xml  |>> fun (_ as _1)   -> (_1 )) |>> fun (_ as _2)   -> (_1,_2 ))

 and private xml   = Lexer.literal XML >>= fun (_  as _1) ->((attempt ((attempt (Lexer.literal RAW >>= fun (_  as _1) ->(opt ( attempt(Lexer.literal ( >>= fun (_  as _1) ->(Lexer.pSTRING_CONST >>= fun (_  as _2) ->(Lexer.literal ) |>> fun (_ as _3)   -> (_1,_2,_3 ))))) |>> fun (_ as _2)   -> (_1,_2 )))) <|> (Lexer.literal AUTO |>> fun (_ as _1)   -> (_1 )) >>= fun (_  as _1) ->(opt ( attempt(common_directives  >>= fun (_  as _1) ->(opt ( attempt(Lexer.literal , >>= fun (_  as _1) ->((attempt (Lexer.literal XMLDATA |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal XMLSCHEMA >>= fun (_  as _1) ->(opt ( attempt(Lexer.literal ( >>= fun (_  as _1) ->(Lexer.pSTRING_CONST >>= fun (_  as _2) ->(Lexer.literal ) |>> fun (_ as _3)   -> (_1,_2,_3 ))))) |>> fun (_ as _2)   -> (_1,_2 ))) |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _2) ->(opt ( attempt(Lexer.literal , >>= fun (_  as _1) ->(Lexer.literal ELEMENTS >>= fun (_  as _2) ->(opt ( attempt((attempt (Lexer.literal XSINIL |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal ABSENT |>> fun (_ as _1)   -> (_1 )))) |>> fun (_ as _3)   -> (_1,_2,_3 ))))) |>> fun (_ as _3)   -> (_1,_2,_3 ))))) |>> fun (_ as _2)   -> (_1,_2 )))) <|> ((attempt (Lexer.literal EXPLICIT >>= fun (_  as _1) ->(opt ( attempt(common_directives  >>= fun (_  as _1) ->(opt ( attempt(Lexer.literal , >>= fun (_  as _1) ->(Lexer.literal XMLDATA |>> fun (_ as _2)   -> (_1,_2 )))) |>> fun (_ as _2)   -> (_1,_2 )))) |>> fun (_ as _2)   -> (_1,_2 )))) <|> (Lexer.literal PATH >>= fun (_  as _1) ->(opt ( attempt(Lexer.literal ( >>= fun (_  as _1) ->(Lexer.pSTRING_CONST >>= fun (_  as _2) ->(Lexer.literal ) |>> fun (_ as _3)   -> (_1,_2,_3 ))))) >>= fun (_  as _2) ->(opt ( attempt(common_directives  >>= fun (_  as _1) ->(opt ( attempt(Lexer.literal , >>= fun (_  as _1) ->(Lexer.literal ELEMENTS >>= fun (_  as _2) ->(opt ( attempt((attempt (Lexer.literal XSINIL |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal ABSENT |>> fun (_ as _1)   -> (_1 )))) |>> fun (_ as _3)   -> (_1,_2,_3 ))))) |>> fun (_ as _2)   -> (_1,_2 )))) |>> fun (_ as _3)   -> (_1,_2,_3 ))))) |>> fun (_ as _2)   -> (_1,_2 ))

 and private common_directives   = opt ( attempt(Lexer.literal , >>= fun (_  as _1) ->(Lexer.literal BINARY >>= fun (_  as _2) ->(Lexer.literal BASE64 |>> fun (_ as _3)   -> (_1,_2,_3 ))))) >>= fun (_  as _1) ->(opt ( attempt(Lexer.literal , >>= fun (_  as _1) ->(Lexer.literal TYPE |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _2) ->(opt ( attempt(Lexer.literal , >>= fun (_  as _1) ->(Lexer.literal ROOT >>= fun (_  as _2) ->(opt ( attempt(Lexer.literal ( >>= fun (_  as _1) ->(Lexer.pSTRING_CONST >>= fun (_  as _2) ->(Lexer.literal ) |>> fun (_ as _3)   -> (_1,_2,_3 ))))) |>> fun (_ as _3)   -> (_1,_2,_3 ))))) |>> fun (_ as _3)   -> (_1,_2,_3 )))

 and private query_hint   = (attempt ((attempt (Lexer.literal HASH |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal ORDER |>> fun (_ as _1)   -> (_1 )) >>= fun (_  as _1) ->(Lexer.literal GROUP |>> fun (_ as _2)   -> (_1,_2 )))) <|> ((attempt ((attempt (Lexer.literal CONCAT |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal HASH |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal MERGE |>> fun (_ as _1)   -> (_1 ))) >>= fun (_  as _1) ->(Lexer.literal UNION |>> fun (_ as _2)   -> (_1,_2 )))) <|> ((attempt ((attempt (Lexer.literal LOOP |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal MERGE |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal HASH |>> fun (_ as _1)   -> (_1 ))) >>= fun (_  as _1) ->(Lexer.literal JOIN |>> fun (_ as _2)   -> (_1,_2 )))) <|> ((attempt (Lexer.literal FAST >>= fun (_  as _1) ->(Lexer.pDEC_NUMBER |>> fun (_ as _2)   -> (_1,_2 )))) <|> ((attempt (Lexer.literal FORCE >>= fun (_  as _1) ->(Lexer.literal ORDER |>> fun (_ as _2)   -> (_1,_2 )))) <|> ((attempt (Lexer.literal MAXDOP >>= fun (_  as _1) ->(Lexer.pDEC_NUMBER |>> fun (_ as _2)   -> (_1,_2 )))) <|> ((attempt (Lexer.literal OPTIMIZE >>= fun (_  as _1) ->(Lexer.literal FOR >>= fun (_  as _2) ->(Lexer.literal ( >>= fun (_  as _3) ->(yard_rule_comma_list_22  >>= fun (_  as _4) ->(Lexer.literal ) |>> fun (_ as _5)   -> (_1,_2,_3,_4,_5 ))))))) <|> ((attempt (Lexer.literal PARAMETERIZATION >>= fun (_  as _1) ->((attempt (Lexer.literal SIMPLE |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal FORCED |>> fun (_ as _1)   -> (_1 )) |>> fun (_ as _2)   -> (_1,_2 )))) <|> ((attempt (Lexer.literal RECOMPILE |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal ROBUST >>= fun (_  as _1) ->(Lexer.literal PLAN |>> fun (_ as _2)   -> (_1,_2 )))) <|> ((attempt (Lexer.literal KEEP >>= fun (_  as _1) ->(Lexer.literal PLAN |>> fun (_ as _2)   -> (_1,_2 )))) <|> ((attempt (Lexer.literal KEEPFIXED >>= fun (_  as _1) ->(Lexer.literal PLAN |>> fun (_ as _2)   -> (_1,_2 )))) <|> ((attempt (Lexer.literal EXPAND >>= fun (_  as _1) ->(Lexer.literal VIEWS |>> fun (_ as _2)   -> (_1,_2 )))) <|> ((attempt (Lexer.literal MAXRECURSION >>= fun (_  as _1) ->(Lexer.pDEC_NUMBER |>> fun (_ as _2)   -> (_1,_2 )))) <|> (Lexer.literal USE >>= fun (_  as _1) ->(Lexer.literal PLAN >>= fun (_  as _2) ->(Lexer.pSTRING_CONST |>> fun (_ as _3)   -> (_1,_2,_3 )))))))))))))))))

 and private yard_rule_comma_list_22   = yard_rule_list_23  |>> fun (_ as _1)   -> (_1 )

 and private yard_rule_list_23   = (attempt (preturn  [] )) <|> (Lexer.pLOCALVAR >>= fun (_  as _1) ->(Lexer.literal = >>= fun (_  as _2) ->(Lexer.pSTRING_CONST |>> fun (_ as _3)   -> (_1,_2,_3 ))) >>= fun (hd ) -> (many ( attempt(Lexer.literal , >>= fun (_  as _1) ->(Lexer.pLOCALVAR >>= fun (_  as _1) ->(Lexer.literal = >>= fun (_  as _2) ->(Lexer.pSTRING_CONST |>> fun (_ as _3)   -> (_1,_2,_3 ))) |>> fun (_ as _2)   -> (_2 )))) |>> fun (tl) -> (hd::tl) )  )

 and private common_table_expression   = (attempt (full_ident  |>> fun (_ as _1)   -> (_1 ))) <|> (ident  |>> fun (_ as _1)   -> (_1 )) >>= fun (_  as _1) ->(opt ( attempt(Lexer.literal ( >>= fun (_  as _1) ->(yard_rule_comma_list_5  >>= fun (_  as _2) ->(Lexer.literal ) |>> fun (_ as _3)   -> (_1,_2,_3 ))))) >>= fun (_  as _2) ->(Lexer.literal AS >>= fun (_  as _3) ->(Lexer.literal ( >>= fun (_  as _4) ->(select_stmnt  >>= fun (_  as _5) ->(Lexer.literal ) >>= fun (_  as _6) ->(opt ( attempt(Lexer.literal ;)) |>> fun (_ as _7)   -> (_1,_2,_3,_4,_5,_6,_7 )))))))

 and private query_expression   = (attempt (query_specification  |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal ( >>= fun (_  as _1) ->(query_expression  >>= fun (_  as _2) ->(Lexer.literal ) |>> fun (_ as _3)   -> (_1,_2,_3 )))) >>= fun (_  as _1) ->(opt ( attempt((attempt ((attempt (Lexer.literal UNION >>= fun (_  as _1) ->(opt ( attempt(Lexer.literal ALL)) |>> fun (_ as _2)   -> (_1,_2 )))) <|> ((attempt (Lexer.literal EXCEPT |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal INTERSECT |>> fun (_ as _1)   -> (_1 ))) >>= fun (_  as _1) ->(query_specification  |>> fun (_ as _2)   -> (_1,_2 )))) <|> (yard_rule_comma_list_24  |>> fun (_ as _1)   -> (_1 )))) |>> fun (_ as _2)   -> (_1,_2 ))

 and private yard_rule_comma_list_24   = yard_rule_list_25  |>> fun (_ as _1)   -> (_1 )

 and private yard_rule_list_25   = (attempt (preturn  [] )) <|> (Lexer.literal ( >>= fun (_  as _1) ->(query_expression  >>= fun (_  as _2) ->(Lexer.literal ) |>> fun (_ as _3)   -> (_1,_2,_3 ))) >>= fun (hd ) -> (many ( attempt(Lexer.literal , >>= fun (_  as _1) ->(Lexer.literal ( >>= fun (_  as _1) ->(query_expression  >>= fun (_  as _2) ->(Lexer.literal ) |>> fun (_ as _3)   -> (_1,_2,_3 ))) |>> fun (_ as _2)   -> (_2 )))) |>> fun (tl) -> (hd::tl) )  )

 and private query_specification   = Lexer.literal SELECT >>= fun (_  as _1) ->(opt ( attempt((attempt (Lexer.literal ALL |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal DISTINCT |>> fun (_ as _1)   -> (_1 )))) >>= fun (_  as _2) ->(opt ( attempt(Lexer.literal TOP >>= fun (_  as _1) ->(sql_expr  >>= fun (_  as _2) ->(opt ( attempt(Lexer.literal PERCENT)) >>= fun (_  as _3) ->(opt ( attempt(Lexer.literal WITH >>= fun (_  as _1) ->(Lexer.literal TIES |>> fun (_ as _2)   -> (_1,_2 )))) |>> fun (_ as _4)   -> (_1,_2,_3,_4 )))))) >>= fun (_  as _3) ->(select_list  >>= fun (_  as _4) ->(opt ( attempt(Lexer.literal INTO >>= fun (_  as _1) ->(full_ident  |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _5) ->(opt ( attempt(from )) >>= fun (_  as _6) ->(opt ( attempt(Lexer.literal WHERE >>= fun (_  as _1) ->(search_condition  |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _7) ->(opt ( attempt(Lexer.literal GROUP >>= fun (_  as _1) ->(Lexer.literal BY >>= fun (_  as _2) ->(opt ( attempt(Lexer.literal ALL)) >>= fun (_  as _3) ->(yard_rule_comma_list_8  >>= fun (_  as _4) ->(opt ( attempt(Lexer.literal WITH >>= fun (_  as _1) ->((attempt (Lexer.literal CUBE |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal ROLLUP |>> fun (_ as _1)   -> (_1 )) |>> fun (_ as _2)   -> (_1,_2 )))) |>> fun (_ as _5)   -> (_1,_2,_3,_4,_5 ))))))) >>= fun (_  as _8) ->(opt ( attempt(Lexer.literal HAVING >>= fun (_  as _1) ->(search_condition  |>> fun (_ as _2)   -> (_1,_2 )))) |>> fun (_ as _9)   -> (_1,_2,_3,_4,_5,_6,_7,_8,_9 )))))))))

 and private select_list   = yard_rule_comma_list_26  |>> fun (_ as _1)   -> (_1 )

 and private yard_rule_comma_list_26   = yard_rule_list_27  |>> fun (_ as _1)   -> (_1 )

 and private yard_rule_list_27   = (attempt (preturn  [] )) <|> ((attempt (Lexer.literal * |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (full_ident  >>= fun (_  as _1) ->(Lexer.literal . >>= fun (_  as _2) ->(Lexer.literal * |>> fun (_ as _3)   -> (_1,_2,_3 ))))) <|> ((attempt ((attempt (opt ( attempt(ident  >>= fun (_  as _1) ->(Lexer.literal . |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _1) ->((attempt (ident  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal IDENTITY |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal ROWGUID |>> fun (_ as _1)   -> (_1 ))) >>= fun (_  as _2) ->(opt ( attempt((attempt (Lexer.literal . |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.pDOUBLE_COLON |>> fun (_ as _1)   -> (_1 )) >>= fun (_  as _1) ->((attempt (Lexer.pSTRING_CONST |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (ident  |>> fun (_ as _1)   -> (_1 ))) <|> (ident  >>= fun (_  as _1) ->(Lexer.literal ( >>= fun (_  as _2) ->(yard_rule_comma_list_8  >>= fun (_  as _3) ->(Lexer.literal ) |>> fun (_ as _4)   -> (_1,_2,_3,_4 )))))) |>> fun (_ as _2)   -> (_1,_2 )))) |>> fun (_ as _3)   -> (_1,_2,_3 ))))) <|> (sql_expr  >>= fun (_  as _1) ->(opt ( attempt(opt ( attempt(Lexer.literal AS)) >>= fun (_  as _1) ->(ident  |>> fun (_ as _2)   -> (_1,_2 )))) |>> fun (_ as _2)   -> (_1,_2 ))) |>> fun (_ as _1)   -> (_1 ))) <|> (ident  >>= fun (_  as _1) ->(Lexer.literal = >>= fun (_  as _2) ->(sql_expr  |>> fun (_ as _3)   -> (_1,_2,_3 )))))) >>= fun (hd ) -> (many ( attempt(Lexer.literal , >>= fun (_  as _1) ->((attempt (Lexer.literal * |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (full_ident  >>= fun (_  as _1) ->(Lexer.literal . >>= fun (_  as _2) ->(Lexer.literal * |>> fun (_ as _3)   -> (_1,_2,_3 ))))) <|> ((attempt ((attempt (opt ( attempt(ident  >>= fun (_  as _1) ->(Lexer.literal . |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _1) ->((attempt (ident  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal IDENTITY |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal ROWGUID |>> fun (_ as _1)   -> (_1 ))) >>= fun (_  as _2) ->(opt ( attempt((attempt (Lexer.literal . |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.pDOUBLE_COLON |>> fun (_ as _1)   -> (_1 )) >>= fun (_  as _1) ->((attempt (Lexer.pSTRING_CONST |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (ident  |>> fun (_ as _1)   -> (_1 ))) <|> (ident  >>= fun (_  as _1) ->(Lexer.literal ( >>= fun (_  as _2) ->(yard_rule_comma_list_8  >>= fun (_  as _3) ->(Lexer.literal ) |>> fun (_ as _4)   -> (_1,_2,_3,_4 )))))) |>> fun (_ as _2)   -> (_1,_2 )))) |>> fun (_ as _3)   -> (_1,_2,_3 ))))) <|> (sql_expr  >>= fun (_  as _1) ->(opt ( attempt(opt ( attempt(Lexer.literal AS)) >>= fun (_  as _1) ->(ident  |>> fun (_ as _2)   -> (_1,_2 )))) |>> fun (_ as _2)   -> (_1,_2 ))) |>> fun (_ as _1)   -> (_1 ))) <|> (ident  >>= fun (_  as _1) ->(Lexer.literal = >>= fun (_  as _2) ->(sql_expr  |>> fun (_ as _3)   -> (_1,_2,_3 )))))) |>> fun (_ as _2)   -> (_2 )))) |>> fun (tl) -> (hd::tl) )  )

 and private scalar_function   = (attempt (Lexer.literal LOWER >>= fun (_  as _1) ->(sql_expr  |>> fun (_ as _2)   -> (_1,_2 )))) <|> (Lexer.literal SUM >>= fun (_  as _1) ->(Lexer.literal ( >>= fun (_  as _2) ->(opt ( attempt((attempt (Lexer.literal ALL |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal DISTINCT |>> fun (_ as _1)   -> (_1 )))) >>= fun (_  as _3) ->(sql_expr  >>= fun (_  as _4) ->(Lexer.literal ) |>> fun (_ as _5)   -> (_1,_2,_3,_4,_5 ))))))

 and private aggregate_windowed_function   = Lexer.literal OVER >>= fun (_  as _1) ->(Lexer.literal ( >>= fun (_  as _2) ->(yard_rule_comma_list_28  >>= fun (_  as _3) ->(order_by_clause  >>= fun (_  as _4) ->(Lexer.literal ) |>> fun (_ as _5)   -> (_1,_2,_3,_4,_5 )))))

 and private yard_rule_comma_list_28   = yard_rule_list_29  |>> fun (_ as _1)   -> (_1 )

 and private yard_rule_list_29   = (attempt (preturn  [] )) <|> (opt ( attempt((attempt (Lexer.literal PARTITION >>= fun (_  as _1) ->(Lexer.literal BY >>= fun (_  as _2) ->(Lexer.pLOCALVAR |>> fun (_ as _3)   -> (_1,_2,_3 ))))) <|> (select_stmnt  |>> fun (_ as _1)   -> (_1 )))) >>= fun (hd ) -> (many ( attempt(Lexer.literal , >>= fun (_  as _1) ->(opt ( attempt((attempt (Lexer.literal PARTITION >>= fun (_  as _1) ->(Lexer.literal BY >>= fun (_  as _2) ->(Lexer.pLOCALVAR |>> fun (_ as _3)   -> (_1,_2,_3 ))))) <|> (select_stmnt  |>> fun (_ as _1)   -> (_1 )))) |>> fun (_ as _2)   -> (_2 )))) |>> fun (tl) -> (hd::tl) )  )

 and private ranking_windowed_function   = (attempt (Lexer.literal RANK |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal DENSE_RANK |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal ROW_NUMBER |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal NTILE |>> fun (_ as _1)   -> (_1 )))) >>= fun (_  as _1) ->(Lexer.literal ( >>= fun (_  as _2) ->(opt ( attempt(sql_expr )) >>= fun (_  as _3) ->(Lexer.literal ) >>= fun (_  as _4) ->(Lexer.literal OVER >>= fun (_  as _5) ->(Lexer.literal ( >>= fun (_  as _6) ->(opt ( attempt(many ( attempt((attempt (Lexer.literal PARTITION >>= fun (_  as _1) ->(Lexer.literal BY >>= fun (_  as _2) ->(Lexer.pLOCALVAR |>> fun (_ as _3)   -> (_1,_2,_3 ))))) <|> ((attempt (select_stmnt  |>> fun (_ as _1)   -> (_1 ))) <|> (full_ident  |>> fun (_ as _1)   -> (_1 ))))) |>> fun (_ as _1)   -> (_1 ))) >>= fun (_  as _7) ->(order_by_clause  >>= fun (_  as _8) ->(Lexer.literal ) |>> fun (_ as _9)   -> (_1,_2,_3,_4,_5,_6,_7,_8,_9 )))))))))

 and private order_by_clause   = opt ( attempt(Lexer.literal ORDER >>= fun (_  as _1) ->(Lexer.literal BY >>= fun (_  as _2) ->(yard_rule_comma_list_30  |>> fun (_ as _3)   -> (_1,_2,_3 ))))) |>> fun (_ as _1)   -> (_1 )

 and private yard_rule_comma_list_30   = yard_rule_list_31  |>> fun (_ as _1)   -> (_1 )

 and private yard_rule_list_31   = (attempt (preturn  [] )) <|> (sql_expr  >>= fun (_  as _1) ->(opt ( attempt((attempt (Lexer.literal ASC |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal DESC |>> fun (_ as _1)   -> (_1 )))) |>> fun (_ as _2)   -> (_1,_2 )) >>= fun (hd ) -> (many ( attempt(Lexer.literal , >>= fun (_  as _1) ->(sql_expr  >>= fun (_  as _1) ->(opt ( attempt((attempt (Lexer.literal ASC |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal DESC |>> fun (_ as _1)   -> (_1 )))) |>> fun (_ as _2)   -> (_1,_2 )) |>> fun (_ as _2)   -> (_2 )))) |>> fun (tl) -> (hd::tl) )  )

 and private search_condition   = (attempt (opt ( attempt(Lexer.literal NOT)) >>= fun (_  as _1) ->(predicate  |>> fun (_ as _2)   -> (_1,_2 )))) <|> (Lexer.literal ( >>= fun (_  as _1) ->(search_condition  >>= fun (_  as _2) ->(Lexer.literal ) |>> fun (_ as _3)   -> (_1,_2,_3 )))) >>= fun (_  as _1) ->(many ( attempt((attempt (Lexer.literal AND |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal OR |>> fun (_ as _1)   -> (_1 )) >>= fun (_  as _1) ->(opt ( attempt(Lexer.literal NOT)) >>= fun (_  as _2) ->((attempt (predicate  |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal ( >>= fun (_  as _1) ->(search_condition  >>= fun (_  as _2) ->(Lexer.literal ) |>> fun (_ as _3)   -> (_1,_2,_3 )))) |>> fun (_ as _3)   -> (_1,_2,_3 ))))) |>> fun (_ as _2)   -> (_1,_2 ))

 and private predicate   = (attempt (sql_expr  >>= fun (_  as _1) ->(opt ( attempt(Lexer.literal ESCAPE >>= fun (_  as _1) ->(Lexer.pSTRING_CONST |>> fun (_ as _2)   -> (_1,_2 )))) |>> fun (_ as _2)   -> (_1,_2 )))) <|> ((attempt (sql_expr  >>= fun (_  as _1) ->(opt ( attempt(Lexer.literal NOT)) >>= fun (_  as _2) ->(Lexer.literal BETWEEN >>= fun (_  as _3) ->(sql_expr  >>= fun (_  as _4) ->(Lexer.literal AND >>= fun (_  as _5) ->(sql_expr  |>> fun (_ as _6)   -> (_1,_2,_3,_4,_5,_6 )))))))) <|> ((attempt (sql_expr  >>= fun (_  as _1) ->(Lexer.literal IS >>= fun (_  as _2) ->(opt ( attempt(Lexer.literal NOT)) >>= fun (_  as _3) ->(Lexer.literal NULL |>> fun (_ as _4)   -> (_1,_2,_3,_4 )))))) <|> ((attempt (sql_expr  >>= fun (_  as _1) ->(binop  >>= fun (_  as _2) ->((attempt (Lexer.literal ALL |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal SOME |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal ANY |>> fun (_ as _1)   -> (_1 ))) >>= fun (_  as _3) ->(Lexer.literal ( >>= fun (_  as _4) ->(query_expression  >>= fun (_  as _5) ->(Lexer.literal ) |>> fun (_ as _6)   -> (_1,_2,_3,_4,_5,_6 )))))))) <|> ((attempt (Lexer.literal EXISTS >>= fun (_  as _1) ->(Lexer.literal ( >>= fun (_  as _2) ->(query_expression  >>= fun (_  as _3) ->(Lexer.literal ) |>> fun (_ as _4)   -> (_1,_2,_3,_4 )))))) <|> (Lexer.pIDENT >>= fun (_  as _1) ->(opt ( attempt(Lexer.literal . >>= fun (_  as _1) ->(Lexer.pIDENT |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _2) ->(opt ( attempt(Lexer.literal ( >>= fun (_  as _1) ->(Lexer.literal ) |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _3) ->(Lexer.literal IN >>= fun (_  as _4) ->(Lexer.literal ( >>= fun (_  as _5) ->((attempt (dec_num  |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.pSTRING_CONST |>> fun (_ as _1)   -> (_1 )) >>= fun (_  as _6) ->(Lexer.literal , >>= fun (_  as _7) ->((attempt (dec_num  |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.pSTRING_CONST |>> fun (_ as _1)   -> (_1 )) >>= fun (_  as _8) ->(Lexer.literal ) |>> fun (_ as _9)   -> (_1,_2,_3,_4,_5,_6,_7,_8,_9 ))))))))))))))

 and private from   = Lexer.literal FROM >>= fun (_  as _1) ->(yard_rule_comma_list_32  |>> fun (_ as _2)   -> (_1,_2 ))

 and private yard_rule_comma_list_32   = yard_rule_list_33  |>> fun (_ as _1)   -> (_1 )

 and private yard_rule_list_33   = (attempt (preturn  [] )) <|> (table_source  >>= fun (hd ) -> (many ( attempt(Lexer.literal , >>= fun (_  as _1) ->(table_source  |>> fun (_ as _2)   -> (_2 )))) |>> fun (tl) -> (hd::tl) )  )

 and private table_source   = (attempt (full_ident  >>= fun (_  as _1) ->(opt ( attempt(Lexer.literal AS)) >>= fun (_  as _2) ->(full_ident  >>= fun (_  as _3) ->(opt ( attempt(tablesample_clause )) >>= fun (_  as _4) ->(opt ( attempt(Lexer.literal WITH >>= fun (_  as _1) ->(Lexer.literal ( >>= fun (_  as _2) ->(table_hint  >>= fun (_  as _3) ->(many ( attempt(Lexer.literal ,)) >>= fun (_  as _4) ->(Lexer.literal ) |>> fun (_ as _5)   -> (_1,_2,_3,_4,_5 ))))))) |>> fun (_ as _5)   -> (_1,_2,_3,_4,_5 ))))))) <|> ((attempt ((attempt (rowset_function  |>> fun (_ as _1)   -> (_1 ))) <|> (sql_expr  |>> fun (_ as _1)   -> (_1 )) >>= fun (_  as _1) ->(opt ( attempt(opt ( attempt(Lexer.literal AS)) >>= fun (_  as _1) ->(ident  |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _2) ->(opt ( attempt(Lexer.literal ( >>= fun (_  as _1) ->(yard_rule_comma_list_5  >>= fun (_  as _2) ->(Lexer.literal ) |>> fun (_ as _3)   -> (_1,_2,_3 ))))) |>> fun (_ as _3)   -> (_1,_2,_3 ))))) <|> ((attempt (ident  >>= fun (_  as _1) ->(opt ( attempt(Lexer.literal AS)) >>= fun (_  as _2) ->(ident  >>= fun (_  as _3) ->(opt ( attempt(Lexer.literal ( >>= fun (_  as _1) ->(yard_rule_comma_list_5  >>= fun (_  as _2) ->(Lexer.literal ) |>> fun (_ as _3)   -> (_1,_2,_3 ))))) |>> fun (_ as _4)   -> (_1,_2,_3,_4 )))))) <|> ((attempt (joined_table  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (pivoted_table  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (unpivoted_table  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.pLOCALVAR >>= fun (_  as _1) ->(opt ( attempt(opt ( attempt(Lexer.literal AS)) >>= fun (_  as _1) ->(full_ident  |>> fun (_ as _2)   -> (_1,_2 )))) |>> fun (_ as _2)   -> (_1,_2 )))) <|> (Lexer.pLOCALVAR >>= fun (_  as _1) ->(Lexer.literal . >>= fun (_  as _2) ->(ident  >>= fun (_  as _3) ->(Lexer.literal ( >>= fun (_  as _4) ->(yard_rule_comma_list_8  >>= fun (_  as _5) ->(Lexer.literal ) >>= fun (_  as _6) ->(opt ( attempt(Lexer.literal AS >>= fun (_  as _1) ->(ident  |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _7) ->(opt ( attempt(Lexer.literal ( >>= fun (_  as _1) ->(yard_rule_comma_list_5  >>= fun (_  as _2) ->(Lexer.literal ) |>> fun (_ as _3)   -> (_1,_2,_3 ))))) |>> fun (_ as _8)   -> (_1,_2,_3,_4,_5,_6,_7,_8 )))))))))))))))

 and private rowset_function   = (attempt (containstable  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (freetexttable  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (opendatasource  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (openquery  |>> fun (_ as _1)   -> (_1 ))) <|> (openrowset  |>> fun (_ as _1)   -> (_1 )))))

 and private openrowset   = Lexer.literal OPENROWSET >>= fun (_  as _1) ->(Lexer.literal ( >>= fun (_  as _2) ->((attempt (Lexer.pSTRING_CONST >>= fun (_  as _1) ->(Lexer.literal , >>= fun (_  as _2) ->((attempt (Lexer.pSTRING_CONST >>= fun (_  as _1) ->(Lexer.literal ; >>= fun (_  as _2) ->(Lexer.pSTRING_CONST >>= fun (_  as _3) ->(Lexer.literal ; >>= fun (_  as _4) ->(Lexer.pSTRING_CONST |>> fun (_ as _5)   -> (_1,_2,_3,_4,_5 ))))))) <|> (Lexer.pSTRING_CONST |>> fun (_ as _1)   -> (_1 )) >>= fun (_  as _3) ->(Lexer.literal , >>= fun (_  as _4) ->((attempt (opt ( attempt(opt ( attempt(full_ident  >>= fun (_  as _1) ->(Lexer.literal . |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _1) ->(full_ident  >>= fun (_  as _2) ->(Lexer.literal . |>> fun (_ as _3)   -> (_1,_2,_3 ))))) >>= fun (_  as _1) ->(full_ident  |>> fun (_ as _2)   -> (_1,_2 )))) <|> (Lexer.pSTRING_CONST |>> fun (_ as _1)   -> (_1 )) |>> fun (_ as _5)   -> (_1,_2,_3,_4,_5 ))))))) <|> (Lexer.literal BULK >>= fun (_  as _1) ->(Lexer.pSTRING_CONST >>= fun (_  as _2) ->(Lexer.literal , >>= fun (_  as _3) ->((attempt (Lexer.literal FORMATFILE >>= fun (_  as _1) ->(Lexer.literal = >>= fun (_  as _2) ->(Lexer.pSTRING_CONST >>= fun (_  as _3) ->(opt ( attempt(bulk_options )) |>> fun (_ as _4)   -> (_1,_2,_3,_4 )))))) <|> ((attempt (Lexer.literal SINGLE_BLOB |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal SINGLE_CLOB |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal SINGLE_NCLOB |>> fun (_ as _1)   -> (_1 )))) |>> fun (_ as _4)   -> (_1,_2,_3,_4 ))))) >>= fun (_  as _3) ->(Lexer.literal ) |>> fun (_ as _4)   -> (_1,_2,_3,_4 ))))

 and private bulk_options   = opt ( attempt(Lexer.literal , >>= fun (_  as _1) ->(Lexer.literal CODEPAGE >>= fun (_  as _2) ->(Lexer.literal = >>= fun (_  as _3) ->(Lexer.pSTRING_CONST |>> fun (_ as _4)   -> (_1,_2,_3,_4 )))))) >>= fun (_  as _1) ->(opt ( attempt(Lexer.literal , >>= fun (_  as _1) ->(Lexer.literal ERRORFILE >>= fun (_  as _2) ->(Lexer.literal = >>= fun (_  as _3) ->(Lexer.pSTRING_CONST |>> fun (_ as _4)   -> (_1,_2,_3,_4 )))))) >>= fun (_  as _2) ->(opt ( attempt(Lexer.literal , >>= fun (_  as _1) ->(Lexer.literal FIRSTROW >>= fun (_  as _2) ->(Lexer.literal = >>= fun (_  as _3) ->(Lexer.pDEC_NUMBER |>> fun (_ as _4)   -> (_1,_2,_3,_4 )))))) >>= fun (_  as _3) ->(opt ( attempt(Lexer.literal , >>= fun (_  as _1) ->(Lexer.literal LASTROW >>= fun (_  as _2) ->(Lexer.literal = >>= fun (_  as _3) ->(Lexer.pDEC_NUMBER |>> fun (_ as _4)   -> (_1,_2,_3,_4 )))))) >>= fun (_  as _4) ->(opt ( attempt(Lexer.literal , >>= fun (_  as _1) ->(Lexer.literal MAXERRORS >>= fun (_  as _2) ->(Lexer.literal = >>= fun (_  as _3) ->(Lexer.pDEC_NUMBER |>> fun (_ as _4)   -> (_1,_2,_3,_4 )))))) >>= fun (_  as _5) ->(opt ( attempt(Lexer.literal , >>= fun (_  as _1) ->(Lexer.literal ROWS_PER_BATCH >>= fun (_  as _2) ->(Lexer.literal = >>= fun (_  as _3) ->(Lexer.pDEC_NUMBER |>> fun (_ as _4)   -> (_1,_2,_3,_4 )))))) |>> fun (_ as _6)   -> (_1,_2,_3,_4,_5,_6 ))))))

 and private openquery   = Lexer.literal OPENQUERY >>= fun (_  as _1) ->(Lexer.literal ( >>= fun (_  as _2) ->(full_ident  >>= fun (_  as _3) ->(Lexer.literal , >>= fun (_  as _4) ->(Lexer.pSTRING_CONST >>= fun (_  as _5) ->(Lexer.literal ) |>> fun (_ as _6)   -> (_1,_2,_3,_4,_5,_6 ))))))

 and private opendatasource   = Lexer.literal OPENDATASOURCE >>= fun (_  as _1) ->(Lexer.literal ( >>= fun (_  as _2) ->(ident  >>= fun (_  as _3) ->(Lexer.literal , >>= fun (_  as _4) ->(Lexer.pSTRING_CONST >>= fun (_  as _5) ->(Lexer.literal ) |>> fun (_ as _6)   -> (_1,_2,_3,_4,_5,_6 ))))))

 and private freetexttable   = Lexer.literal FREETEXTTABLE >>= fun (_  as _1) ->(Lexer.literal ( >>= fun (_  as _2) ->(full_ident  >>= fun (_  as _3) ->(Lexer.literal , >>= fun (_  as _4) ->((attempt (full_ident  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal ( >>= fun (_  as _1) ->(yard_rule_comma_list_34  >>= fun (_  as _2) ->(Lexer.literal ) |>> fun (_ as _3)   -> (_1,_2,_3 ))))) <|> (Lexer.literal * |>> fun (_ as _1)   -> (_1 ))) >>= fun (_  as _5) ->(Lexer.literal , >>= fun (_  as _6) ->(Lexer.pSTRING_CONST >>= fun (_  as _7) ->(opt ( attempt(Lexer.literal , >>= fun (_  as _1) ->(Lexer.literal LANGUAGE >>= fun (_  as _2) ->((attempt (Lexer.pSTRING_CONST |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.pDEC_NUMBER |>> fun (_ as _1)   -> (_1 )) |>> fun (_ as _3)   -> (_1,_2,_3 ))))) >>= fun (_  as _8) ->(opt ( attempt(Lexer.literal , >>= fun (_  as _1) ->(Lexer.pDEC_NUMBER |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _9) ->(Lexer.literal ) |>> fun (_ as _10)   -> (_1,_2,_3,_4,_5,_6,_7,_8,_9,_10 ))))))))))

 and private yard_rule_comma_list_34   = yard_rule_list_35  |>> fun (_ as _1)   -> (_1 )

 and private yard_rule_list_35   = (attempt (preturn  [] )) <|> (full_ident  >>= fun (hd ) -> (many ( attempt(Lexer.literal , >>= fun (_  as _1) ->(full_ident  |>> fun (_ as _2)   -> (_2 )))) |>> fun (tl) -> (hd::tl) )  )

 and private containstable   = Lexer.literal CONTAINSTABLE >>= fun (_  as _1) ->(Lexer.literal ( >>= fun (_  as _2) ->(full_ident  >>= fun (_  as _3) ->(Lexer.literal , >>= fun (_  as _4) ->((attempt (ident  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal ( >>= fun (_  as _1) ->(yard_rule_comma_list_5  >>= fun (_  as _2) ->(Lexer.literal ) |>> fun (_ as _3)   -> (_1,_2,_3 ))))) <|> (Lexer.literal * |>> fun (_ as _1)   -> (_1 ))) >>= fun (_  as _5) ->(Lexer.literal , >>= fun (_  as _6) ->(Lexer.literal \' >>= fun (_  as _7) ->(contains_search_condition  >>= fun (_  as _8) ->(Lexer.literal \' >>= fun (_  as _9) ->(opt ( attempt(Lexer.literal , >>= fun (_  as _1) ->(Lexer.literal LANGUAGE >>= fun (_  as _2) ->((attempt (Lexer.pSTRING_CONST |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.pDEC_NUMBER |>> fun (_ as _1)   -> (_1 )) |>> fun (_ as _3)   -> (_1,_2,_3 ))))) >>= fun (_  as _10) ->(opt ( attempt(Lexer.literal , >>= fun (_  as _1) ->(Lexer.pDEC_NUMBER |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _11) ->(Lexer.literal ) |>> fun (_ as _12)   -> (_1,_2,_3,_4,_5,_6,_7,_8,_9,_10,_11,_12 ))))))))))))

 and private contains_search_condition   = (attempt (simple_term  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (prefix_term  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (generation_term  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (proximity_term  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (weighted_term  |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal ( >>= fun (_  as _1) ->(contains_search_condition  >>= fun (_  as _2) ->(Lexer.literal ) >>= fun (_  as _3) ->((attempt (Lexer.literal AND |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal & |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal AND >>= fun (_  as _1) ->(Lexer.literal NOT |>> fun (_ as _2)   -> (_1,_2 )))) <|> ((attempt (Lexer.literal &! |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal OR |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal | |>> fun (_ as _1)   -> (_1 )))))) >>= fun (_  as _4) ->(many1 ( attempt(contains_search_condition )) |>> fun (_ as _5)   -> (_1,_2,_3,_4,_5 ))))))))))

 and private simple_term   = Lexer.pSTRING_CONST |>> fun (_ as _1)   -> (_1 )

 and private prefix_term   = Lexer.pSTRING_CONST |>> fun (_ as _1)   -> (_1 )

 and private generation_term   = Lexer.literal FORMSOF >>= fun (_  as _1) ->(Lexer.literal ( >>= fun (_  as _2) ->((attempt (Lexer.literal INFLECTIONAL |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal THESAURUS |>> fun (_ as _1)   -> (_1 )) >>= fun (_  as _3) ->(Lexer.literal , >>= fun (_  as _4) ->(yard_rule_comma_list_36  >>= fun (_  as _5) ->(Lexer.literal ) |>> fun (_ as _6)   -> (_1,_2,_3,_4,_5,_6 ))))))

 and private yard_rule_comma_list_36   = yard_rule_list_37  |>> fun (_ as _1)   -> (_1 )

 and private yard_rule_list_37   = (attempt (preturn  [] )) <|> (simple_term  >>= fun (hd ) -> (many ( attempt(Lexer.literal , >>= fun (_  as _1) ->(simple_term  |>> fun (_ as _2)   -> (_2 )))) |>> fun (tl) -> (hd::tl) )  )

 and private proximity_term   = (attempt (simple_term  |>> fun (_ as _1)   -> (_1 ))) <|> (prefix_term  |>> fun (_ as _1)   -> (_1 )) >>= fun (_  as _1) ->(many1 ( attempt((attempt (Lexer.literal NEAR |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal ~ |>> fun (_ as _1)   -> (_1 )) >>= fun (_  as _1) ->((attempt (simple_term  |>> fun (_ as _1)   -> (_1 ))) <|> (prefix_term  |>> fun (_ as _1)   -> (_1 )) |>> fun (_ as _2)   -> (_1,_2 )))) |>> fun (_ as _2)   -> (_1,_2 ))

 and private weighted_term   = Lexer.literal ISABOUT >>= fun (_  as _1) ->(Lexer.literal ( >>= fun (_  as _2) ->(yard_rule_comma_list_38  >>= fun (_  as _3) ->(Lexer.literal ) |>> fun (_ as _4)   -> (_1,_2,_3,_4 ))))

 and private yard_rule_comma_list_38   = yard_rule_list_39  |>> fun (_ as _1)   -> (_1 )

 and private yard_rule_list_39   = (attempt (preturn  [] )) <|> ((attempt (simple_term  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (prefix_term  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (generation_term  |>> fun (_ as _1)   -> (_1 ))) <|> (proximity_term  |>> fun (_ as _1)   -> (_1 )))) >>= fun (_  as _1) ->(opt ( attempt(Lexer.pWEIGHT >>= fun (_  as _1) ->(Lexer.literal ( >>= fun (_  as _2) ->(Lexer.pDEC_NUMBER >>= fun (_  as _3) ->(Lexer.literal ) |>> fun (_ as _4)   -> (_1,_2,_3,_4 )))))) |>> fun (_ as _2)   -> (_1,_2 )) >>= fun (hd ) -> (many ( attempt(Lexer.literal , >>= fun (_  as _1) ->((attempt (simple_term  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (prefix_term  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (generation_term  |>> fun (_ as _1)   -> (_1 ))) <|> (proximity_term  |>> fun (_ as _1)   -> (_1 )))) >>= fun (_  as _1) ->(opt ( attempt(Lexer.pWEIGHT >>= fun (_  as _1) ->(Lexer.literal ( >>= fun (_  as _2) ->(Lexer.pDEC_NUMBER >>= fun (_  as _3) ->(Lexer.literal ) |>> fun (_ as _4)   -> (_1,_2,_3,_4 )))))) |>> fun (_ as _2)   -> (_1,_2 )) |>> fun (_ as _2)   -> (_2 )))) |>> fun (tl) -> (hd::tl) )  )

 and private table_hint   = opt ( attempt(Lexer.literal NOEXPAND)) >>= fun (_  as _1) ->((attempt (Lexer.literal INDEX >>= fun (_  as _1) ->(Lexer.literal ( >>= fun (_  as _2) ->(yard_rule_comma_list_5  >>= fun (_  as _3) ->(Lexer.literal ) |>> fun (_ as _4)   -> (_1,_2,_3,_4 )))))) <|> ((attempt (Lexer.literal FASTFIRSTROW |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal HOLDLOCK |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal NOLOCK |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal NOWAIT |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal PAGLOCK |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal READCOMMITTED |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal READCOMMITTEDLOCK |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal READPAST |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal READUNCOMMITTED |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal REPEATABLEREAD |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal ROWLOCK |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal SERIALIZABLE |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal TABLOCK |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal TABLOCKX |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal UPDLOCK |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal XLOCK |>> fun (_ as _1)   -> (_1 ))))))))))))))))) |>> fun (_ as _2)   -> (_1,_2 ))

 and private table_hint_limited   = (attempt (Lexer.literal KEEPIDENTITY |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal KEEPDEFAULTS |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal FASTFIRSTROW |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal HOLDLOCK |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal IGNORE_CONSTRAINTS |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal IGNORE_TRIGGERS |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal NOWAIT |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal PAGLOCK |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal READCOMMITTED |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal READCOMMITTEDLOCK |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal READPAST |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal REPEATABLEREAD |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal ROWLOCK |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal SERIALIZABLE |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal TABLOCK |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal TABLOCKX |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal UPDLOCK |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal XLOCK |>> fun (_ as _1)   -> (_1 ))))))))))))))))))

 and private tablesample_clause   = Lexer.literal TABLESAMPLE >>= fun (_  as _1) ->(opt ( attempt(Lexer.literal SYSTEM)) >>= fun (_  as _2) ->(Lexer.literal ( >>= fun (_  as _3) ->(sql_expr  >>= fun (_  as _4) ->(opt ( attempt((attempt (Lexer.literal PERCENT |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal ROWS |>> fun (_ as _1)   -> (_1 )))) >>= fun (_  as _5) ->(Lexer.literal ) >>= fun (_  as _6) ->(opt ( attempt(Lexer.literal REPEATABLE >>= fun (_  as _1) ->(sql_expr  |>> fun (_ as _2)   -> (_1,_2 )))) |>> fun (_ as _7)   -> (_1,_2,_3,_4,_5,_6,_7 )))))))

 and private joined_table   = (attempt (table_source  >>= fun (_  as _1) ->(opt ( attempt(join_type )) >>= fun (_  as _2) ->(Lexer.literal JOIN >>= fun (_  as _3) ->(table_source  >>= fun (_  as _4) ->(Lexer.literal ON >>= fun (_  as _5) ->(search_condition  |>> fun (_ as _6)   -> (_1,_2,_3,_4,_5,_6 )))))))) <|> ((attempt (table_source  >>= fun (_  as _1) ->(Lexer.literal CROSS >>= fun (_  as _2) ->(Lexer.literal JOIN >>= fun (_  as _3) ->(table_source  |>> fun (_ as _4)   -> (_1,_2,_3,_4 )))))) <|> (Lexer.literal ( >>= fun (_  as _1) ->(joined_table  >>= fun (_  as _2) ->(Lexer.literal ) |>> fun (_ as _3)   -> (_1,_2,_3 )))))

 and private join_type   = (attempt (Lexer.literal INNER |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal LEFT |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal RIGHT |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal FULL |>> fun (_ as _1)   -> (_1 ))) >>= fun (_  as _1) ->(opt ( attempt(Lexer.literal OUTER)) >>= fun (_  as _2) ->(opt ( attempt(join_hint )) |>> fun (_ as _3)   -> (_1,_2,_3 ))))

 and private join_hint   = (attempt (Lexer.literal LOOP |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal HASH |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal MERGE |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal REMOTE |>> fun (_ as _1)   -> (_1 ))))

 and private pivoted_table   = table_source  >>= fun (_  as _1) ->(Lexer.literal PIVOT >>= fun (_  as _2) ->(pivot_clause  >>= fun (_  as _3) ->(full_ident  |>> fun (_ as _4)   -> (_1,_2,_3,_4 ))))

 and private pivot_clause   = Lexer.literal ( >>= fun (_  as _1) ->(many1 ( attempt(sql_expr )) >>= fun (_  as _2) ->(Lexer.literal FOR >>= fun (_  as _3) ->(sql_expr  >>= fun (_  as _4) ->(Lexer.literal IN >>= fun (_  as _5) ->(Lexer.literal ( >>= fun (_  as _6) ->(yard_rule_comma_list_5  >>= fun (_  as _7) ->(Lexer.literal ) >>= fun (_  as _8) ->(Lexer.literal ) |>> fun (_ as _9)   -> (_1,_2,_3,_4,_5,_6,_7,_8,_9 )))))))))

 and private unpivoted_table   = table_source  >>= fun (_  as _1) ->(Lexer.literal UNPIVOT >>= fun (_  as _2) ->(unpivot_clause  >>= fun (_  as _3) ->(full_ident  |>> fun (_ as _4)   -> (_1,_2,_3,_4 ))))

 and private unpivot_clause   = Lexer.literal ( >>= fun (_  as _1) ->(ident  >>= fun (_  as _2) ->(Lexer.literal FOR >>= fun (_  as _3) ->(sql_expr  >>= fun (_  as _4) ->(Lexer.literal IN >>= fun (_  as _5) ->(Lexer.literal ( >>= fun (_  as _6) ->(yard_rule_comma_list_34  >>= fun (_  as _7) ->(Lexer.literal ) >>= fun (_  as _8) ->(Lexer.literal ) |>> fun (_ as _9)   -> (_1,_2,_3,_4,_5,_6,_7,_8,_9 )))))))))

 and private case   = Lexer.literal CASE >>= fun (_  as _1) ->(opt ( attempt(sql_expr )) >>= fun (_  as _2) ->(many ( attempt(Lexer.literal WHEN >>= fun (_  as _1) ->(sql_expr  >>= fun (_  as _2) ->(Lexer.literal THEN >>= fun (_  as _3) ->(sql_expr  |>> fun (_ as _4)   -> (_1,_2,_3,_4 )))))) >>= fun (_  as _3) ->(opt ( attempt(Lexer.literal ELSE >>= fun (_  as _1) ->(sql_expr  |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _4) ->(Lexer.literal END |>> fun (_ as _5)   -> (_1,_2,_3,_4,_5 )))))

 and private create_table   = Lexer.literal CREATE >>= fun (_  as _1) ->(Lexer.literal TABLE >>= fun (_  as _2) ->(opt ( attempt(Lexer.pIDENT >>= fun (_  as _1) ->(Lexer.literal . >>= fun (_  as _2) ->(opt ( attempt(Lexer.pIDENT)) >>= fun (_  as _3) ->(opt ( attempt(Lexer.literal .)) |>> fun (_ as _4)   -> (_1,_2,_3,_4 )))))) >>= fun (_  as _3) ->(Lexer.pIDENT >>= fun (_  as _4) ->(Lexer.literal ( >>= fun (_  as _5) ->(yard_rule_comma_list_40  >>= fun (_  as _6) ->(yard_rule_comma_list_42  >>= fun (_  as _7) ->(Lexer.literal ) >>= fun (_  as _8) ->(opt ( attempt(Lexer.literal ON >>= fun (_  as _1) ->((attempt (Lexer.pIDENT >>= fun (_  as _1) ->(Lexer.literal ( >>= fun (_  as _2) ->(Lexer.pIDENT >>= fun (_  as _3) ->(Lexer.literal ) |>> fun (_ as _4)   -> (_1,_2,_3,_4 )))))) <|> ((attempt (Lexer.pIDENT |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal DEFAULT |>> fun (_ as _1)   -> (_1 ))) |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _9) ->(opt ( attempt(Lexer.literal TEXTIMAGE_ON >>= fun (_  as _1) ->((attempt (Lexer.pIDENT |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal DEFAULT |>> fun (_ as _1)   -> (_1 )) |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _10) ->(opt ( attempt(Lexer.literal ;)) |>> fun (_ as _11)   -> (_1,_2,_3,_4,_5,_6,_7,_8,_9,_10,_11 )))))))))))

 and private yard_rule_comma_list_42   = yard_rule_list_43  |>> fun (_ as _1)   -> (_1 )

 and private yard_rule_list_43   = (attempt (preturn  [] )) <|> (table_constraint_create_table  >>= fun (hd ) -> (many ( attempt(Lexer.literal , >>= fun (_  as _1) ->(table_constraint_create_table  |>> fun (_ as _2)   -> (_2 )))) |>> fun (tl) -> (hd::tl) )  )

 and private yard_rule_comma_list_40   = yard_rule_list_41  |>> fun (_ as _1)   -> (_1 )

 and private yard_rule_list_41   = (attempt (preturn  [] )) <|> ((attempt (column_definition_create_table  |>> fun (_ as _1)   -> (_1 ))) <|> (computed_column_definition  |>> fun (_ as _1)   -> (_1 )) >>= fun (hd ) -> (many ( attempt(Lexer.literal , >>= fun (_  as _1) ->((attempt (column_definition_create_table  |>> fun (_ as _1)   -> (_1 ))) <|> (computed_column_definition  |>> fun (_ as _1)   -> (_1 )) |>> fun (_ as _2)   -> (_2 )))) |>> fun (tl) -> (hd::tl) )  )

 and private column_definition_create_table   = (attempt (ident  >>= fun (_  as _1) ->(sql_datatype  >>= fun (_  as _2) ->(opt ( attempt(Lexer.literal COLLATE >>= fun (_  as _1) ->(Lexer.pIDENT |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _3) ->(opt ( attempt(opt ( attempt(Lexer.literal NOT)) >>= fun (_  as _1) ->(Lexer.literal NULL |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _4) ->(opt ( attempt(opt ( attempt(Lexer.literal CONSTRAINT >>= fun (_  as _1) ->(Lexer.pIDENT |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _1) ->(Lexer.literal DEFAULT >>= fun (_  as _2) ->(sql_expr  |>> fun (_ as _3)   -> (_1,_2,_3 ))))) |>> fun (_ as _5)   -> (_1,_2,_3,_4,_5 ))))))) <|> (opt ( attempt(Lexer.literal IDENTITY >>= fun (_  as _1) ->(opt ( attempt(Lexer.literal ( >>= fun (_  as _1) ->(sql_expr  >>= fun (_  as _2) ->(Lexer.literal , >>= fun (_  as _3) ->(sql_expr  >>= fun (_  as _4) ->(Lexer.literal ) |>> fun (_ as _5)   -> (_1,_2,_3,_4,_5 ))))))) >>= fun (_  as _2) ->(opt ( attempt(Lexer.literal NOT >>= fun (_  as _1) ->(Lexer.literal FOR >>= fun (_  as _2) ->(Lexer.literal REPLICATION |>> fun (_ as _3)   -> (_1,_2,_3 ))))) |>> fun (_ as _3)   -> (_1,_2,_3 ))))) >>= fun (_  as _1) ->(opt ( attempt(Lexer.literal ROWGUIDCOL |>> fun (_ as _1)   -> (_1 ))) >>= fun (_  as _2) ->(many ( attempt(column_constraint_create_table )) |>> fun (_ as _3)   -> (_1,_2,_3 ))))

 and private column_constraint_create_table   = opt ( attempt(Lexer.literal CONSTRAINT >>= fun (_  as _1) ->(Lexer.pIDENT |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _1) ->((attempt ((attempt (Lexer.literal PRIMARY >>= fun (_  as _1) ->(Lexer.literal KEY |>> fun (_ as _2)   -> (_1,_2 )))) <|> (Lexer.literal UNIQUE |>> fun (_ as _1)   -> (_1 )) >>= fun (_  as _1) ->(opt ( attempt((attempt (Lexer.literal CLUSTERED |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal NONCLUSTERED |>> fun (_ as _1)   -> (_1 )))) >>= fun (_  as _2) ->(opt ( attempt((attempt (Lexer.literal WITH >>= fun (_  as _1) ->(Lexer.literal FILLFACTOR >>= fun (_  as _2) ->(Lexer.literal = >>= fun (_  as _3) ->(Lexer.pDEC_NUMBER |>> fun (_ as _4)   -> (_1,_2,_3,_4 )))))) <|> (Lexer.literal WITH >>= fun (_  as _1) ->(Lexer.literal ( >>= fun (_  as _2) ->(yard_rule_comma_list_44  >>= fun (_  as _3) ->(Lexer.literal ) |>> fun (_ as _4)   -> (_1,_2,_3,_4 ))))))) >>= fun (_  as _3) ->(opt ( attempt(Lexer.literal ON >>= fun (_  as _1) ->((attempt (Lexer.pIDENT >>= fun (_  as _1) ->(Lexer.literal ( >>= fun (_  as _2) ->(Lexer.pIDENT >>= fun (_  as _3) ->(Lexer.literal ) |>> fun (_ as _4)   -> (_1,_2,_3,_4 )))))) <|> ((attempt (Lexer.pIDENT |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal DEFAULT |>> fun (_ as _1)   -> (_1 ))) |>> fun (_ as _2)   -> (_1,_2 )))) |>> fun (_ as _4)   -> (_1,_2,_3,_4 )))))) <|> ((attempt (opt ( attempt(Lexer.literal FOREIGN >>= fun (_  as _1) ->(Lexer.literal KEY |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _1) ->(Lexer.literal REFERENCES >>= fun (_  as _2) ->(opt ( attempt(Lexer.pIDENT >>= fun (_  as _1) ->(Lexer.literal . |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _3) ->(Lexer.pIDENT >>= fun (_  as _4) ->(opt ( attempt(Lexer.literal ( >>= fun (_  as _1) ->(Lexer.pIDENT >>= fun (_  as _2) ->(Lexer.literal ) |>> fun (_ as _3)   -> (_1,_2,_3 ))))) >>= fun (_  as _5) ->(many ( attempt(delete_update )) >>= fun (_  as _6) ->(opt ( attempt(Lexer.literal NOT >>= fun (_  as _1) ->(Lexer.literal FOR >>= fun (_  as _2) ->(Lexer.literal REPLICATION |>> fun (_ as _3)   -> (_1,_2,_3 ))))) |>> fun (_ as _7)   -> (_1,_2,_3,_4,_5,_6,_7 ))))))))) <|> (Lexer.literal CHECK >>= fun (_  as _1) ->(opt ( attempt(Lexer.literal NOT >>= fun (_  as _1) ->(Lexer.literal FOR >>= fun (_  as _2) ->(Lexer.literal REPLICATION |>> fun (_ as _3)   -> (_1,_2,_3 ))))) >>= fun (_  as _2) ->(sql_expr  |>> fun (_ as _3)   -> (_1,_2,_3 ))))) |>> fun (_ as _2)   -> (_1,_2 ))

 and private yard_rule_comma_list_44   = yard_rule_list_45  |>> fun (_ as _1)   -> (_1 )

 and private yard_rule_list_45   = (attempt (preturn  [] )) <|> (index_option  >>= fun (hd ) -> (many ( attempt(Lexer.literal , >>= fun (_  as _1) ->(index_option  |>> fun (_ as _2)   -> (_2 )))) |>> fun (tl) -> (hd::tl) )  )

 and private computed_column_definition   = Lexer.pIDENT >>= fun (_  as _1) ->(Lexer.literal AS >>= fun (_  as _2) ->(sql_expr  >>= fun (_  as _3) ->(opt ( attempt(Lexer.literal PERSISTED >>= fun (_  as _1) ->(opt ( attempt(Lexer.literal NOT >>= fun (_  as _1) ->(Lexer.literal NULL |>> fun (_ as _2)   -> (_1,_2 )))) |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _4) ->(opt ( attempt((attempt (opt ( attempt(Lexer.literal CONSTRAINT >>= fun (_  as _1) ->(Lexer.pIDENT |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _1) ->((attempt (Lexer.literal PRIMARY >>= fun (_  as _1) ->(Lexer.literal KEY |>> fun (_ as _2)   -> (_1,_2 )))) <|> (Lexer.literal UNIQUE |>> fun (_ as _1)   -> (_1 )) >>= fun (_  as _2) ->(opt ( attempt((attempt (Lexer.literal CLUSTERED |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal NONCLUSTERED |>> fun (_ as _1)   -> (_1 )))) >>= fun (_  as _3) ->(opt ( attempt((attempt (Lexer.literal WITH >>= fun (_  as _1) ->(Lexer.literal FILLFACTOR >>= fun (_  as _2) ->(Lexer.literal = >>= fun (_  as _3) ->(Lexer.pDEC_NUMBER |>> fun (_ as _4)   -> (_1,_2,_3,_4 )))))) <|> (Lexer.literal WITH >>= fun (_  as _1) ->(Lexer.literal ( >>= fun (_  as _2) ->(yard_rule_comma_list_44  >>= fun (_  as _3) ->(Lexer.literal ) |>> fun (_ as _4)   -> (_1,_2,_3,_4 ))))))) >>= fun (_  as _4) ->(opt ( attempt(Lexer.literal ON >>= fun (_  as _1) ->((attempt (Lexer.pIDENT >>= fun (_  as _1) ->(Lexer.literal ( >>= fun (_  as _2) ->(Lexer.pIDENT >>= fun (_  as _3) ->(Lexer.literal ) |>> fun (_ as _4)   -> (_1,_2,_3,_4 )))))) <|> ((attempt (Lexer.pIDENT |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal DEFAULT |>> fun (_ as _1)   -> (_1 ))) |>> fun (_ as _2)   -> (_1,_2 )))) |>> fun (_ as _5)   -> (_1,_2,_3,_4,_5 ))))))) <|> ((attempt (opt ( attempt(Lexer.literal FOREIGN >>= fun (_  as _1) ->(Lexer.literal KEY |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _1) ->(Lexer.literal REFERENCES >>= fun (_  as _2) ->(Lexer.pIDENT >>= fun (_  as _3) ->(opt ( attempt(Lexer.literal ( >>= fun (_  as _1) ->(Lexer.pIDENT >>= fun (_  as _2) ->(Lexer.literal ) |>> fun (_ as _3)   -> (_1,_2,_3 ))))) >>= fun (_  as _4) ->(many ( attempt(delete_update )) >>= fun (_  as _5) ->(opt ( attempt(Lexer.literal NOT >>= fun (_  as _1) ->(Lexer.literal FOR >>= fun (_  as _2) ->(Lexer.literal REPLICATION |>> fun (_ as _3)   -> (_1,_2,_3 ))))) |>> fun (_ as _6)   -> (_1,_2,_3,_4,_5,_6 )))))))) <|> (Lexer.literal CHECK >>= fun (_  as _1) ->(opt ( attempt(Lexer.literal NOT >>= fun (_  as _1) ->(Lexer.literal FOR >>= fun (_  as _2) ->(Lexer.literal REPLICATION |>> fun (_ as _3)   -> (_1,_2,_3 ))))) >>= fun (_  as _2) ->(sql_expr  |>> fun (_ as _3)   -> (_1,_2,_3 ))))))) |>> fun (_ as _5)   -> (_1,_2,_3,_4,_5 )))))

 and private table_constraint_create_table   = opt ( attempt(Lexer.literal CONSTRAINT >>= fun (_  as _1) ->(Lexer.pIDENT |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _1) ->((attempt ((attempt (Lexer.literal PRIMARY >>= fun (_  as _1) ->(Lexer.literal KEY |>> fun (_ as _2)   -> (_1,_2 )))) <|> (Lexer.literal UNIQUE |>> fun (_ as _1)   -> (_1 )) >>= fun (_  as _1) ->(opt ( attempt((attempt (Lexer.literal CLUSTERED |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal NONCLUSTERED |>> fun (_ as _1)   -> (_1 )))) >>= fun (_  as _2) ->(Lexer.literal ( >>= fun (_  as _3) ->(yard_rule_comma_list_46  >>= fun (_  as _4) ->(Lexer.literal ) >>= fun (_  as _5) ->(opt ( attempt((attempt (Lexer.literal WITH >>= fun (_  as _1) ->(Lexer.literal FILLFACTOR >>= fun (_  as _2) ->(Lexer.literal = >>= fun (_  as _3) ->(Lexer.pDEC_NUMBER |>> fun (_ as _4)   -> (_1,_2,_3,_4 )))))) <|> (Lexer.literal WITH >>= fun (_  as _1) ->(Lexer.literal ( >>= fun (_  as _2) ->(yard_rule_comma_list_44  >>= fun (_  as _3) ->(Lexer.literal ) |>> fun (_ as _4)   -> (_1,_2,_3,_4 ))))))) >>= fun (_  as _6) ->(opt ( attempt(Lexer.literal ON >>= fun (_  as _1) ->((attempt (Lexer.pIDENT >>= fun (_  as _1) ->(Lexer.literal ( >>= fun (_  as _2) ->(Lexer.pIDENT >>= fun (_  as _3) ->(Lexer.literal ) |>> fun (_ as _4)   -> (_1,_2,_3,_4 )))))) <|> ((attempt (Lexer.pIDENT |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal DEFAULT |>> fun (_ as _1)   -> (_1 ))) |>> fun (_ as _2)   -> (_1,_2 )))) |>> fun (_ as _7)   -> (_1,_2,_3,_4,_5,_6,_7 ))))))))) <|> ((attempt (Lexer.literal FOREIGN >>= fun (_  as _1) ->(Lexer.literal KEY >>= fun (_  as _2) ->(Lexer.literal ( >>= fun (_  as _3) ->(yard_rule_comma_list_48  >>= fun (_  as _4) ->(Lexer.literal ) >>= fun (_  as _5) ->(Lexer.literal REFERENCES >>= fun (_  as _6) ->(Lexer.pIDENT >>= fun (_  as _7) ->(opt ( attempt(Lexer.literal ( >>= fun (_  as _1) ->(yard_rule_comma_list_48  >>= fun (_  as _2) ->(Lexer.literal ) |>> fun (_ as _3)   -> (_1,_2,_3 ))))) >>= fun (_  as _8) ->(many ( attempt(delete_update )) >>= fun (_  as _9) ->(opt ( attempt(Lexer.literal NOT >>= fun (_  as _1) ->(Lexer.literal FOR >>= fun (_  as _2) ->(Lexer.literal REPLICATION |>> fun (_ as _3)   -> (_1,_2,_3 ))))) |>> fun (_ as _10)   -> (_1,_2,_3,_4,_5,_6,_7,_8,_9,_10 )))))))))))) <|> (Lexer.literal CHECK >>= fun (_  as _1) ->(opt ( attempt(Lexer.literal NOT >>= fun (_  as _1) ->(Lexer.literal FOR >>= fun (_  as _2) ->(Lexer.literal REPLICATION |>> fun (_ as _3)   -> (_1,_2,_3 ))))) >>= fun (_  as _2) ->(sql_expr  |>> fun (_ as _3)   -> (_1,_2,_3 ))))) |>> fun (_ as _2)   -> (_1,_2 ))

 and private yard_rule_comma_list_46   = yard_rule_list_47  |>> fun (_ as _1)   -> (_1 )

 and private yard_rule_list_47   = (attempt (preturn  [] )) <|> (Lexer.pIDENT >>= fun (_  as _1) ->(opt ( attempt((attempt (Lexer.literal ASC |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal DESC |>> fun (_ as _1)   -> (_1 )))) |>> fun (_ as _2)   -> (_1,_2 )) >>= fun (hd ) -> (many ( attempt(Lexer.literal , >>= fun (_  as _1) ->(Lexer.pIDENT >>= fun (_  as _1) ->(opt ( attempt((attempt (Lexer.literal ASC |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal DESC |>> fun (_ as _1)   -> (_1 )))) |>> fun (_ as _2)   -> (_1,_2 )) |>> fun (_ as _2)   -> (_2 )))) |>> fun (tl) -> (hd::tl) )  )

 and private yard_rule_comma_list_48   = yard_rule_list_49  |>> fun (_ as _1)   -> (_1 )

 and private yard_rule_list_49   = (attempt (preturn  [] )) <|> (Lexer.pIDENT >>= fun (hd ) -> (many ( attempt(Lexer.literal , >>= fun (_  as _1) ->(Lexer.pIDENT |>> fun (_ as _2)   -> (_2 )))) |>> fun (tl) -> (hd::tl) )  )

 and private delete_update   = Lexer.literal ON >>= fun (_  as _1) ->((attempt (Lexer.literal DELETE |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal UPDATE |>> fun (_ as _1)   -> (_1 )) >>= fun (_  as _2) ->(delete_update_options  |>> fun (_ as _3)   -> (_1,_2,_3 )))

 and private delete_update_options   = (attempt (Lexer.literal NO >>= fun (_  as _1) ->(Lexer.literal ACTION |>> fun (_ as _2)   -> (_1,_2 )))) <|> ((attempt (Lexer.literal CASCADE |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal SET >>= fun (_  as _1) ->(Lexer.literal NULL |>> fun (_ as _2)   -> (_1,_2 )))) <|> (Lexer.literal SET >>= fun (_  as _1) ->(Lexer.literal DEFAULT |>> fun (_ as _2)   -> (_1,_2 )))))

 and private index_option   = (attempt (Lexer.literal PAD_INDEX >>= fun (_  as _1) ->(Lexer.literal = >>= fun (_  as _2) ->((attempt (Lexer.literal ON |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal OFF |>> fun (_ as _1)   -> (_1 )) |>> fun (_ as _3)   -> (_1,_2,_3 ))))) <|> ((attempt (Lexer.literal FILLFACTOR >>= fun (_  as _1) ->(Lexer.literal = >>= fun (_  as _2) ->(Lexer.pDEC_NUMBER |>> fun (_ as _3)   -> (_1,_2,_3 ))))) <|> ((attempt (Lexer.literal IGNORE_DUP_KEY >>= fun (_  as _1) ->(Lexer.literal = >>= fun (_  as _2) ->((attempt (Lexer.literal ON |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal OFF |>> fun (_ as _1)   -> (_1 )) |>> fun (_ as _3)   -> (_1,_2,_3 ))))) <|> ((attempt (Lexer.literal STATISTICS_NORECOMPUTE >>= fun (_  as _1) ->(Lexer.literal = >>= fun (_  as _2) ->((attempt (Lexer.literal ON |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal OFF |>> fun (_ as _1)   -> (_1 )) |>> fun (_ as _3)   -> (_1,_2,_3 ))))) <|> ((attempt (Lexer.literal ALLOW_ROW_LOCKS >>= fun (_  as _1) ->(Lexer.literal = >>= fun (_  as _2) ->((attempt (Lexer.literal ON |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal OFF |>> fun (_ as _1)   -> (_1 )) |>> fun (_ as _3)   -> (_1,_2,_3 ))))) <|> (Lexer.literal ALLOW_PAGE_LOCKS >>= fun (_  as _1) ->(Lexer.literal = >>= fun (_  as _2) ->((attempt (Lexer.literal ON |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal OFF |>> fun (_ as _1)   -> (_1 )) |>> fun (_ as _3)   -> (_1,_2,_3 )))))))) |>> fun (_ as _1)   -> (_1 )

 and private insert   = opt ( attempt(Lexer.literal WITH >>= fun (_  as _1) ->(yard_rule_comma_list_14  |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _1) ->(Lexer.literal INSERT >>= fun (_  as _2) ->(opt ( attempt(Lexer.literal TOP >>= fun (_  as _1) ->(sql_expr  >>= fun (_  as _2) ->(opt ( attempt(Lexer.literal PERCENT)) |>> fun (_ as _3)   -> (_1,_2,_3 ))))) >>= fun (_  as _3) ->(opt ( attempt(Lexer.literal INTO)) >>= fun (_  as _4) ->((attempt (object  |>> fun (_ as _1)   -> (_1 ))) <|> (rowset_function  >>= fun (_  as _1) ->(opt ( attempt(Lexer.literal WITH >>= fun (_  as _1) ->(Lexer.literal ( >>= fun (_  as _2) ->(many ( attempt(table_hint )) >>= fun (_  as _3) ->(Lexer.literal ) |>> fun (_ as _4)   -> (_1,_2,_3,_4 )))))) |>> fun (_ as _2)   -> (_1,_2 ))) >>= fun (_  as _5) ->(opt ( attempt(Lexer.literal ( >>= fun (_  as _1) ->(yard_rule_comma_list_50  >>= fun (_  as _2) ->(Lexer.literal ) |>> fun (_ as _3)   -> (_1,_2,_3 ))))) >>= fun (_  as _6) ->(opt ( attempt(output_clause )) >>= fun (_  as _7) ->(opt ( attempt((attempt (Lexer.literal VALUES >>= fun (_  as _1) ->(Lexer.literal ( >>= fun (_  as _2) ->(yard_rule_comma_list_52  >>= fun (_  as _3) ->(Lexer.literal ) |>> fun (_ as _4)   -> (_1,_2,_3,_4 )))))) <|> ((attempt (batch_body  |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal DEFAULT >>= fun (_  as _1) ->(Lexer.literal VALUES |>> fun (_ as _2)   -> (_1,_2 )))))) >>= fun (_  as _8) ->(opt ( attempt(Lexer.literal ;)) |>> fun (_ as _9)   -> (_1,_2,_3,_4,_5,_6,_7,_8,_9 )))))))))

 and private yard_rule_comma_list_52   = yard_rule_list_53  |>> fun (_ as _1)   -> (_1 )

 and private yard_rule_list_53   = (attempt (preturn  [] )) <|> ((attempt (Lexer.literal DEFAULT |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal NULL |>> fun (_ as _1)   -> (_1 ))) <|> (sql_expr  |>> fun (_ as _1)   -> (_1 ))) >>= fun (hd ) -> (many ( attempt(Lexer.literal , >>= fun (_  as _1) ->((attempt (Lexer.literal DEFAULT |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal NULL |>> fun (_ as _1)   -> (_1 ))) <|> (sql_expr  |>> fun (_ as _1)   -> (_1 ))) |>> fun (_ as _2)   -> (_2 )))) |>> fun (tl) -> (hd::tl) )  )

 and private yard_rule_comma_list_50   = yard_rule_list_51  |>> fun (_ as _1)   -> (_1 )

 and private yard_rule_list_51   = (attempt (preturn  [] )) <|> (Lexer.pLOCALVAR >>= fun (hd ) -> (many ( attempt(Lexer.literal , >>= fun (_  as _1) ->(Lexer.pLOCALVAR |>> fun (_ as _2)   -> (_2 )))) |>> fun (tl) -> (hd::tl) )  )

 and private output_clause   = Lexer.literal OUTPUT >>= fun (_  as _1) ->(dml_select_list  >>= fun (_  as _2) ->(Lexer.literal INTO >>= fun (_  as _3) ->((attempt (Lexer.pLOCALVAR |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.pIDENT |>> fun (_ as _1)   -> (_1 )) >>= fun (_  as _4) ->(opt ( attempt(Lexer.literal ( >>= fun (_  as _1) ->(yard_rule_comma_list_50  >>= fun (_  as _2) ->(Lexer.literal ) |>> fun (_ as _3)   -> (_1,_2,_3 ))))) >>= fun (_  as _5) ->(opt ( attempt(Lexer.literal OUTPUT >>= fun (_  as _1) ->(dml_select_list  |>> fun (_ as _2)   -> (_1,_2 )))) |>> fun (_ as _6)   -> (_1,_2,_3,_4,_5,_6 ))))))

 and private dml_select_list   = (attempt (ident  |>> fun (_ as _1)   -> (_1 ))) <|> (sql_expr  |>> fun (_ as _1)   -> (_1 )) >>= fun (_  as _1) ->(opt ( attempt(opt ( attempt(Lexer.literal AS)) >>= fun (_  as _1) ->(Lexer.pIDENT |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _2) ->(yard_rule_comma_list_54  |>> fun (_ as _3)   -> (_1,_2,_3 )))

 and private yard_rule_comma_list_54   = yard_rule_list_55  |>> fun (_ as _1)   -> (_1 )

 and private yard_rule_list_55   = (attempt (preturn  [] )) <|> ((attempt (ident  |>> fun (_ as _1)   -> (_1 ))) <|> (sql_expr  |>> fun (_ as _1)   -> (_1 )) >>= fun (_  as _1) ->(opt ( attempt(opt ( attempt(Lexer.literal AS)) >>= fun (_  as _1) ->(Lexer.pIDENT |>> fun (_ as _2)   -> (_1,_2 )))) |>> fun (_ as _2)   -> (_1,_2 )) >>= fun (hd ) -> (many ( attempt(Lexer.literal , >>= fun (_  as _1) ->((attempt (ident  |>> fun (_ as _1)   -> (_1 ))) <|> (sql_expr  |>> fun (_ as _1)   -> (_1 )) >>= fun (_  as _1) ->(opt ( attempt(opt ( attempt(Lexer.literal AS)) >>= fun (_  as _1) ->(Lexer.pIDENT |>> fun (_ as _2)   -> (_1,_2 )))) |>> fun (_ as _2)   -> (_1,_2 )) |>> fun (_ as _2)   -> (_2 )))) |>> fun (tl) -> (hd::tl) )  )

 and private column_name   = (attempt (Lexer.literal DELETED |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal INSERTED |>> fun (_ as _1)   -> (_1 ))) <|> (ident  |>> fun (_ as _1)   -> (_1 ))) >>= fun (_  as _1) ->(Lexer.literal . >>= fun (_  as _2) ->((attempt (Lexer.literal * |>> fun (_ as _1)   -> (_1 ))) <|> (ident  |>> fun (_ as _1)   -> (_1 )) |>> fun (_ as _3)   -> (_1,_2,_3 )))

 and private object   = opt ( attempt((attempt (Lexer.pIDENT >>= fun (_  as _1) ->(Lexer.literal . >>= fun (_  as _2) ->(Lexer.pIDENT >>= fun (_  as _3) ->(Lexer.literal . >>= fun (_  as _4) ->(Lexer.pIDENT >>= fun (_  as _5) ->(Lexer.literal . |>> fun (_ as _6)   -> (_1,_2,_3,_4,_5,_6 )))))))) <|> ((attempt (Lexer.pIDENT >>= fun (_  as _1) ->(Lexer.literal . >>= fun (_  as _2) ->(opt ( attempt(Lexer.pIDENT)) >>= fun (_  as _3) ->(Lexer.literal . |>> fun (_ as _4)   -> (_1,_2,_3,_4 )))))) <|> (Lexer.pIDENT >>= fun (_  as _1) ->(Lexer.literal . |>> fun (_ as _2)   -> (_1,_2 )))))) >>= fun (_  as _1) ->(ident  |>> fun (_ as _2)   -> (_1,_2 ))

 and private begin_transaction   = Lexer.literal BEGIN >>= fun (_  as _1) ->((attempt (Lexer.literal TRAN |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal TRANSACTION |>> fun (_ as _1)   -> (_1 )) >>= fun (_  as _2) ->(opt ( attempt((attempt (ident  |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.pLOCALVAR |>> fun (_ as _1)   -> (_1 )) >>= fun (_  as _1) ->(opt ( attempt(Lexer.literal WITH >>= fun (_  as _1) ->(Lexer.literal MARK >>= fun (_  as _2) ->(opt ( attempt(Lexer.pSTRING_CONST)) |>> fun (_ as _3)   -> (_1,_2,_3 ))))) |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _3) ->(opt ( attempt(Lexer.literal ;)) |>> fun (_ as _4)   -> (_1,_2,_3,_4 ))))

 and private commit_transaction   = Lexer.literal COMMIT >>= fun (_  as _1) ->((attempt (Lexer.literal TRAN |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal TRANSACTION |>> fun (_ as _1)   -> (_1 )) >>= fun (_  as _2) ->(opt ( attempt((attempt (Lexer.pIDENT |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.pLOCALVAR |>> fun (_ as _1)   -> (_1 )))) >>= fun (_  as _3) ->(opt ( attempt(Lexer.literal ;)) |>> fun (_ as _4)   -> (_1,_2,_3,_4 ))))

 and private execute_stmnt   = (attempt (execute_proc  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (execute_character_string  |>> fun (_ as _1)   -> (_1 ))) <|> (execute_command  |>> fun (_ as _1)   -> (_1 )))

 and private execute_proc   = opt ( attempt((attempt (Lexer.literal EXEC |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal EXECUTE |>> fun (_ as _1)   -> (_1 )))) >>= fun (_  as _1) ->((attempt (create_object  >>= fun (_  as _1) ->(Lexer.literal . >>= fun (_  as _2) ->(Lexer.pIDENT >>= fun (_  as _3) ->(Lexer.literal ( >>= fun (_  as _4) ->(yard_rule_comma_list_56  >>= fun (_  as _5) ->(Lexer.literal ) |>> fun (_ as _6)   -> (_1,_2,_3,_4,_5,_6 )))))))) <|> (opt ( attempt(Lexer.pLOCALVAR >>= fun (_  as _1) ->(Lexer.literal = |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _1) ->((attempt (full_ident  >>= fun (_  as _1) ->(opt ( attempt(Lexer.literal ; >>= fun (_  as _1) ->(Lexer.pDEC_NUMBER |>> fun (_ as _2)   -> (_1,_2 )))) |>> fun (_ as _2)   -> (_1,_2 )))) <|> (Lexer.pLOCALVAR |>> fun (_ as _1)   -> (_1 )) >>= fun (_  as _2) ->(yard_rule_brace_opt_60  >>= fun (_  as _3) ->(opt ( attempt(Lexer.literal WITH >>= fun (_  as _1) ->(Lexer.literal RECOMPILE |>> fun (_ as _2)   -> (_1,_2 )))) |>> fun (_ as _4)   -> (_1,_2,_3,_4 ))))) |>> fun (_ as _2)   -> (_1,_2 ))

 and private yard_rule_comma_list_56   = yard_rule_list_57  |>> fun (_ as _1)   -> (_1 )

 and private yard_rule_list_57   = (attempt (preturn  [] )) <|> (opt ( attempt(Lexer.pLOCALVAR >>= fun (_  as _1) ->(Lexer.literal = |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _1) ->(sql_expr  |>> fun (_ as _2)   -> (_1,_2 )) >>= fun (hd ) -> (many ( attempt(Lexer.literal , >>= fun (_  as _1) ->(opt ( attempt(Lexer.pLOCALVAR >>= fun (_  as _1) ->(Lexer.literal = |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _1) ->(sql_expr  |>> fun (_ as _2)   -> (_1,_2 )) |>> fun (_ as _2)   -> (_2 )))) |>> fun (tl) -> (hd::tl) )  )

 and private yard_rule_brace_opt_60   = (attempt (yard_rule_comma_list_58  |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal ( >>= fun (_  as _1) ->(yard_rule_comma_list_58  >>= fun (_  as _2) ->(Lexer.literal ) |>> fun (_ as _3)   -> (_2 ))))

 and private yard_rule_comma_list_58   = yard_rule_list_59  |>> fun (_ as _1)   -> (_1 )

 and private yard_rule_list_59   = (attempt (preturn  [] )) <|> (opt ( attempt(opt ( attempt(Lexer.pLOCALVAR >>= fun (_  as _1) ->(Lexer.literal = |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _1) ->((attempt (sql_expr  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.pLOCALVAR >>= fun (_  as _1) ->(opt ( attempt((attempt (Lexer.literal OUTPUT |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal OUT |>> fun (_ as _1)   -> (_1 )))) |>> fun (_ as _2)   -> (_1,_2 )))) <|> (opt ( attempt(Lexer.literal DEFAULT)) |>> fun (_ as _1)   -> (_1 ))) |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (hd ) -> (many ( attempt(Lexer.literal , >>= fun (_  as _1) ->(opt ( attempt(opt ( attempt(Lexer.pLOCALVAR >>= fun (_  as _1) ->(Lexer.literal = |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _1) ->((attempt (sql_expr  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.pLOCALVAR >>= fun (_  as _1) ->(opt ( attempt((attempt (Lexer.literal OUTPUT |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal OUT |>> fun (_ as _1)   -> (_1 )))) |>> fun (_ as _2)   -> (_1,_2 )))) <|> (opt ( attempt(Lexer.literal DEFAULT)) |>> fun (_ as _1)   -> (_1 ))) |>> fun (_ as _2)   -> (_1,_2 )))) |>> fun (_ as _2)   -> (_2 )))) |>> fun (tl) -> (hd::tl) )  )

 and private create_object   = Lexer.pSTOREDPROCEDURE >>= fun (_  as _1) ->(Lexer.literal ( >>= fun (_  as _2) ->(yard_rule_comma_list_8  >>= fun (_  as _3) ->(Lexer.literal ) |>> fun (_ as _4)   -> (_1,_2,_3,_4 ))))

 and private execute_character_string   = (attempt (Lexer.literal EXEC |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal EXECUTE |>> fun (_ as _1)   -> (_1 )) >>= fun (_  as _1) ->(Lexer.literal ( >>= fun (_  as _2) ->(many1 ( attempt((attempt (Lexer.pLOCALVAR |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.pSTRING_CONST |>> fun (_ as _1)   -> (_1 )) >>= fun (_  as _1) ->(opt ( attempt(Lexer.literal +)) |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _3) ->(Lexer.literal ) >>= fun (_  as _4) ->(opt ( attempt(Lexer.literal AS >>= fun (_  as _1) ->((attempt (Lexer.literal LOGIN |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal USER |>> fun (_ as _1)   -> (_1 )) >>= fun (_  as _2) ->(Lexer.literal = >>= fun (_  as _3) ->(Lexer.pSTRING_CONST |>> fun (_ as _4)   -> (_1,_2,_3,_4 )))))) >>= fun (_  as _5) ->(opt ( attempt(Lexer.literal ;)) |>> fun (_ as _6)   -> (_1,_2,_3,_4,_5,_6 ))))))

 and private execute_command   = (attempt (Lexer.literal EXEC |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal EXECUTE |>> fun (_ as _1)   -> (_1 )) >>= fun (_  as _1) ->(Lexer.literal ( >>= fun (_  as _2) ->(many1 ( attempt((attempt (Lexer.pLOCALVAR |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.pSTRING_CONST >>= fun (_  as _1) ->(opt ( attempt(Lexer.literal ?)) >>= fun (_  as _2) ->(opt ( attempt(Lexer.literal +)) |>> fun (_ as _3)   -> (_1,_2,_3 )))))) >>= fun (_  as _3) ->(many ( attempt(Lexer.literal , >>= fun (_  as _1) ->(sql_expr  >>= fun (_  as _2) ->(opt ( attempt(Lexer.literal OUTPUT)) |>> fun (_ as _3)   -> (_1,_2,_3 ))))) >>= fun (_  as _4) ->(Lexer.literal ) >>= fun (_  as _5) ->(opt ( attempt(Lexer.literal AS >>= fun (_  as _1) ->((attempt (Lexer.literal LOGIN |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal USER |>> fun (_ as _1)   -> (_1 )) >>= fun (_  as _2) ->(Lexer.literal = >>= fun (_  as _3) ->(Lexer.pSTRING_CONST |>> fun (_ as _4)   -> (_1,_2,_3,_4 )))))) >>= fun (_  as _6) ->(opt ( attempt(Lexer.literal AT >>= fun (_  as _1) ->(full_ident  |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _7) ->(opt ( attempt(Lexer.literal ;)) |>> fun (_ as _8)   -> (_1,_2,_3,_4,_5,_6,_7,_8 ))))))))

 and private type_size   = Lexer.literal ( >>= fun (_  as _1) ->((attempt (Lexer.pDEC_NUMBER |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal MAX |>> fun (_ as _1)   -> (_1 )) >>= fun (_  as _2) ->(Lexer.literal ) |>> fun (_ as _3)   -> (_1,_2,_3 )))

 and private sql_datatype   = (attempt (Lexer.literal BIGINT |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal NUMERIC |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal BIT |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal SMALLINT |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal DECIMAL |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal DATETIME |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal SMALLMONEY |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal SYSNAME |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal INT |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal TINYINT |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal MONEY |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal FLOAT >>= fun (_  as _1) ->(opt ( attempt(type_size )) |>> fun (_ as _2)   -> (_1,_2 )))) <|> ((attempt (Lexer.literal REAL |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal CHAR >>= fun (_  as _1) ->(opt ( attempt(type_size )) |>> fun (_ as _2)   -> (_1,_2 )))) <|> ((attempt (Lexer.literal VARCHAR >>= fun (_  as _1) ->(opt ( attempt(type_size )) |>> fun (_ as _2)   -> (_1,_2 )))) <|> ((attempt (Lexer.literal VARBINARY >>= fun (_  as _1) ->(opt ( attempt(type_size )) |>> fun (_ as _2)   -> (_1,_2 )))) <|> ((attempt (Lexer.literal NCHAR >>= fun (_  as _1) ->(opt ( attempt(type_size )) |>> fun (_ as _2)   -> (_1,_2 )))) <|> ((attempt (Lexer.literal NVARCHAR >>= fun (_  as _1) ->(opt ( attempt(type_size )) |>> fun (_ as _2)   -> (_1,_2 )))) <|> (Lexer.literal SQL_VARIANT |>> fun (_ as _1)   -> (_1 )))))))))))))))))))

 and private execute_as   = (attempt (Lexer.literal EXEC |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal EXECUTE |>> fun (_ as _1)   -> (_1 )) >>= fun (_  as _1) ->(Lexer.literal AS >>= fun (_  as _2) ->((attempt (Lexer.literal CALLER |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal SELF |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal OWNER |>> fun (_ as _1)   -> (_1 ))) <|> (ident  >>= fun (_  as _1) ->(Lexer.literal = >>= fun (_  as _2) ->(Lexer.pSTRING_CONST |>> fun (_ as _3)   -> (_1,_2,_3 )))))) |>> fun (_ as _3)   -> (_1,_2,_3 )))

 and private binop   = (attempt (Lexer.literal += |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal -= |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal *= |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal /= |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal %= |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal &= |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal ^= |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal |= |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal = |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal + |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal - |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal * |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal / |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal % |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal ~ |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal < |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal > |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal < >>= fun (_  as _1) ->(Lexer.literal > |>> fun (_ as _2)   -> (_1,_2 )) |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal < >>= fun (_  as _1) ->(Lexer.literal = |>> fun (_ as _2)   -> (_1,_2 )) |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal > >>= fun (_  as _1) ->(Lexer.literal = |>> fun (_ as _2)   -> (_1,_2 )) |>> fun (_ as _1)   -> (_1 ))))))))))))))))))))

 and private fetch_stmnt   = Lexer.literal FETCH >>= fun (_  as _1) ->(opt ( attempt(opt ( attempt((attempt (Lexer.literal NEXT |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal PRIOR |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal FIRST |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal LAST |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal ABSOLUTE >>= fun (_  as _1) ->((attempt (dec_num  |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.pLOCALVAR |>> fun (_ as _1)   -> (_1 )) |>> fun (_ as _2)   -> (_1,_2 )))) <|> (Lexer.literal RELATIVE >>= fun (_  as _1) ->((attempt (dec_num  |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.pLOCALVAR |>> fun (_ as _1)   -> (_1 )) |>> fun (_ as _2)   -> (_1,_2 ))))))))) >>= fun (_  as _1) ->(Lexer.literal FROM |>> fun (_ as _2)   -> (_1,_2 )))) >>= fun (_  as _2) ->((attempt (opt ( attempt(Lexer.literal GLOBAL)) >>= fun (_  as _1) ->(Lexer.pIDENT |>> fun (_ as _2)   -> (_1,_2 )))) <|> (Lexer.pLOCALVAR |>> fun (_ as _1)   -> (_1 )) >>= fun (_  as _3) ->(opt ( attempt(Lexer.literal INTO >>= fun (_  as _1) ->(yard_rule_comma_list_50  |>> fun (_ as _2)   -> (_1,_2 )))) |>> fun (_ as _4)   -> (_1,_2,_3,_4 ))))

 and private sql_expr   = (attempt (sql_value  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (scalar_function  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal ( >>= fun (_  as _1) ->(sql_expr  >>= fun (_  as _2) ->(Lexer.literal ) |>> fun (_ as _3)   -> (_1,_2,_3 ))))) <|> ((attempt (call_expr  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (full_ident  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (select_stmnt  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt ((attempt (Lexer.literal NOT |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal += |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal -= |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal ~ |>> fun (_ as _1)   -> (_1 )))) >>= fun (_  as _1) ->(sql_expr  |>> fun (_ as _2)   -> (_1,_2 )))) <|> ((attempt (Lexer.pGLOBALVAR |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.pLOCALVAR |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal * |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (sql_expr  >>= fun (_  as _1) ->(binop  >>= fun (_  as _2) ->(sql_expr  |>> fun (_ as _3)   -> (_1,_2,_3 ))))) <|> ((attempt (sql_expr  >>= fun (_  as _1) ->(Lexer.literal IS >>= fun (_  as _2) ->(opt ( attempt(Lexer.literal NOT)) >>= fun (_  as _3) ->(Lexer.literal NULL |>> fun (_ as _4)   -> (_1,_2,_3,_4 )))))) <|> ((attempt (ranking_windowed_function  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (aggregate_windowed_function  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (sql_expr  >>= fun (_  as _1) ->(Lexer.literal COLLATE >>= fun (_  as _2) ->(ident  |>> fun (_ as _3)   -> (_1,_2,_3 ))))) <|> ((attempt (case  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (begin_transaction  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (Lexer.literal EXISTS >>= fun (_  as _1) ->(sql_expr  |>> fun (_ as _2)   -> (_1,_2 )))) <|> ((attempt (Lexer.literal IS_MEMBER >>= fun (_  as _1) ->(Lexer.literal ( >>= fun (_  as _2) ->(Lexer.pSTRING_CONST >>= fun (_  as _3) ->(Lexer.literal ) |>> fun (_ as _4)   -> (_1,_2,_3,_4 )))))) <|> ((attempt (sql_expr  >>= fun (_  as _1) ->((attempt (Lexer.literal AND |>> fun (_ as _1)   -> (_1 ))) <|> (Lexer.literal OR |>> fun (_ as _1)   -> (_1 )) >>= fun (_  as _2) ->(sql_expr  |>> fun (_ as _3)   -> (_1,_2,_3 ))))) <|> ((attempt (Lexer.literal TYPE >>= fun (_  as _1) ->(Lexer.literal FROM >>= fun (_  as _2) ->(full_ident  |>> fun (_ as _3)   -> (_1,_2,_3 ))))) <|> ((attempt (fetch_stmnt  |>> fun (_ as _1)   -> (_1 ))) <|> ((attempt (sql_expr  >>= fun (_  as _1) ->(opt ( attempt(Lexer.literal NOT)) >>= fun (_  as _2) ->(Lexer.literal IN >>= fun (_  as _3) ->(Lexer.literal ( >>= fun (_  as _4) ->(yard_rule_comma_list_8  >>= fun (_  as _5) ->(Lexer.literal ) |>> fun (_ as _6)   -> (_1,_2,_3,_4,_5,_6 )))))))) <|> (sql_expr  >>= fun (_  as _1) ->(opt ( attempt(Lexer.literal NOT)) >>= fun (_  as _2) ->(Lexer.literal LIKE >>= fun (_  as _3) ->(sql_expr  |>> fun (_ as _4)   -> (_1,_2,_3,_4 )))))))))))))))))))))))))))

 and private call_expr   = full_ident  >>= fun (_  as _1) ->(Lexer.literal ( >>= fun (_  as _2) ->(yard_rule_comma_list_61  >>= fun (_  as _3) ->(Lexer.literal ) |>> fun (_ as _4)   -> (_1,_2,_3,_4 ))))

 and private yard_rule_comma_list_61   = yard_rule_list_62  |>> fun (_ as _1)   -> (_1 )

 and private yard_rule_list_62   = (attempt (preturn  [] )) <|> ((attempt (sql_datatype  |>> fun (_ as _1)   -> (_1 ))) <|> (sql_expr  |>> fun (_ as _1)   -> (_1 )) >>= fun (hd ) -> (many ( attempt(Lexer.literal , >>= fun (_  as _1) ->((attempt (sql_datatype  |>> fun (_ as _1)   -> (_1 ))) <|> (sql_expr  |>> fun (_ as _1)   -> (_1 )) |>> fun (_ as _2)   -> (_2 )))) |>> fun (tl) -> (hd::tl) )  )