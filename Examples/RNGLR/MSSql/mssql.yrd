(*
  mssql.yrd contains grammar of MS-SQL\T-SQL.
  
  Copyright 2012 Anastasiya Ragozina <ragozina.anastasiya@gmail.com>

  This file is part of YaccConctructor.

  YaccConstructor is free software:you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*)

include "../../../GrammarTemplates/Common.yrd"

[<Start>]
root_rule: (batch_body "GO")+

batch_body: 
   create_proc
 | set_stmnt
  
(*****************************************SET****************************************************)

set_stmnt:
	KW_SET (
		"ANSI_NULLS" | "ANSI_DEFAULTS" | "ANSI_NULL_DFLT" 
        	 | "ANSI_PADDING" | "ANSI_WARNINGS" | "CONCAT_NULL_YIELDS_NULL"
	         | "CURSOR_CLOSE_ON_COMMIT" | "QUOTED_IDENTIFIER" 
                 | "FMTONLY" | "FORCEPLAN" | "IMPLICIT_TRANSACTIONS"
                 | "NOCOUNT" | "NOEXEC" | "NUMERIC_ROUNDABORT" | "PARSEONLY"
                 | "REMOTE_PROC_TRANSACTIONS" | "SHOWPLAN_ALL" | "SHOWPLAN_TEXT"
                 | "SHOWPLAN_XML" | "STATISTICS" ("IO" | "PROFILE" | "TIME" | "XML")
                 | "XACT_ABORT" ) 
              (KW_ON | KW_OFF)
	| set_localvar

set_localvar:
    KW_SET
	( 
		LOCALVAR 
		(DOUBLE_COLON property_name | ident )? OP_EQ sql_expr | udt_name ( DOT | DOUBLE_COLON ) ident LPAREN comma_list<<proc_formal_param>> RPAREN (*свойство пользовательского типа или общее поле польз типа*)
	)
	|
	( LOCALVAR OP_EQ 
		( LOCALVAR | ident | ( KW_CURSOR ( KW_FORWARD_ONLY | KW_SCROLL )? 
		( KW_STATIC | KW_KEYSET | KW_DYNAMIC | KW_FAST_FORWARD )? 
		( KW_READ_ONLY | KW_SCROLL_LOCKS | KW_OPTIMISTIC )? 
		KW_TYPE_WARNING? 
		KW_FOR select_stmnt 
		( KW_FOR ( KW_EAD ONLY | KW_UPDATE ( KW_OF comma_list<<ident>> )?))? 
		) 
		)
	) 	
	
(*********************************PROCEDURE************************************************************)	

proc_formal_param:
      LOCALVAR (full_ident DOT)? sql_datatype
      KW_VARYING? (OP_EQ (KW_NULL | DEC_NUMBER | STRING_CONST) )?
      (KW_OUT | KW_OUTPUT)? KW_READONLY?	  	  
  
create_proc:
    KW_CREATE ("PROCEDURE" | "PROC")
    (ident DOT)? ident (SEMI DEC_NUMBER)?  
    (comma_list<<proc_formal_param>>)? 
    (KW_WITH (execute_as)+ )? 
	(*(KW_WITH list<<procedure_option COMMA>>)?*)
	( KW_FOR KW_REPLICATION )?
    KW_AS KW_BEGIN? (proc_body_stmnt SEMI?)* KW_END?
    SEMI?

procedure_option: 
      "ENCRYPTION"?
    | "RECOMPILE"?
    | "EXECUTE_AS_Clause"?

proc_body_stmnt:
     select_stmnt
   | set_stmnt
   | execute_stmnt
   | sql_expr
   | declare
   | KW_RETURN sql_expr
   | KW_IF sql_expr KW_THEN ( (KW_BEGIN sql_expr* KW_END) | sql_expr) (KW_ELSE (KW_BEGIN sql_expr* KW_END) | sql_expr)?
   | raiserror_stmnt

raiserror_stmnt:
    KW_RAISERROR LPAREN ( DEC_NUMBER | STRING_CONST | LOCALVAR )
    ( COMMA DEC_NUMBER COMMA DEC_NUMBER )
    ( COMMA comma_list<<LOCALVAR>> )? RPAREN
    ( KW_WITH comma_list<< ("LOG" | "NOWAIT" | "SETERROR")>> )?
   
(***********************************DECLARE**********************************************************)

declare:  
    KW_DECLARE 
    comma_list<<(
		LOCALVAR KW_AS? sql_datatype
		| ident KW_CURSOR
		| ident KW_AS? table_type_definition
    )>>

table_type_definition: 
     KW_TABLE LPAREN (column_definition | table_constraint)* RPAREN 

column_definition:
	ident (("scalar_data_type") | (KW_AS sql_expr))
    (KW_COLLATE ident)? 
    ((KW_DEFAULT sql_expr)? | KW_IDENTITY (DEC_NUMBER COMMA DEC_NUMBER)? )? 
    (KW_ROWGUIDCOL)? 
    (column_constraint)? 

column_constraint: 
	((KW_NULL | KW_NOT KW_NULL)? 
    | (KW_PRIMARY KW_KEY | KW_UNIQUE)?
    | KW_CHECK sql_expr 
    ) 

table_constraint: 
     ((KW_PRIMARY KW_KEY | KW_UNIQUE) LPAREN comma_list<<ident>> RPAREN) 
     | (KW_CHECK LPAREN search_condition RPAREN) 
       
(*****************************************SELECT****************************************************)


select_stmnt:  
	(KW_WITH comma_list<<common_table_expression>>)?
	query_expression 
    (KW_ORDER KW_BY comma_list<<(full_ident|DEC_NUMBER (KW_ASC | KW_DESC)?)>>)? 
    (KW_COMPUTE 
		comma_list<<(KW_AVG | KW_COUNT | KW_MAX | KW_MIN | KW_SUM LPAREN sql_expr RPAREN)>> 
		(KW_BY comma_list<<sql_expr>>)? 
    )? 
    for? 
    (KW_OPTION LPAREN comma_list<<query_hint>> RPAREN)? 
	
for:
	(KW_FOR (KW_BROWSE | xml))?
	(*questions*)
xml:
	KW_XML 
	( 
		(KW_RAW (LPAREN STRING_CONST RPAREN)? | KW_AUTO) 
		( 
			common_directives
			(COMMA (KW_XMLDATA | KW_XMLSCHEMA (LPAREN STRING_CONST RPAREN)?))? 
			(COMMA KW_ELEMENTS (KW_XSINIL | KW_ABSENT)?)?
		)?
		| KW_EXPLICIT 
			( 
				common_directives 
				(COMMA KW_XMLDATA)? 
			)?
		| KW_PATH (LPAREN STRING_CONST RPAREN)? 
			(
				common_directives 
				(COMMA KW_ELEMENTS (KW_XSINIL | KW_ABSENT)?)?
			)?
	)

common_directives:
	(COMMA KW_BINARY KW_BASE64)?
	(COMMA KW_TYPE)?
	(COMMA KW_ROOT (LPAREN STRING_CONST RPAREN)?)?

query_hint: 
	((KW_HASH | KW_ORDER) KW_GROUP 
	| (KW_CONCAT | KW_HASH | KW_MERGE) KW_UNION 
	| (KW_LOOP | KW_MERGE | KW_HASH) KW_JOIN 
	| KW_FAST DEC_NUMBER
	| KW_FORCE KW_ORDER 
	| KW_MAXDOP DEC_NUMBER 
	| KW_OPTIMIZE KW_FOR LPAREN comma_list<<(LOCALVAR OP_EQ STRING_CONST)>>RPAREN  
	| KW_PARAMETERIZATION (KW_SIMPLE | KW_FORCED)
	| KW_RECOMPILE
	| KW_ROBUST KW_PLAN 
	| KW_KEEP KW_PLAN 
	| KW_KEEPFIXED KW_PLAN
	| KW_EXPAND KW_VIEWS 
	| KW_MAXRECURSION DEC_NUMBER 
	| KW_USE KW_PLAN STRING_CONST    
	) 
	
common_table_expression:
    full_ident (LPAREN comma_list<<ident>> RPAREN)?
    KW_AS
        LPAREN select_stmnt RPAREN
SEMI?
	
query_expression: 
    query_specification | LPAREN query_expression RPAREN 
    ((KW_UNION (KW_ALL)? | KW_EXCEPT | KW_INTERSECT)
    query_specification | comma_list<<(LPAREN query_expression RPAREN)>>)? 
		
query_specification: 
	KW_SELECT (KW_ALL | KW_DISTINCT)? 
	(KW_TOP sql_expr KW_PERCENT? (KW_WITH KW_TIES)?)? 
	select_list                                           (**********************) 
	(KW_INTO full_ident)? 
	from? 
	(KW_WHERE search_condition)? 
	(KW_GROUP KW_BY KW_ALL? comma_list<<group_by_expression>>
        (KW_WITH (KW_CUBE | KW_ROLLUP))?
	)?
    (KW_HAVING search_condition)? 
	
group_by_expression:
	( STRING_CONST (*| scalar_function*) | (full_ident DOT)? full_ident | LOCALVAR  (*&&&&&&*)
	| LPAREN sql_expr RPAREN | LPAREN select_stmnt RPAREN 
    | binop sql_expr 
    | sql_expr binop sql_expr 
    | ranking_windowed_function | aggregate_windowed_function
	)

aggregate_windowed_function:
	KW_OVER LPAREN ((KW_PARTITION KW_BY LOCALVAR | select_stmnt)*)? RPAREN

ranking_windowed_function:
		(KW_RANK | KW_DENSE_RANK | KW_ROW_NUMBER | KW_NTILE) LPAREN (sql_expr)? RPAREN KW_OVER LPAREN 
		((KW_PARTITION KW_BY LOCALVAR|select_stmnt|full_ident)*)?
        order_by_clause RPAREN
	
order_by_clause:
	(KW_ORDER KW_BY 
		comma_list<<(ident|DEC_NUMBER (KW_COLLATE ident)? (KW_ASC | KW_DESC)?)>>
	)? 
	
search_condition: 
    KW_NOT? predicate | LPAREN search_condition RPAREN 
	(comma_list<<(KW_AND | KW_OR KW_NOT? predicate | LPAREN search_condition RPAREN)>>)?

predicate: 
    sql_expr binop sql_expr 
    | STRING_CONST KW_NOT? KW_LIKE STRING_CONST                     
		(KW_ESCAPE STRING_CONST)?                                                
    | sql_expr KW_NOT? KW_BETWEEN sql_expr KW_AND sql_expr 
    | sql_expr KW_IS KW_NOT? KW_NULL  
    | sql_expr binop                     
		(KW_ALL | KW_SOME | KW_ANY) LPAREN query_expresssion RPAREN            
    | KW_EXISTS LPAREN query_expresssion RPAREN  

from:
( KW_FROM comma_list<<table_source>> )? 

table_source: 
	
	full_ident KW_AS?  full_ident tablesample_clause? 
		(KW_WITH LPAREN table_hint COMMA* RPAREN)? 
    | rowset_function (KW_AS? full_ident)? 
        (LPAREN comma_list<<ident>> RPAREN)?  
    | user_defined_function (KW_AS full_ident)? (LPAREN comma_list<<full_ident>> RPAREN)? 
    (*| openxml_clause*)
    | full_ident  KW_AS? full_ident (LPAREN comma_list<<full_ident>> RPAREN)? 
    | joined_table 
    | pivoted_table 
    (*| <unpivoted_table>*)                                                      (*&&&&&&&&*)
    | LOCALVAR (KW_AS full_ident)?
    | LOCALVAR DOT ident LPAREN comma_list<<sql_expression>> RPAREN (KW_AS full_ident)? (LPAREN comma_list<<full_ident>> RPAREN)?

(*
(*O_O*)
openxml_clause:
OPENXML LPAREN idoc int [ in] , rowpattern nvarchar [ in ] , [ flags byte [ in ] ] RPAREN 
( WITH LPAREN SchemaDeclaration | TableName RPAREN )?           (*&&&&&&&&&&&&&&&&&&&&&&&&&&&&*)*)

rowset_function:
	containstable
	| freetexttable
	| opendatasource
	| openquery
	| openrowset
	| openxml
(*
CONTAINSTABLE ( table , { column_name | (column_list ) | * } , ' < contains_search_condition > ' 
     [ , LANGUAGE language_term] 
  [ ,top_n_by_rank ] 
          ) 
< contains_search_condition > ::= 
    { < simple_term > 
    | < prefix_term > 
    | < generation_term > 
    | < proximity_term > 
     |  < weighted_term > 
    } 
    | { ( < contains_search_condition > ) 
    { { AND | & } | { AND NOT | &! } | { OR | | } } 
     < contains_search_condition > [ ...n ] 
    }
< simple_term > ::= 
          word | " phrase "
< prefix term > ::= 
     { "word * " | "phrase *" } 
< generation_term > ::= 
     FORMSOF ( { INFLECTIONAL | THESAURUS } , < simple_term > [ ,...n ] ) 
< proximity_term > ::= 
     { < simple_term > | < prefix_term > } 
     { { NEAR | ~ } { < simple_term > | < prefix_term > } } [ ...n ] 
< weighted_term > ::= 
     ISABOUT
        ( { { 
  < simple_term > 
  | < prefix_term > 
  | < generation_term > 
  | < proximity_term > 
  } 
   [ WEIGHT ( weight_value ) ] 
   } [ ,...n ] 
        )*)
table_hint: 
	(KW_NOEXPAND )? 
	(KW_INDEX LPAREN comma_list<<ident>> RPAREN  	
		| KW_FASTFIRSTROW 
		| KW_HOLDLOCK 
		| KW_NOLOCK 
		| KW_NOWAIT
		| KW_PAGLOCK 
		| KW_READCOMMITTED 
		| KW_READCOMMITTEDLOCK 
		| KW_READPAST 
		| KW_READUNCOMMITTED 
		| KW_REPEATABLEREAD 
		| KW_ROWLOCK 
		| KW_SERIALIZABLE 
		| KW_TABLOCK 
		| KW_TABLOCKX 
		| KW_UPDLOCK 
		| KW_XLOCK 
	) 

table_hint_limited:
	(
		KW_KEEPIDENTITY 
	| KW_KEEPDEFAULTS 
	| KW_FASTFIRSTROW 
	| KW_HOLDLOCK 
	| KW_IGNORE_CONSTRAINTS 
	| KW_IGNORE_TRIGGERS 
	| KW_NOWAIT
	| KW_PAGLOCK 
	| KW_READCOMMITTED 
	| KW_READCOMMITTEDLOCK 
	| KW_READPAST 
	| KW_REPEATABLEREAD 
	| KW_ROWLOCK 
	| KW_SERIALIZABLE 
	| KW_TABLOCK 
	| KW_TABLOCKX 
	| KW_UPDLOCK 
	| KW_XLOCK 
	)?

tablesample_clause:
    KW_TABLESAMPLE KW_SYSTEM? LPAREN sql_expr ( KW_PERCENT | KW_ROWS )? RPAREN  
        ( KW_REPEATABLE LPAREN sql_expr RPAREN )?                            

joined_table: 
	(
		table_source join_type table_source KW_ON search_condition 
		| table_source KW_CROSS KW_JOIN table_source 
		| left_table_source (KW_CROSS | KW_OUTER) KW_APPLY right_table_source  (*OOOOOOOOOOO*)
		| LPAREN? joined_table RPAREN? 
	)

join_type: 
    (KW_INNER | ((KW_LEFT | KW_RIGHT | KW_FULL) KW_OUTER?) (join_hint)?)?
    KW_JOIN

join_hint: 
      KW_LOOP 
	  | KW_HASH 
	  | KW_MERGE 
	  | KW_REMOTE 

pivoted_table:
        table_source KW_PIVOT pivot_clause full_ident

pivot_clause:
        LPAREN aggregate_function ( value_column )  (*vt*)
        KW_FOR pivot_column 
        KW_IN LPAREN <column_list> RPAREN      (*&&&&&&&&&&*) 
		RPAREN 

unpivoted_table:
        table_source KW_UNPIVOT unpivot_clause full_ident

unpivot_clause:
        LPAREN value_column KW_FOR pivot_column KW_IN LPAREN comma_list<<full_ident>> RPAREN RPAREN (*&&&&&&&&&&*)
 
	
(*****************************************ALTER TABLE****************************************************)
ALTER TABLE ( ident DOT ( ident )? DOT | ident DOT )? ident 
( 
    KW_ALTER KW_COLUMN ident 
    ( 
        ( ident DOT )? type_name ( ( { precision [ , scale ]       (*???????????????*)
            | max | xml_schema_collection } ) )? 
        ( KW_COLLATE ident )?
        ( KW_NULL | KW_NOT KW_NULL ) 
    | (KW_ADD | KW_DROP ) ( "ROWGUIDCOL" | "PERSISTED" | "NOT FOR REPLICATION" )
    )
    | ( KW_WITH ( KW_CHECK | KW_NOCHECK ) )? KW_ADD 
    { 
        <column_definition>
      | <computed_column_definition>                 (*??????????????????*)
      | <table_constraint> 
    } [ ,...n ]
    | KW_DROP 
    (list<<( 
        ( KW_CONSTRAINT )? ident 
        ( KW_WITH (list<<drop_clustered_constraint_option COMMA>>) )?          (*???????????*)
        | KW_COLUMN ident)
    COMMA>> )
    | ( KW_WITH ( KW_CHECK | KW_NOCHECK ) )? ( KW_CHECK | KW_NOCHECK ) KW_CONSTRAINT 
        ( KW_ALL | (list<<ident COMMA>>)) 
    | ( KW_ENABLE | KW_DISABLE ) KW_TRIGGER 
        ( KW_ALL | list<<ident COMMA>>)
    | KW_SWITCH ( KW_PARTITION source_partition_number_expression )?         (*????*)
        KW_TO ident 
        ( kw_PARTITION target_partition_number_expression )?          
)
SEMI?

drop_clustered_constraint_option:  
    ( 
        KW_MAXDOP = max_degree_of_parallelism (*DEC_NUMBER*)
      | KW_ONLINE = (KW_ON | KW_OFF)
      | KW_MOVE KW_TO ( ident LPAREN ident RPAREN | filegroup    (*??*)
          | "default")
    )

(*
begin_transaction:
KW_BEGIN ( KW_TRAN | KW_TRANSACTION ) 
    ( ( ident | LOCALVAR )     (*????????/*)
      ( KW_WITH KW_MARK ( STRING_CONST ) )?
    )?
( SEMI )?      (* proc_body_stmt?*)

rollback:
KW_ROLLBACK ( KW_TRAN | KW_TRANSACTION ) 
     ( ident)? 
( SEMI )?
commit:
KW_COMMIT ( KW_TRAN | KW_TRANSACTION ) ( transaction_name | @tran_name_variable )?  (*????????/*)
( SEMI )?
	*)


execute_stmnt:
	execute_proc|execute_character_string|execute_command
	
execute_proc:
( KW_EXEC | KW_EXECUTE  )?
    ( 
      ( LOCALVAR OP_EQ )?
      ( full_ident ( SEMI DEC_NUMBER )? | LOCALVAR )? 
        comma_list<<( ( LOCALVAR OP_EQ )? ( VALUE                         (*?????*)
                           | LOCALVAR KW_OUTPUT? 
                           | KW_DEFAULT? 
                           )
        )?>>
       (KW_WITH KW_RECOMPILE)?
    )
SEMI?

execute_character_string:
( KW_EXEC | KW_EXECUTE ) 
        LPAREN { @string_variable | [ N ]'tsql_string' } [ + ...n ] RPAREN    (***&&&&&&&&&&&&&&&&&&&&)
    ( KW_AS ( KW_LOGIN | KW_USER ) OP_EQ ' name ' )?
SEMI?

execute_command:
( KW_EXEC | KW_EXECUTE )
        LPAREN ( LOCALVAR | [ N ] 'command_string [ ? ] ' ) [ + ...n ]
        [ { , { value | @variable [ OUTPUT ] } } [ ...n ] ]
        RPAREN 
    [ AS { LOGIN | USER } = ' name ' ]
    [ AT linked_server_name ]
[;]

type_size : LPAREN (DEC_NUMBER | KW_MAX) RPAREN

sql_datatype:
      KW_BIGINT | KW_NUMERIC | KW_BIT | KW_SMALLINT  | KW_DECIMAL | "SMALLMONEY"  | "sysname"
    | "INT" | KW_TINYINT | KW_MONEY
    | KW_FLOAT (LPAREN DEC_NUMBER RPAREN)?  (* http://msdn.microsoft.com/en-us/library/ms173773.aspx *)
    | KW_REAL
    | KW_CHAR (LPAREN DEC_NUMBER RPAREN)?
    | KW_VARCHAR type_size?
    | "varbinary" type_size?
    | KW_NCHAR (LPAREN DEC_NUMBER RPAREN)?   (* http://msdn.microsoft.com/en-us/library/ms186939.aspx *)
    | KW_NVARCHAR type_size?

execute_as: (KW_EXEC | KW_EXECUTE) KW_AS (KW_CALLER | KW_SELF | KW_OWNER | username = STRING_CONST) 

binop:
	 OP_PLUS_EQ | OP_MINUS_EQ | OP_MUL_EQ | OP_DIV_EQ | OP_MOD_EQ | OP_AND_EQ | OP_XOR_EQ | OP_OR_EQ
	| OP_EQ | OP_PLUS | OP_MINUS | OP_MUL | OP_DIV | OP_MOD | OP_TILDA
	| OP_LT | OP_MT | (OP_LT OP_EQ) | (OP_MT OP_EQ) | (OP_LT OP_GT)


(* http://msdn.microsoft.com/en-us/library/ms190286.aspx *)
sql_expr:
    sql_value
  | LPAREN sql_expr RPAREN
  | LOCALVAR 
  | full_ident LPAREN comma_list<<sql_expr>> RPAREN
  | KW_SELECT sql_expr KW_FROM IDENT
  | (OP_PLUS_EQ | OP_MINUS_EQ | OP_TILDA) sql_expr 
  | GLOBALVAR
  | full_ident
  | sql_expr binop sql_expr
  | sql_value

comma_list<<item>>: list<<item COMMA>>

sql_value:
     STRING_CONST   (* http://msdn.microsoft.com/en-us/library/ms179899.aspx *)
   | DEC_NUMBER
   | KW_NULL

(* http://msdn.microsoft.com/en-us/library/ms175874.aspx *)
ident: brace_opt<<LBRACKET IDENT RBRACKET>>

full_ident: not_empty_list<<ident DOT>>
