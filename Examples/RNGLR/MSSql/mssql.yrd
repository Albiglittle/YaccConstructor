include "../../../GrammarTemplates/Common.yrd"

[<Start>]
root_rule: (batch_body "GO")+

batch_body: 
    create_proc 
 |  start2
 |  set_stmnt

start2: 
    sel_expr = KW_SELECT ident KW_FROM ident
  | GLOBALVAR
  | GLOBALTEMPOBJ
  | TEMPOBJ
(*****************************************SET****************************************************)
set_stmnt:
	"SET" (
		"ANSI_NULLS" | "ANSI_DEFAULTS" | "ANSI_NULL_DFLT" 
        	 | "ANSI_PADDING" | "ANSI_WARNINGS" | "CONCAT_NULL_YIELDS_NULL"
	         | "CURSOR_CLOSE_ON_COMMIT" | "QUOTED_IDENTIFIER" 
                 | "FMTONLY" | "FORCEPLAN" | "IMPLICIT_TRANSACTIONS"
                 | "NOCOUNT" | "NOEXEC" | "NUMERIC_ROUNDABORT" | "PARSEONLY"
                 | "REMOTE_PROC_TRANSACTIONS" | "SHOWPLAN_ALL" | "SHOWPLAN_TEXT"
                 | "SHOWPLAN_XML" | "STATISTICS" ("IO" | "PROFILE" | "TIME" | "XML")
                 | "XACT_ABORT" ) 
              (KW_ON | KW_OFF)
	| "SET" LOCALVAR (DOT IDENT)? OP_EQ ( sql_expr | IDENT (DOT | DOUBLE_COLON) IDENT )

set_localvar:
KW_SET 
	( 
		LOCALVAR 
		(DOUBLE_COLON property_name | ident )? = sql_expr | udt_name ( DOT | DOUBLE_COLON ) ident LPAREN comma_list<<proc_formal_param>> RPAREN (*свойство пользовательского типа или общее поле польз типа*)
	)
	|
	( LOCALVAR = 
		( LOCALVAR | ident | ( KW_CURSOR ( KW_FORWARD_ONLY | KW_SCROLL )? 
		( KW_STATIC | KW_KEYSET | KW_DYNAMIC | KW_FAST_FORWARD )? 
		( KW_READ_ONLY | KW_SCROLL_LOCKS | KW_OPTIMISTIC )? 
		( KW_TYPE_WARNING )? 
		KW_FOR select_stmnt 
		( KW_FOR ( KW_EAD ONLY | KW_UPDATE ( KW_OF comma_list<<ident>> )? ) )? 
		) 
		)
	) 	
	


(*********************************PROCEDURE************************************************************)	
proc_formal_param:
      LOCALVAR (full_ident DOT)? sql_datatype
      KW_VARYING? (OP_EQ (KW_NULL | DEC_NUMBER | STRING_CONST) )?
      (KW_OUT | KW_OUTPUT)? KW_READONLY?	  	  
  
create_proc:
    KW_CREATE ("PROCEDURE" | "PROC")
    (ident DOT)? ident (SEMI DEC_NUMBER)?  
    (comma_list<<proc_formal_param>>)? 
    (KW_WITH (execute_as)+ )? 
	(*(KW_WITH list<<procedure_option COMMA>>)?*)
	( KW_FOR KW_REPLICATION )?
    KW_AS KW_BEGIN? (proc_body_stmnt SEMI?)* KW_END?
    SEMI?

procedure_option: 
    ( "ENCRYPTION" )?
    ( "RECOMPILE" )?
    ( "EXECUTE_AS_Clause" )?

proc_body_stmnt:
     select_stmnt
   | set_stmnt 
   | execute_stmnt
   | sql_expr
   |  declare
   | KW_RETURN sql_expr
   | KW_IF sql_expr KW_THEN ( (KW_BEGIN sql_expr* KW_END) | sql_expr) (KW_ELSE (KW_BEGIN sql_expr* KW_END) | sql_expr)?
   | raiserror_stmnt

raiserror_stmnt:
    KW_RAISERROR LPAREN ( DEC_NUMBER | STRING_CONST | LOCALVAR )
    ( COMMA DEC_NUMBER COMMA DEC_NUMBER )
    ( COMMA comma_list<<LOCALVAR>> )? RPAREN
    ( KW_WITH comma_list<< "LOG" | "NOWAIT" | "SETERROR">> )?
   
(***********************************DECLARE**********************************************************)
declare:  
KW_DECLARE 
    (
		LOCALVAR (KW_AS)? sql_datatype  
		|  ident KW_CURSOR  
		| ( ident (KW_AS)? table_type_definition ) 
     )+

table_type_definition: 
     KW_TABLE LPAREN ((column_definition) | (table_constraint) )* RPAREN 

column_definition:
          ident ( ("scalar_data_type") | (KW_AS sql_expr) )
     ( KW_COLLATE IDENT )? 
     ( ( KW_DEFAULT sql_expr )? | KW_IDENTITY ( ( DEC_NUMBER,DEC_NUMBER ) )? )? 
     ( KW_ROWGUIDCOL )? 
     (column_constraint)? 

column_constraint: 
     ( ( KW_NULL | KW_NOT KW_NULL )? 
     | ( KW_PRIMARY KW_KEY | KW_UNIQUE )?
     | KW_CHECK ( sql_expr ) 
     ) 

table_constraint: 
     ( ( KW_PRIMARY KW_KEY | KW_UNIQUE ) LPAREN list<<IDENT COMMA>> RPAREN) 
     | (CHECK LPAREN search_condition RPAREN) 
       
(*****************************************SELECT****************************************************)
(* http://msdn.microsoft.com/en-us/library/ms189499.aspx *)
select_stmnt:
(*  list<<(KW_WITH common_table_expression)* COMMA>> *)
    query_expression
    (KW_INTO full_ident (* http://msdn.microsoft.com/en-us/library/ms188029.aspx *) )?
;

(*
select_stmnt: 
    lаist<<(KW_WITH common_table_expression)* COMMA>>
    query_expression
    (KW_ORDER KW_BY list<<(sql_expr | DEC_NUMBER (KW_ASC | KW_DESC))* COMA>>)?       (*???*)
    (compute)? 
    (for_clause)? 
    (select_stmnt_option)? 
	
compute:
	"COMPUTE" list<<("AVG" | "COUNT" | KW_MAX | KW_MIN | "STDEV" | "STDEVP" | KW_VAR | KW_VARP | KW_SUM) (sql_expr) COMMA>> 
    (list<<KW_BY sql_expr COMMA>>)?  
;

for_clause:
	(KW_FOR (BROWSE | xml))?

xml:
	KW_XML 
	(("RAW" ((STRING_CONST))? | "AUTO") (*??*)
		( 
			commonDirectives 
			( , ("XMLDATA" | "XMLSCHEMA" ( ( STRING_CONST ) )? ) )?  
			( , "ELEMENTS" ( "XSINIL" | "ABSENT" )? )?
		)?
	| "EXPLICIT" 
		( 
			comonDirictives 
			( , "XMLDATA" )? 
		)?
	| "PATH" ( ( STRING_CONST ) )?        
		(
			commonDirectives 
			( , KW_ELEMENTS ( KW_XSINIL | KW_ABSENT )? )?
		)?
	) 	
;	
 
 commonDirectives:
( , KW_BINARY_BASE64 )?
( , KW_TYPE )?
( , KW_ROOT ( ( STRING_CONST ) )? )?             

select_stmnt_option:
	( "OPTION" ( <query_hint> [ ,...n ] ) )?              (*?????????????????*)

query_expression: 
    (query_specification | ( LPAREN query_expression RPAREN )) 
    (  ( KW_UNION KW_ALL?| KW_EXCEPT | KW_INTERSECT )
        query_specification | (list<<(query_expression) COMMA>> ) )? 
		
query_specification: 
KW_SELECT ( KW_ALL | KW_DISTINCT )? 
    (KW_TOP LPAREN sql_expr RPAREN KW_PRESENT? ( KW_WITH KW_TIES )? )?                  (*??????*)
       list<<  (       
            STAR
        |   full_ident DOT STAR
        |   (
                (full_ident DOT)? (IDENT | (DOLLAR KW_IDENTITY) | (DOLLAR KW_ROWGUID) )
            |   udt_column_runtime = IDENT (
                    (DOT | DOUBLE_COLON)
                    (IDENT | IDENT LPAREN comma_list<<sql_expr>> RPAREN)
                )?
            |   sql_expr ( KW_AS? IDENT)?
            )
        |   IDENT OP_EQ sql_expr
        )
        COMMA>>                                                 (*?????????*)
    ( KW_INTO ident )? 
    ( KW_FROM list<< table_source COMMA>> )? (*?????????*)
    ( KW_WHERE search_condition )?                             (*?????????*)
    ( KW_GROUP KW_BY ( KW_ALL )? list<<sql_expr COMMA>> (*?????????*)
                ( KW_WITH ( "CUBE" | "ROLLUP" ) )?
    )?
    ( KW_HAVING search_condition )?                            (*?????????*)

	
search_condition: 
    ( KW_NOT? predicate | LPAREN search_condition RPAREN ) 
   ( list<< ( KW_AND | KW_OR ) KW_NOT? ( predicate | LPAREN search_condition RPAREN )  COMMA>>)?

predicate: 
    ( sql_expr ( OP_EQ | (OP_LT OP_MT) | OP_MT | OP_LT_EQ | OP_MT_EQ ) sql_expr 
    | STRING_CONST KW_NOT? KW_LIKE STRING_CONST                     
  ( KW_ESCAPE STRING_CONST )?                                                
    | sql_expr KW_NOT? KW_BETWEEN sql_expr KW_AND sql_expr 
    | sql_expr KW_IS KW_NOT? KW_NULL  
    | sql_expr ( OP_EQ | (OP_LT OP_MT) | OP_MT | OP_LT_EQ | OP_MT_EQ )                     
  ( KW_ALL | KW_SOME | KW_ANY) LPAREN query_expresssion RPAREN            
    | KW_EXISTS LPAREN query_expresssion RPAREN     )                         
	
(*****************************************ALTER TABLE****************************************************)
ALTER TABLE ( ident DOT ( ident )? DOT | ident DOT )? ident 
( 
    KW_ALTER KW_COLUMN ident 
    ( 
        ( ident DOT )? type_name ( ( { precision [ , scale ]       (*???????????????*)
            | max | xml_schema_collection } ) )? 
        ( KW_COLLATE ident )?
        ( KW_NULL | KW_NOT KW_NULL ) 
    | (KW_ADD | KW_DROP ) ( "ROWGUIDCOL" | "PERSISTED" | "NOT FOR REPLICATION" )
    )
    | ( KW_WITH ( KW_CHECK | KW_NOCHECK ) )? KW_ADD 
    { 
        <column_definition>
      | <computed_column_definition>                 (*??????????????????*)
      | <table_constraint> 
    } [ ,...n ]
    | KW_DROP 
    (list<<( 
        ( KW_CONSTRAINT )? ident 
        ( KW_WITH (list<<drop_clustered_constraint_option COMMA>>) )?          (*???????????*)
        | KW_COLUMN ident)
    COMMA>> )
    | ( KW_WITH ( KW_CHECK | KW_NOCHECK ) )? ( KW_CHECK | KW_NOCHECK ) KW_CONSTRAINT 
        ( KW_ALL | (list<<ident COMMA>>)) 
    | ( KW_ENABLE | KW_DISABLE ) KW_TRIGGER 
        ( KW_ALL | list<<ident COMMA>>)
    | KW_SWITCH ( KW_PARTITION source_partition_number_expression )?         (*????*)
        KW_TO ident 
        ( kw_PARTITION target_partition_number_expression )?          
)
SEMI?

drop_clustered_constraint_option:  
    ( 
        KW_MAXDOP = max_degree_of_parallelism (*DEC_NUMBER*)
      | KW_ONLINE = (KW_ON | KW_OFF)
      | KW_MOVE KW_TO ( ident LPAREN ident RPAREN | filegroup    (*??*)
          | "default")
    )

(*
begin_transaction:
KW_BEGIN ( KW_TRAN | KW_TRANSACTION ) 
    ( ( ident | @tran_name_variable )     (*????????/*)
      ( KW_WITH KW_MARK ( STRING_CONST ) )?
    )?
( SEMI )?      (* proc_body_stmt?*)

rollback:
KW_ROLLBACK ( KW_TRAN | KW_TRANSACTION ) 
     ( ident)? 
( SEMI )?
commit:
KW_COMMIT ( KW_TRAN | KW_TRANSACTION ) ( transaction_name | @tran_name_variable )?  (*????????/*)
( SEMI )?
	*)
	*)

query_expression:
    ( query_specification | (LPAREN query_expression RPAREN) )
    (
        (KW_UNION KW_ALL? | KW_EXCEPT | KW_INTERSECT) query_specification   
    |   LPAREN query_expression RPAREN
    )?
;
query_specification:
    (* http://msdn.microsoft.com/en-us/library/ms176104.aspx *)
    KW_SELECT (* (KW_ALL | KW_DISTINCT)?
    (KW_TOP LPAREN sql_expr RPAREN KW_PRESENT? (KW_WITH KW_TIES)? )? *)
    (* <select_list> *) 
    list<<  (       
            STAR
        |   full_ident DOT STAR
        |   (
                (full_ident DOT)? (IDENT | (DOLLAR KW_IDENTITY) | (DOLLAR KW_ROWGUID) )
            |   udt_column_runtime = IDENT (
                    (DOT | DOUBLE_COLON)
                    (IDENT | IDENT LPAREN comma_list<<sql_expr>> RPAREN)
                )?
            |   sql_expr ( KW_AS? IDENT)?
            )
        |   IDENT OP_EQ sql_expr
        )
        COMMA>>
    from_stmnt?
    (KW_WHERE search_condition)?
;


(* http://msdn.microsoft.com/en-us/library/ms173545.aspx *)
search_condition:
   ( KW_NOT? search_condition_predicate | LPAREN search_condition RPAREN )
   comma_list<<(
      (KW_AND | KW_OR) KW_NOT? (search_condition_predicate | LPAREN search_condition RPAREN)
   )>>
;
search_condition_predicate:
    sql_expr ( OP_EQ | OP_LT | OP_MT | (OP_LT OP_MT) | OP_LT_EQ | OP_MT_EQ ) sql_expr
|   sql_expr KW_NOT? KW_LIKE sql_expr
|   sql_expr KW_IS KW_NOT? KW_NULL   (* TODO: add many-many items *)
;
(*
(* http://msdn.microsoft.com/en-us/library/ms175972.aspx *)
common_table_expression:
    ident                                            (* TODO: impelement it ! *)
;
*)
(* http://msdn.microsoft.com/en-us/library/ms177634.aspx *) 
from_stmnt:
    KW_FROM comma_list<<(
        full_ident (KW_AS? IDENT)? tablesample_clause? 
            (KW_WITH LPAREN table_hint+ RPAREN)?        
(*  | about rowset functions  *)
    | user_defined_function = IDENT (KW_AS? IDENT)?    
    )>>
                           
tablesample_clause:
    KW_TABLESAMPLE KW_SYSTEM? LPAREN DEC_NUMBER (KW_RERCENT | KW_ROWS)? RPAREN
        (KW_REPEATABLE LPAREN DEC_NUMBER RPAREN)?
;
(* http://msdn.microsoft.com/en-us/library/ms187373.aspx *)
table_hint: KW_NOEXPAND? NOLOCK;

(* http://msdn.microsoft.com/en-us/library/ms188332.aspx *)
execute_stmnt:
    (KW_EXEC | KW_EXECUTE) ( LOCALVAR OP_EQ )?  ( (full_ident (SEMI DEC_NUMBER)? ) | LOCALVAR )
     (* (
        (LOCALVAR OP_EQ)? 
        (((GLOBALVAR | LOCALVAR) KW_OUTPUT? )? 
         |   KW_DEFAULT?
         |   sql_value)
    )* *)
    (KW_WITH KW_RECOMPILE)?
    SEMI?
(*
execute_stmnt:
	( ( KW_EXEC | KW_EXECUTE ) )?
    ( 
      ( LOCALVAR OP_EQ )?
      ( full_ident ( SEMI DEC_NUMBER )? | LOCALVAR )  
      ( ( LOCALVAR OP_EQ )?                                           (*имя процедуры с @ +&&&*)
			( 
				((GLOBALVAR | LOCALVAR) ( KW_OUTPUT? )? 
				|( DEFAULT )? 
            )
        )?
     (* [ ,...n ]*)
      ( WITH RECOMPILE )?
    ))
SEMI;

execute_char_string:
( KW_EXEC | KW_EXECUTE ) 
        LPAREN ( LOCALVAR |  DEC_NUMBER? STRING_CONST )+ RPAREN
    ( KW_AS ( KW_LOGIN | KW_USER ) OP_EQ STRING_CONST )?
SEMI?

execute_pass-through_command:
( KW_EXEC | KW_EXECUTE )
        LPAREN ( LOCAL_VAR | DEC_NUMBER? STRING_CONST ("?")?  )+  (*&&*)
        ( ( COMMA (  LOCALVAR KW_OUTPUT? ) )+)?            (*&&*)
        RPAREN
    ( KW_AS ( KW_LOGIN | KW_USER ) OP_EQ STRING_CONST )?
    ( KW_AT ident )?
SEMI?
	*)
type_size : LPAREN (DEC_NUMBER | KW_MAX) RPAREN

sql_datatype:
      KW_BIGINT | KW_NUMERIC | KW_BIT | KW_SMALLINT  | KW_DECIMAL | "SMALLMONEY"  | "sysname"
    | "INT" | KW_TINYINT | KW_MONEY
    | KW_FLOAT (LPAREN DEC_NUMBER RPAREN)?  (* http://msdn.microsoft.com/en-us/library/ms173773.aspx *)
    | KW_REAL
    | KW_CHAR (LPAREN DEC_NUMBER RPAREN)?
    | KW_VARCHAR type_size?
    | "varbinary" type_size?
    | KW_NCHAR (LPAREN DEC_NUMBER RPAREN)?   (* http://msdn.microsoft.com/en-us/library/ms186939.aspx *)
    | KW_NVARCHAR type_size?

execute_as: (KW_EXEC | KW_EXECUTE) KW_AS (KW_CALLER | KW_SELF | KW_OWNER | username = STRING_CONST) 

binop:
	 OP_PLUS_EQ | OP_MINUS_EQ | OP_MUL_EQ | OP_DIV_EQ | OP_MOD_EQ | OP_AND_EQ | OP_XOR_EQ | OP_OR_EQ
	| OP_EQ | OP_PLUS | OP_MINUS | OP_MUL | OP_DIV | OP_MOD | OP_TILDA
	| OP_LT | OP_MT | (OP_LT OP_EQ) | (OP_MT OP_EQ) | (OP_LT OP_GT)


(* http://msdn.microsoft.com/en-us/library/ms190286.aspx *)
sql_expr:
    sql_value
  | LPAREN sql_expr RPAREN
  | LOCALVAR 
  | full_ident LPAREN comma_list<<sql_expr>> RPAREN
  | KW_SELECT sql_expr KW_FROM IDENT
  | (OP_PLUS_EQ | OP_MINUS_EQ | OP_TILDA) sql_expr 
  | GLOBALVAR
  | full_ident
  | sql_expr binop sql_expr
  | sql_value

comma_list<<item>>: list<<item COMMA>>

sql_value:
     STRING_CONST   (* http://msdn.microsoft.com/en-us/library/ms179899.aspx *)
   | DEC_NUMBER
   | KW_NULL

(* http://msdn.microsoft.com/en-us/library/ms175874.aspx *)
ident: brace_opt<<LBRACKET IDENT RBRACKET>>

full_ident: not_empty_list<<ident DOT>>
