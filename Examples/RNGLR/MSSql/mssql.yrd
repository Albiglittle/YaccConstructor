include "../../../GrammarTemplates/Common.yrd"

+ root_rule: (batch_body "GO")+

batch_body: 
    create_proc 
 |  start2
 |  set_stmnt

start2: 
    sel_expr = KW_SELECT ident KW_FROM ident
  | GLOBALVAR
  | GLOBALTEMPOBJ
  | TEMPOBJ
;

set_stmnt:
	"SET" ("ANSI_NULLS" | "ANSI_DEFAULTS" | "ANSI_NULL_DFLT" 
	| "ANSI_PADDING" | "ANSI_WARNINGS" | "CONCAT_NULL_YIELDS_NULL"
	| "CURSOR_CLOSE_ON_COMMIT" | "QUOTED_IDENTIFIER" 
	| "FMTONLY" | "FORCEPLAN" | "IMPLICIT_TRANSACTIONS"
	| "NOCOUNT" | "NOEXEC" | NUMERIC_ROUNDABORT | PARSEONLY
	| REMOTE_PROC_TRANSACTIONS | SHOWPLAN_ALL | SHOWPLAN_TEXT
	| SHOWPLAN_XML | STATISTICS (IO | PROFILE | TIME | XML)
	| XACT_ABORT ) ("ON" | "OFF")
	| SET LOCALVAR (DOT IDENT)? OP_EQ ( sql_expr | IDENT (DOT | DOUBLE_COLON) IDENT )

proc_formal_param:
      LOCALVAR (full_ident DOT)? sql_datatype
      KW_VARYING? (OP_EQ (KW_NULL | DEC_NUMBER | STRING_CONST) )?
      (KW_OUT | KW_OUTPUT)? KW_READONLY?	  	  

create_proc:
    KW_CREATE ("PROCEDURE" | "PROC")
    (ident DOT)? ident (SEMI DEC_NUMBER)?  
    comma_list<<proc_formal_param>> 
    (KW_WITH (execute_as)+ )? ( KW_FOR KW_REPLICATION )?
    KW_AS KW_BEGIN? (proc_body_stmnt SEMI?)* KW_END?
    SEMI?


(*CREATE { PROC | PROCEDURE } [schema_name.] procedure_name [ ; number ] 
[ { @parameter [ type_schema_name. ] data_type } [ VARYING ] [ = default ] 
[ OUT | OUTPUT ] ] [ ,...n ] [ WITH list<<procedure_option COMMA>> ] [ FOR REPLICATION ] 
AS { <sql_statement> [;][ ...n ] | <method_specifier> } [;] <procedure_option> ::= [ ENCRYPTION ] [ RECOMPILE ] [ EXECUTE_AS_Clause ] 
<sql_statement> ::= { [ BEGIN ] statements [ END ] } <method_specifier> ::= EXTERNAL NAME assembly_name.class_name.method_name*)


proc_body_stmnt:
    select_stmnt
|   set_stmnt 
|   execute_stmnt
|   sql_expr
|   KW_DECLARE LOCALVAR KW_AS sql_datatype (OP_EQ sql_expr)?
|   KW_RETURN sql_expr
|   KW_IF sql_expr KW_THEN ( (KW_BEGIN sql_expr* KW_END) | sql_expr) (KW_ELSE (KW_BEGIN sql_expr* KW_END) | sql_expr)?
;
(* http://msdn.microsoft.com/en-us/library/ms189499.aspx *)
select_stmnt:
(*  list<<(KW_WITH common_table_expression)* COMMA>> *)
    query_expression
    (KW_INTO full_ident (* http://msdn.microsoft.com/en-us/library/ms188029.aspx *) )?
;
(*
select_stmnt: 
    list<<(WITH common_table_expression)* COMMA>>
    (query_expression)?
    ("ORDER" BY list<<(order_by_expression | column_position (KW_ASC | KW_DESC))* COMA>>)?
    (compute)? 
    (for_clause)? 
    (select_stmnt_option)? 

compute:
	(KW_COMPUTE (KW_AVG | KW_COUNT | KW_MAX | KW_MIN | KW_STDEV | KW_STDEVP | KW_VAR | KW_VARP | KW_SUM) (sql_expr))? (*n times*)
    (KW_BY sql_expr)?   (*n times*)
;

for_clause:
	(KW_FOR (BROWSE | xml))?

xml:
	KW_XML 
	((KW_RAW (('ElementName'))? | KW_AUTO) (*??*)
		( 
			commonDirectives 
			( , (KW_XMLDATA | KW_XMLSCHEMA ( ( 'TargetNameSpaceURI' ) )? ) )?   (*??*)
			( , KW_ELEMENTS ( KW_XSINIL | KW_ABSENT )? )?
		)?
	| KW_EXPLICIT 
		( 
			comonDirictives 
			( , KW_XMLDATA )? 
		)?
	| KW_PATH ( ( 'ElementName' ) )?        (*??*)
		(
			commonDirectives 
			( , KW_ELEMENTS ( KW_XSINIL | KW_ABSENT )? )?
		)?
	) 	
;	
 
 commonDirectives:
( , KW_BINARY_BASE64 )?
( , KW_TYPE )?
( , KW_ROOT ( ( 'RootName' ) )? )?             (*??*)

select_stmnt_option:
	( OPTION ( <query_hint> [ ,...n ] ) )?              (*????????*)

	
<query_specification> ::= 
SELECT [ ALL | DISTINCT ] 
    [TOP expression [PERCENT] [ WITH TIES ] ] 
    < select_list > 
    [ INTO new_table ] 
    [ FROM { <table_source> } [ ,...n ] ] 
    [ WHERE <search_condition> ] 
    [ GROUP BY [ ALL ] group_by_expression [ ,...n ] 
                [ WITH { CUBE | ROLLUP } ]
    ]
    [ HAVING < search_condition > ]  *)
(*что-то повторяется*)
query_expression:
    ( query_specification | (LPAREN query_expression RPAREN) )
    (
        (KW_UNION KW_ALL? | KW_EXCEPT | KW_INTERSECT) query_specification   
    |   LPAREN query_expression RPAREN
    )?
;
query_specification:
    (* http://msdn.microsoft.com/en-us/library/ms176104.aspx *)
    KW_SELECT (* (KW_ALL | KW_DISTINCT)?
    (KW_TOP LPAREN sql_expr RPAREN KW_PRESENT? (KW_WITH KW_TIES)? )? *)
    (* <select_list> *) 
    list<<  (       
            STAR
        |   full_ident DOT STAR
        |   (
                (full_ident DOT)? (IDENT | (DOLLAR KW_IDENTITY) | (DOLLAR KW_ROWGUID) )
            |   udt_column_runtime = IDENT (
                    (DOT | DOUBLE_COLON)
                    (IDENT | IDENT LPAREN comma_list<<sql_expr>> RPAREN)
                )?
            |   sql_expr ( KW_AS? IDENT)?
            )
        |   IDENT OP_EQ sql_expr
        )
        COMMA>>
    from_stmnt?
    (KW_WHERE search_condition)?
;


(* http://msdn.microsoft.com/en-us/library/ms173545.aspx *)
search_condition:
   ( KW_NOT? search_condition_predicate | LPAREN search_condition RPAREN )
   comma_list<<(
      (KW_AND | KW_OR) KW_NOT? (search_condition_predicate | LPAREN search_condition RPAREN)
   )>>
;
search_condition_predicate:
    sql_expr ( OP_EQ | OP_LT | OP_MT | (OP_LT OP_MT) | OP_LT_EQ | OP_MT_EQ ) sql_expr
|   sql_expr KW_NOT? KW_LIKE sql_expr
|   sql_expr KW_IS KW_NOT? KW_NULL   (* TODO: add many-many items *)
;
(*
(* http://msdn.microsoft.com/en-us/library/ms175972.aspx *)
common_table_expression:
    ident                                            (* TODO: impelement it ! *)
;
*)
(* http://msdn.microsoft.com/en-us/library/ms177634.aspx *) 
from_stmnt:
    KW_FROM comma_list<<(
        full_ident (KW_AS? IDENT)? tablesample_clause? 
            (KW_WITH LPAREN table_hint+ RPAREN)?        
(*  | about rowset functions  *)
    | user_defined_function = IDENT (KW_AS? IDENT)?    
    )>>
                           
tablesample_clause:
    KW_TABLESAMPLE KW_SYSTEM? LPAREN DEC_NUMBER (KW_RERCENT | KW_ROWS)? RPAREN
        (KW_REPEATABLE LPAREN DEC_NUMBER RPAREN)?
;
(* http://msdn.microsoft.com/en-us/library/ms187373.aspx *)
table_hint: KW_NOEXPAND? NOLOCK;

(* http://msdn.microsoft.com/en-us/library/ms188332.aspx *)
execute_stmnt:
    (KW_EXEC | KW_EXECUTE) ( LOCALVAR OP_EQ )?  ( (full_ident (SEMI DEC_NUMBER)? ) | LOCALVAR )
     (* (
        (LOCALVAR OP_EQ)? 
        (((GLOBALVAR | LOCALVAR) KW_OUTPUT? )? 
         |   KW_DEFAULT?
         |   sql_value)
    )* *)
    (KW_WITH KW_RECOMPILE)?
    SEMI?

type_size : LPAREN (DEC_NUMBER | KW_MAX) RPAREN

sql_datatype:
      KW_BIGINT | KW_NUMERIC | KW_BIT | KW_SMALLINT  | KW_DECIMAL | "SMALLMONEY"  | "sysname"
    | "INT" | KW_TINYINT | KW_MONEY
    | KW_FLOAT (LPAREN DEC_NUMBER RPAREN)?  (* http://msdn.microsoft.com/en-us/library/ms173773.aspx *)
    | KW_REAL
    | KW_CHAR (LPAREN DEC_NUMBER RPAREN)?
    | KW_VARCHAR type_size?
    | "varbinary" type_size?
    | KW_NCHAR (LPAREN DEC_NUMBER RPAREN)?   (* http://msdn.microsoft.com/en-us/library/ms186939.aspx *)
    | KW_NVARCHAR type_size?


execute_as:
    (KW_EXEC | KW_EXECUTE) KW_AS (KW_CALLER | KW_SELF | KW_OWNER | username = STRING_CONST ) 

binop:
	 OP_PLUS_EQ | OP_MINUS_EQ | OP_MUL_EQ | OP_DIV_EQ | OP_MOD_EQ | OP_AND_EQ | OP_XOR_EQ | OP_OR_EQ
	| OP_EQ | OP_PLUS | OP_MINUS | OP_MUL | OP_DIV | OP_MOD | OP_TILDA
	| OP_LT | OP_MT | (OP_LT OP_EQ) | (OP_MT OP_EQ) | (OP_LT OP_GT)


(* http://msdn.microsoft.com/en-us/library/ms190286.aspx *)
sql_expr:
    sql_value
  | LPAREN sql_expr RPAREN
  | LOCALVAR 
  | full_ident LPAREN comma_list<<sql_expr>> RPAREN
  | KW_SELECT sql_expr KW_FROM IDENT
  | (OP_PLUS_EQ | OP_MINUS_EQ | OP_TILDA) sql_expr 
  | GLOBALVAR
  | full_ident
  | sql_expr binop sql_expr
  | sql_value

comma_list<<item>>: list<<item COMMA>>

sql_value:
     STRING_CONST   (* http://msdn.microsoft.com/en-us/library/ms179899.aspx *)
   | DEC_NUMBER
   | KW_NULL

(* http://msdn.microsoft.com/en-us/library/ms175874.aspx *)
ident:
    (LBRACKET IDENT RBRACKET)
|   IDENT

full_ident: not_empty_list<<ident DOT>>