{
module Lexer
open Microsoft.FSharp.Text.Lexing
open Microsoft.FSharp.Text
open Yard.Generators.GNESCCGenerator
open Yard.Generators.GNESCCGenerator.Tables

type MyLexeme (tag,_value) =
    member self.MValue = _value    
    interface ILexeme with    
       member self.tag = tag
       member self.CompareTo x =  compare (hash self) (hash x)
    end

}

let term = ['A'-'Z']
let nterm = ['a'-'z']
let ws = ['\t' '\r' ' ']

rule tokens = parse
 | nterm 
        {MyLexeme(getTag T_NTERM, LexBuffer<_>.LexemeString(lexbuf))}
 | term 
        {MyLexeme(getTag T_TERM, LexBuffer<_>.LexemeString(lexbuf))}
 | '\n' {MyLexeme(getTag T_DELIM, LexBuffer<_>.LexemeString(lexbuf))}
 | "->" {MyLexeme(getTag T_DRV, LexBuffer<_>.LexemeString(lexbuf))}
 | ws  {tokens lexbuf}
 | eof  {MyLexeme( Constants.gnesccEndStreamTag, LexBuffer<_>.LexemeString(lexbuf))}


{

type Lexer(lb) = 
    let locBuf = ref []
    interface ILexer with        
    
       member self.Get pos = 
        let l = !locBuf |> List.length
        if l >= pos
        then (!locBuf).[l-pos]
        else
            let t = (tokens lb) :> ILexeme
            locBuf := t :: !locBuf
            t      
    end

}